/* Autogenerated by mlir-tblgen; don't manually edit */

#ifdef GEN_PASS_DECL
// Generate declarations for all passes.
#define GEN_PASS_DECL_BUFFERREUSEPASS
#define GEN_PASS_DECL_COPYCLEANUPPASS
#define GEN_PASS_DECL_EMBEDMEMREFPRINTSPASS
#define GEN_PASS_DECL_EMBEDTFFRAMEWORKPASS
#define GEN_PASS_DECL_FUSEINNERPARALLELLOOPSPASS
#define GEN_PASS_DECL_GPUKERNELTOBLOBPASS
#define GEN_PASS_DECL_KERNELGENFINALBUFFERIZEPASS
#define GEN_PASS_DECL_PARALLELLOOPSTOSEQUENTIAL
#define GEN_PASS_DECL_PROPAGATESHAPEKNOWLEDGETOKERNELS
#define GEN_PASS_DECL_PROPAGATETFABIKNOWLEDGETOKERNELS
#define GEN_PASS_DECL_REWRITETFFRAMEWORKASSERT
#define GEN_PASS_DECL_SHAPETODESCRIPTORSPASS
#define GEN_PASS_DECL_TFKERNELTOLLVMPASS
#define GEN_PASS_DECL_TFTOJITINVOCATIONPASS
#undef GEN_PASS_DECL
#endif // GEN_PASS_DECL

//===----------------------------------------------------------------------===//
// BufferReusePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_BUFFERREUSEPASS
#undef GEN_PASS_DECL_BUFFERREUSEPASS
#endif // GEN_PASS_DECL_BUFFERREUSEPASS
#ifdef GEN_PASS_DEF_BUFFERREUSEPASS
namespace impl {

template <typename DerivedT>
class BufferReusePassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = BufferReusePassBase;

  BufferReusePassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  BufferReusePassBase(const BufferReusePassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("buffer-reuse");
  }
  ::llvm::StringRef getArgument() const override { return "buffer-reuse"; }

  ::llvm::StringRef getDescription() const override { return "Pass to find and annotate candidates for buffer reuse."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("BufferReusePass");
  }
  ::llvm::StringRef getName() const override { return "BufferReusePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(BufferReusePassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_BUFFERREUSEPASS
#endif // GEN_PASS_DEF_BUFFERREUSEPASS

//===----------------------------------------------------------------------===//
// CopyCleanupPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_COPYCLEANUPPASS
#undef GEN_PASS_DECL_COPYCLEANUPPASS
#endif // GEN_PASS_DECL_COPYCLEANUPPASS
#ifdef GEN_PASS_DEF_COPYCLEANUPPASS
namespace impl {

template <typename DerivedT>
class CopyCleanupPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = CopyCleanupPassBase;

  CopyCleanupPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  CopyCleanupPassBase(const CopyCleanupPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("copy-cleanup");
  }
  ::llvm::StringRef getArgument() const override { return "copy-cleanup"; }

  ::llvm::StringRef getDescription() const override { return "Pass to remove copies which are consumed by a GenericOp."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("CopyCleanupPass");
  }
  ::llvm::StringRef getName() const override { return "CopyCleanupPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(CopyCleanupPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_COPYCLEANUPPASS
#endif // GEN_PASS_DEF_COPYCLEANUPPASS

//===----------------------------------------------------------------------===//
// EmbedMemRefPrintsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_EMBEDMEMREFPRINTSPASS
#undef GEN_PASS_DECL_EMBEDMEMREFPRINTSPASS
#endif // GEN_PASS_DECL_EMBEDMEMREFPRINTSPASS
#ifdef GEN_PASS_DEF_EMBEDMEMREFPRINTSPASS
namespace impl {

template <typename DerivedT>
class EmbedMemRefPrintsPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = EmbedMemRefPrintsPassBase;

  EmbedMemRefPrintsPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  EmbedMemRefPrintsPassBase(const EmbedMemRefPrintsPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("embed-memref-prints");
  }
  ::llvm::StringRef getArgument() const override { return "embed-memref-prints"; }

  ::llvm::StringRef getDescription() const override { return "Pass to print content of memrefs"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("EmbedMemRefPrintsPass");
  }
  ::llvm::StringRef getName() const override { return "EmbedMemRefPrintsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<LLVM::LLVMDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(EmbedMemRefPrintsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_EMBEDMEMREFPRINTSPASS
#endif // GEN_PASS_DEF_EMBEDMEMREFPRINTSPASS

//===----------------------------------------------------------------------===//
// EmbedTFFrameworkPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_EMBEDTFFRAMEWORKPASS
#undef GEN_PASS_DECL_EMBEDTFFRAMEWORKPASS
#endif // GEN_PASS_DECL_EMBEDTFFRAMEWORKPASS
#ifdef GEN_PASS_DEF_EMBEDTFFRAMEWORKPASS
namespace impl {

template <typename DerivedT>
class EmbedTFFrameworkPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = EmbedTFFrameworkPassBase;

  EmbedTFFrameworkPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  EmbedTFFrameworkPassBase(const EmbedTFFrameworkPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("embed-tf-framework");
  }
  ::llvm::StringRef getArgument() const override { return "embed-tf-framework"; }

  ::llvm::StringRef getDescription() const override { return "Pass to embed TF Framework for allocation and assertions,"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("EmbedTFFrameworkPass");
  }
  ::llvm::StringRef getName() const override { return "EmbedTFFrameworkPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(EmbedTFFrameworkPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_EMBEDTFFRAMEWORKPASS
#endif // GEN_PASS_DEF_EMBEDTFFRAMEWORKPASS

//===----------------------------------------------------------------------===//
// FuseInnerParallelLoopsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_FUSEINNERPARALLELLOOPSPASS
#undef GEN_PASS_DECL_FUSEINNERPARALLELLOOPSPASS
#endif // GEN_PASS_DECL_FUSEINNERPARALLELLOOPSPASS
#ifdef GEN_PASS_DEF_FUSEINNERPARALLELLOOPSPASS
namespace impl {

template <typename DerivedT>
class FuseInnerParallelLoopsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = FuseInnerParallelLoopsPassBase;

  FuseInnerParallelLoopsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  FuseInnerParallelLoopsPassBase(const FuseInnerParallelLoopsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("fuse-inner-parallel-loops");
  }
  ::llvm::StringRef getArgument() const override { return "fuse-inner-parallel-loops"; }

  ::llvm::StringRef getDescription() const override { return "Limited pass to forward stores to loads."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("FuseInnerParallelLoopsPass");
  }
  ::llvm::StringRef getName() const override { return "FuseInnerParallelLoopsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(FuseInnerParallelLoopsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_FUSEINNERPARALLELLOOPSPASS
#endif // GEN_PASS_DEF_FUSEINNERPARALLELLOOPSPASS

//===----------------------------------------------------------------------===//
// GpuKernelToBlobPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_GPUKERNELTOBLOBPASS
struct GpuKernelToBlobPassOptions {
  std::string blob_annotation_ = "gpu.binary_blob";
  ::llvm::ArrayRef<std::string> architectures_;
  bool generate_fatbin_ = true;
  bool print_ptx_ = false;
  bool print_llvmir_ = false;
};
#undef GEN_PASS_DECL_GPUKERNELTOBLOBPASS
#endif // GEN_PASS_DECL_GPUKERNELTOBLOBPASS
#ifdef GEN_PASS_DEF_GPUKERNELTOBLOBPASS
namespace impl {

template <typename DerivedT>
class GpuKernelToBlobPassBase : public ::mlir::OperationPass<gpu::GPUModuleOp> {
public:
  using Base = GpuKernelToBlobPassBase;

  GpuKernelToBlobPassBase() : ::mlir::OperationPass<gpu::GPUModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  GpuKernelToBlobPassBase(const GpuKernelToBlobPassBase &other) : ::mlir::OperationPass<gpu::GPUModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gpu-kernel-to-blob");
  }
  ::llvm::StringRef getArgument() const override { return "gpu-kernel-to-blob"; }

  ::llvm::StringRef getDescription() const override { return "Pass to annotate GPU Module with its PTX"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("GpuKernelToBlobPass");
  }
  ::llvm::StringRef getName() const override { return "GpuKernelToBlobPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(GpuKernelToBlobPassBase<DerivedT>)

  GpuKernelToBlobPassBase(const GpuKernelToBlobPassOptions &options) : GpuKernelToBlobPassBase() {
    blob_annotation_ = options.blob_annotation_;
    architectures_ = options.architectures_;
    generate_fatbin_ = options.generate_fatbin_;
    print_ptx_ = options.print_ptx_;
    print_llvmir_ = options.print_llvmir_;
  }
protected:
  ::mlir::Pass::Option<std::string> blob_annotation_{*this, "blob-annotation", ::llvm::cl::desc("Blob attribute name"), ::llvm::cl::init("gpu.binary_blob")};
  ::mlir::Pass::ListOption<std::string> architectures_{*this, "arch", ::llvm::cl::desc("GPU architectures")};
  ::mlir::Pass::Option<bool> generate_fatbin_{*this, "generate-fatbin", ::llvm::cl::desc("Bundle machine code for the different architectures in one fatbin."), ::llvm::cl::init(true)};
  ::mlir::Pass::Option<bool> print_ptx_{*this, "print-ptx", ::llvm::cl::desc("Print generated PTX code per target architecture."), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<bool> print_llvmir_{*this, "print-llvmir", ::llvm::cl::desc("Print llvm ir when lowering code per target architecture."), ::llvm::cl::init(false)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_GPUKERNELTOBLOBPASS
#endif // GEN_PASS_DEF_GPUKERNELTOBLOBPASS

//===----------------------------------------------------------------------===//
// KernelgenFinalBufferizePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_KERNELGENFINALBUFFERIZEPASS
#undef GEN_PASS_DECL_KERNELGENFINALBUFFERIZEPASS
#endif // GEN_PASS_DECL_KERNELGENFINALBUFFERIZEPASS
#ifdef GEN_PASS_DEF_KERNELGENFINALBUFFERIZEPASS
namespace impl {

template <typename DerivedT>
class KernelgenFinalBufferizePassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = KernelgenFinalBufferizePassBase;

  KernelgenFinalBufferizePassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  KernelgenFinalBufferizePassBase(const KernelgenFinalBufferizePassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("kernelgen-final-bufferize");
  }
  ::llvm::StringRef getArgument() const override { return "kernelgen-final-bufferize"; }

  ::llvm::StringRef getDescription() const override { return "Pass to transform late operations on values to buffer based ones."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("KernelgenFinalBufferizePass");
  }
  ::llvm::StringRef getName() const override { return "KernelgenFinalBufferizePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(KernelgenFinalBufferizePassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_KERNELGENFINALBUFFERIZEPASS
#endif // GEN_PASS_DEF_KERNELGENFINALBUFFERIZEPASS

//===----------------------------------------------------------------------===//
// ParallelLoopsToSequential
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_PARALLELLOOPSTOSEQUENTIAL
#undef GEN_PASS_DECL_PARALLELLOOPSTOSEQUENTIAL
#endif // GEN_PASS_DECL_PARALLELLOOPSTOSEQUENTIAL
#ifdef GEN_PASS_DEF_PARALLELLOOPSTOSEQUENTIAL
namespace impl {

template <typename DerivedT>
class ParallelLoopsToSequentialBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ParallelLoopsToSequentialBase;

  ParallelLoopsToSequentialBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ParallelLoopsToSequentialBase(const ParallelLoopsToSequentialBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("parallel-loops-to-sequential");
  }
  ::llvm::StringRef getArgument() const override { return "parallel-loops-to-sequential"; }

  ::llvm::StringRef getDescription() const override { return "Pass to convert scf::ParallelOp to scf::ForOp"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ParallelLoopsToSequential");
  }
  ::llvm::StringRef getName() const override { return "ParallelLoopsToSequential"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ParallelLoopsToSequentialBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_PARALLELLOOPSTOSEQUENTIAL
#endif // GEN_PASS_DEF_PARALLELLOOPSTOSEQUENTIAL

//===----------------------------------------------------------------------===//
// PropagateShapeKnowledgeToKernels
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_PROPAGATESHAPEKNOWLEDGETOKERNELS
#undef GEN_PASS_DECL_PROPAGATESHAPEKNOWLEDGETOKERNELS
#endif // GEN_PASS_DECL_PROPAGATESHAPEKNOWLEDGETOKERNELS
#ifdef GEN_PASS_DEF_PROPAGATESHAPEKNOWLEDGETOKERNELS
namespace impl {

template <typename DerivedT>
class PropagateShapeKnowledgeToKernelsBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = PropagateShapeKnowledgeToKernelsBase;

  PropagateShapeKnowledgeToKernelsBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  PropagateShapeKnowledgeToKernelsBase(const PropagateShapeKnowledgeToKernelsBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("propagate-shape-knowledge-to-kernels");
  }
  ::llvm::StringRef getArgument() const override { return "propagate-shape-knowledge-to-kernels"; }

  ::llvm::StringRef getDescription() const override { return "Pass to propagate shape information into kernels"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("PropagateShapeKnowledgeToKernels");
  }
  ::llvm::StringRef getName() const override { return "PropagateShapeKnowledgeToKernels"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(PropagateShapeKnowledgeToKernelsBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_PROPAGATESHAPEKNOWLEDGETOKERNELS
#endif // GEN_PASS_DEF_PROPAGATESHAPEKNOWLEDGETOKERNELS

//===----------------------------------------------------------------------===//
// PropagateTfAbiKnowledgeToKernels
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_PROPAGATETFABIKNOWLEDGETOKERNELS
#undef GEN_PASS_DECL_PROPAGATETFABIKNOWLEDGETOKERNELS
#endif // GEN_PASS_DECL_PROPAGATETFABIKNOWLEDGETOKERNELS
#ifdef GEN_PASS_DEF_PROPAGATETFABIKNOWLEDGETOKERNELS
namespace impl {

template <typename DerivedT>
class PropagateTfAbiKnowledgeToKernelsBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = PropagateTfAbiKnowledgeToKernelsBase;

  PropagateTfAbiKnowledgeToKernelsBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  PropagateTfAbiKnowledgeToKernelsBase(const PropagateTfAbiKnowledgeToKernelsBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("propagate-tf-abi-knowledge-to-kernels");
  }
  ::llvm::StringRef getArgument() const override { return "propagate-tf-abi-knowledge-to-kernels"; }

  ::llvm::StringRef getDescription() const override { return "Pass to propagate tensorflow ABI knowledge to kernels"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("PropagateTfAbiKnowledgeToKernels");
  }
  ::llvm::StringRef getName() const override { return "PropagateTfAbiKnowledgeToKernels"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(PropagateTfAbiKnowledgeToKernelsBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_PROPAGATETFABIKNOWLEDGETOKERNELS
#endif // GEN_PASS_DEF_PROPAGATETFABIKNOWLEDGETOKERNELS

//===----------------------------------------------------------------------===//
// RewriteTFFrameworkAssert
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_REWRITETFFRAMEWORKASSERT
#undef GEN_PASS_DECL_REWRITETFFRAMEWORKASSERT
#endif // GEN_PASS_DECL_REWRITETFFRAMEWORKASSERT
#ifdef GEN_PASS_DEF_REWRITETFFRAMEWORKASSERT
namespace impl {

template <typename DerivedT>
class RewriteTFFrameworkAssertBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = RewriteTFFrameworkAssertBase;

  RewriteTFFrameworkAssertBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  RewriteTFFrameworkAssertBase(const RewriteTFFrameworkAssertBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("rewrite-tf-framework-assert");
  }
  ::llvm::StringRef getArgument() const override { return "rewrite-tf-framework-assert"; }

  ::llvm::StringRef getDescription() const override { return "Pass to rewrite TFAssertOps to CondBranchOp"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("RewriteTFFrameworkAssert");
  }
  ::llvm::StringRef getName() const override { return "RewriteTFFrameworkAssert"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(RewriteTFFrameworkAssertBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_REWRITETFFRAMEWORKASSERT
#endif // GEN_PASS_DEF_REWRITETFFRAMEWORKASSERT

//===----------------------------------------------------------------------===//
// ShapeToDescriptorsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_SHAPETODESCRIPTORSPASS
#undef GEN_PASS_DECL_SHAPETODESCRIPTORSPASS
#endif // GEN_PASS_DECL_SHAPETODESCRIPTORSPASS
#ifdef GEN_PASS_DEF_SHAPETODESCRIPTORSPASS
namespace impl {

template <typename DerivedT>
class ShapeToDescriptorsPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ShapeToDescriptorsPassBase;

  ShapeToDescriptorsPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ShapeToDescriptorsPassBase(const ShapeToDescriptorsPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("shape-to-descriptors");
  }
  ::llvm::StringRef getArgument() const override { return "shape-to-descriptors"; }

  ::llvm::StringRef getDescription() const override { return "Pass to transform shape computations to descriptors"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ShapeToDescriptorsPass");
  }
  ::llvm::StringRef getName() const override { return "ShapeToDescriptorsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ShapeToDescriptorsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_SHAPETODESCRIPTORSPASS
#endif // GEN_PASS_DEF_SHAPETODESCRIPTORSPASS

//===----------------------------------------------------------------------===//
// TFKernelToLLVMPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TFKERNELTOLLVMPASS
struct TFKernelToLLVMPassOptions {
  std::string blob_annotation_ = "gpu.binary_blob";
};
#undef GEN_PASS_DECL_TFKERNELTOLLVMPASS
#endif // GEN_PASS_DECL_TFKERNELTOLLVMPASS
#ifdef GEN_PASS_DEF_TFKERNELTOLLVMPASS
namespace impl {

template <typename DerivedT>
class TFKernelToLLVMPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TFKernelToLLVMPassBase;

  TFKernelToLLVMPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TFKernelToLLVMPassBase(const TFKernelToLLVMPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-kernel-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "tf-kernel-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return "Pass for applying LLVM legalization patterns."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TFKernelToLLVMPass");
  }
  ::llvm::StringRef getName() const override { return "TFKernelToLLVMPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TFKernelToLLVMPassBase<DerivedT>)

  TFKernelToLLVMPassBase(const TFKernelToLLVMPassOptions &options) : TFKernelToLLVMPassBase() {
    blob_annotation_ = options.blob_annotation_;
  }
protected:
  ::mlir::Pass::Option<std::string> blob_annotation_{*this, "blob-annotation", ::llvm::cl::desc("Blob attribute name"), ::llvm::cl::init("gpu.binary_blob")};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TFKERNELTOLLVMPASS
#endif // GEN_PASS_DEF_TFKERNELTOLLVMPASS

//===----------------------------------------------------------------------===//
// TFToJITInvocationPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TFTOJITINVOCATIONPASS
struct TFToJITInvocationPassOptions {
  ::llvm::ArrayRef<int64_t> tile_sizes_;
  ::llvm::ArrayRef<int64_t> unroll_factors_;
  int64_t max_supported_rank_;
  bool enable_ftz_;
  bool index_64bit_;
  bool cpu_codegen_;
  bool jit_i64_indexed_for_large_tensors_ = false;
};
#undef GEN_PASS_DECL_TFTOJITINVOCATIONPASS
#endif // GEN_PASS_DECL_TFTOJITINVOCATIONPASS
#ifdef GEN_PASS_DEF_TFTOJITINVOCATIONPASS
namespace impl {

template <typename DerivedT>
class TFToJITInvocationPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TFToJITInvocationPassBase;

  TFToJITInvocationPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TFToJITInvocationPassBase(const TFToJITInvocationPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-to-jit-invocation");
  }
  ::llvm::StringRef getArgument() const override { return "tf-to-jit-invocation"; }

  ::llvm::StringRef getDescription() const override { return "Pass to rewrite all TF operations to JIT invocations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TFToJITInvocationPass");
  }
  ::llvm::StringRef getName() const override { return "TFToJITInvocationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TFToJITInvocationPassBase<DerivedT>)

  TFToJITInvocationPassBase(const TFToJITInvocationPassOptions &options) : TFToJITInvocationPassBase() {
    tile_sizes_ = options.tile_sizes_;
    unroll_factors_ = options.unroll_factors_;
    max_supported_rank_ = options.max_supported_rank_;
    enable_ftz_ = options.enable_ftz_;
    index_64bit_ = options.index_64bit_;
    cpu_codegen_ = options.cpu_codegen_;
    jit_i64_indexed_for_large_tensors_ = options.jit_i64_indexed_for_large_tensors_;
  }
protected:
  ::mlir::Pass::ListOption<int64_t> tile_sizes_{*this, "tile-sizes", ::llvm::cl::desc("Tiling sizes"), llvm::cl::ZeroOrMore};
  ::mlir::Pass::ListOption<int64_t> unroll_factors_{*this, "unroll-factors", ::llvm::cl::desc("Unrolling in each tile dimension"), llvm::cl::ZeroOrMore};
  ::mlir::Pass::Option<int64_t> max_supported_rank_{*this, "max-supported-rank", ::llvm::cl::desc("Max rank that this kernel supports")};
  ::mlir::Pass::Option<bool> enable_ftz_{*this, "enable-ftz", ::llvm::cl::desc("Enable the denormal flush to zero mode when generating code")};
  ::mlir::Pass::Option<bool> index_64bit_{*this, "index_64bit", ::llvm::cl::desc("Enable the 64 bit indexing for GPU kernels")};
  ::mlir::Pass::Option<bool> cpu_codegen_{*this, "cpu-codegen", ::llvm::cl::desc("CPU codegen (false implies GPU)")};
  ::mlir::Pass::Option<bool> jit_i64_indexed_for_large_tensors_{*this, "jit_i64_indexed_for_large_tensors", ::llvm::cl::desc("Enable JIT compilation of i64-indexed kernels for large input tensors."), ::llvm::cl::init(false)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TFTOJITINVOCATIONPASS
#endif // GEN_PASS_DEF_TFTOJITINVOCATIONPASS
#ifdef GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// BufferReusePass Registration
//===----------------------------------------------------------------------===//

inline void registerBufferReusePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return transforms::CreateBufferReusePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerBufferReusePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return transforms::CreateBufferReusePass();
  });
}

//===----------------------------------------------------------------------===//
// CopyCleanupPass Registration
//===----------------------------------------------------------------------===//

inline void registerCopyCleanupPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return transforms::CreateCopyCleanupPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerCopyCleanupPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return transforms::CreateCopyCleanupPass();
  });
}

//===----------------------------------------------------------------------===//
// EmbedMemRefPrintsPass Registration
//===----------------------------------------------------------------------===//

inline void registerEmbedMemRefPrintsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return transforms::CreateEmbedMemRefPrintsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerEmbedMemRefPrintsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return transforms::CreateEmbedMemRefPrintsPass();
  });
}

//===----------------------------------------------------------------------===//
// EmbedTFFrameworkPass Registration
//===----------------------------------------------------------------------===//

inline void registerEmbedTFFrameworkPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return tf_framework::CreateEmbedTFFrameworkPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerEmbedTFFrameworkPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return tf_framework::CreateEmbedTFFrameworkPass();
  });
}

//===----------------------------------------------------------------------===//
// FuseInnerParallelLoopsPass Registration
//===----------------------------------------------------------------------===//

inline void registerFuseInnerParallelLoopsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return transforms::CreateFuseInnerParallelLoopsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerFuseInnerParallelLoopsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return transforms::CreateFuseInnerParallelLoopsPass();
  });
}

//===----------------------------------------------------------------------===//
// GpuKernelToBlobPass Registration
//===----------------------------------------------------------------------===//

inline void registerGpuKernelToBlobPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return transforms::CreateGpuKernelToBlobPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerGpuKernelToBlobPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return transforms::CreateGpuKernelToBlobPass();
  });
}

//===----------------------------------------------------------------------===//
// KernelgenFinalBufferizePass Registration
//===----------------------------------------------------------------------===//

inline void registerKernelgenFinalBufferizePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return transforms::CreateKernelgenFinalBufferizePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerKernelgenFinalBufferizePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return transforms::CreateKernelgenFinalBufferizePass();
  });
}

//===----------------------------------------------------------------------===//
// ParallelLoopsToSequential Registration
//===----------------------------------------------------------------------===//

inline void registerParallelLoopsToSequential() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return transforms::CreateParallelLoopsToSequential();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerParallelLoopsToSequentialPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return transforms::CreateParallelLoopsToSequential();
  });
}

//===----------------------------------------------------------------------===//
// PropagateShapeKnowledgeToKernels Registration
//===----------------------------------------------------------------------===//

inline void registerPropagateShapeKnowledgeToKernels() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return transforms::CreatePropagateShapeKnowledgeToKernels();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerPropagateShapeKnowledgeToKernelsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return transforms::CreatePropagateShapeKnowledgeToKernels();
  });
}

//===----------------------------------------------------------------------===//
// PropagateTfAbiKnowledgeToKernels Registration
//===----------------------------------------------------------------------===//

inline void registerPropagateTfAbiKnowledgeToKernels() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return transforms::CreatePropagateTfAbiKnowledgeToKernels();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerPropagateTfAbiKnowledgeToKernelsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return transforms::CreatePropagateTfAbiKnowledgeToKernels();
  });
}

//===----------------------------------------------------------------------===//
// RewriteTFFrameworkAssert Registration
//===----------------------------------------------------------------------===//

inline void registerRewriteTFFrameworkAssert() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return tf_framework::CreateRewriteTFFrameworkAssert();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerRewriteTFFrameworkAssertPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return tf_framework::CreateRewriteTFFrameworkAssert();
  });
}

//===----------------------------------------------------------------------===//
// ShapeToDescriptorsPass Registration
//===----------------------------------------------------------------------===//

inline void registerShapeToDescriptorsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return transforms::CreateShapeToDescriptorsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerShapeToDescriptorsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return transforms::CreateShapeToDescriptorsPass();
  });
}

//===----------------------------------------------------------------------===//
// TFKernelToLLVMPass Registration
//===----------------------------------------------------------------------===//

inline void registerTFKernelToLLVMPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return transforms::CreateTFKernelToLLVMPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTFKernelToLLVMPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return transforms::CreateTFKernelToLLVMPass();
  });
}

//===----------------------------------------------------------------------===//
// TFToJITInvocationPass Registration
//===----------------------------------------------------------------------===//

inline void registerTFToJITInvocationPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return transforms::CreateTFToJITInvocationPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTFToJITInvocationPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return transforms::CreateTFToJITInvocationPass();
  });
}

//===----------------------------------------------------------------------===//
// KernelGen Registration
//===----------------------------------------------------------------------===//

inline void registerKernelGenPasses() {
  registerBufferReusePass();
  registerCopyCleanupPass();
  registerEmbedMemRefPrintsPass();
  registerEmbedTFFrameworkPass();
  registerFuseInnerParallelLoopsPass();
  registerGpuKernelToBlobPass();
  registerKernelgenFinalBufferizePass();
  registerParallelLoopsToSequential();
  registerPropagateShapeKnowledgeToKernels();
  registerPropagateTfAbiKnowledgeToKernels();
  registerRewriteTFFrameworkAssert();
  registerShapeToDescriptorsPass();
  registerTFKernelToLLVMPass();
  registerTFToJITInvocationPass();
}
#undef GEN_PASS_REGISTRATION
#endif // GEN_PASS_REGISTRATION
// Deprecated. Please use the new per-pass macros.
#ifdef GEN_PASS_CLASSES

template <typename DerivedT>
class BufferReusePassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = BufferReusePassBase;

  BufferReusePassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  BufferReusePassBase(const BufferReusePassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("buffer-reuse");
  }
  ::llvm::StringRef getArgument() const override { return "buffer-reuse"; }

  ::llvm::StringRef getDescription() const override { return "Pass to find and annotate candidates for buffer reuse."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("BufferReusePass");
  }
  ::llvm::StringRef getName() const override { return "BufferReusePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(BufferReusePassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class CopyCleanupPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = CopyCleanupPassBase;

  CopyCleanupPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  CopyCleanupPassBase(const CopyCleanupPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("copy-cleanup");
  }
  ::llvm::StringRef getArgument() const override { return "copy-cleanup"; }

  ::llvm::StringRef getDescription() const override { return "Pass to remove copies which are consumed by a GenericOp."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("CopyCleanupPass");
  }
  ::llvm::StringRef getName() const override { return "CopyCleanupPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(CopyCleanupPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class EmbedMemRefPrintsPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = EmbedMemRefPrintsPassBase;

  EmbedMemRefPrintsPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  EmbedMemRefPrintsPassBase(const EmbedMemRefPrintsPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("embed-memref-prints");
  }
  ::llvm::StringRef getArgument() const override { return "embed-memref-prints"; }

  ::llvm::StringRef getDescription() const override { return "Pass to print content of memrefs"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("EmbedMemRefPrintsPass");
  }
  ::llvm::StringRef getName() const override { return "EmbedMemRefPrintsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<LLVM::LLVMDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(EmbedMemRefPrintsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class EmbedTFFrameworkPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = EmbedTFFrameworkPassBase;

  EmbedTFFrameworkPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  EmbedTFFrameworkPassBase(const EmbedTFFrameworkPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("embed-tf-framework");
  }
  ::llvm::StringRef getArgument() const override { return "embed-tf-framework"; }

  ::llvm::StringRef getDescription() const override { return "Pass to embed TF Framework for allocation and assertions,"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("EmbedTFFrameworkPass");
  }
  ::llvm::StringRef getName() const override { return "EmbedTFFrameworkPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(EmbedTFFrameworkPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class FuseInnerParallelLoopsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = FuseInnerParallelLoopsPassBase;

  FuseInnerParallelLoopsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  FuseInnerParallelLoopsPassBase(const FuseInnerParallelLoopsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("fuse-inner-parallel-loops");
  }
  ::llvm::StringRef getArgument() const override { return "fuse-inner-parallel-loops"; }

  ::llvm::StringRef getDescription() const override { return "Limited pass to forward stores to loads."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("FuseInnerParallelLoopsPass");
  }
  ::llvm::StringRef getName() const override { return "FuseInnerParallelLoopsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(FuseInnerParallelLoopsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class GpuKernelToBlobPassBase : public ::mlir::OperationPass<gpu::GPUModuleOp> {
public:
  using Base = GpuKernelToBlobPassBase;

  GpuKernelToBlobPassBase() : ::mlir::OperationPass<gpu::GPUModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  GpuKernelToBlobPassBase(const GpuKernelToBlobPassBase &other) : ::mlir::OperationPass<gpu::GPUModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gpu-kernel-to-blob");
  }
  ::llvm::StringRef getArgument() const override { return "gpu-kernel-to-blob"; }

  ::llvm::StringRef getDescription() const override { return "Pass to annotate GPU Module with its PTX"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("GpuKernelToBlobPass");
  }
  ::llvm::StringRef getName() const override { return "GpuKernelToBlobPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(GpuKernelToBlobPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<std::string> blob_annotation_{*this, "blob-annotation", ::llvm::cl::desc("Blob attribute name"), ::llvm::cl::init("gpu.binary_blob")};
  ::mlir::Pass::ListOption<std::string> architectures_{*this, "arch", ::llvm::cl::desc("GPU architectures")};
  ::mlir::Pass::Option<bool> generate_fatbin_{*this, "generate-fatbin", ::llvm::cl::desc("Bundle machine code for the different architectures in one fatbin."), ::llvm::cl::init(true)};
  ::mlir::Pass::Option<bool> print_ptx_{*this, "print-ptx", ::llvm::cl::desc("Print generated PTX code per target architecture."), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<bool> print_llvmir_{*this, "print-llvmir", ::llvm::cl::desc("Print llvm ir when lowering code per target architecture."), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class KernelgenFinalBufferizePassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = KernelgenFinalBufferizePassBase;

  KernelgenFinalBufferizePassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  KernelgenFinalBufferizePassBase(const KernelgenFinalBufferizePassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("kernelgen-final-bufferize");
  }
  ::llvm::StringRef getArgument() const override { return "kernelgen-final-bufferize"; }

  ::llvm::StringRef getDescription() const override { return "Pass to transform late operations on values to buffer based ones."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("KernelgenFinalBufferizePass");
  }
  ::llvm::StringRef getName() const override { return "KernelgenFinalBufferizePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(KernelgenFinalBufferizePassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ParallelLoopsToSequentialBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ParallelLoopsToSequentialBase;

  ParallelLoopsToSequentialBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ParallelLoopsToSequentialBase(const ParallelLoopsToSequentialBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("parallel-loops-to-sequential");
  }
  ::llvm::StringRef getArgument() const override { return "parallel-loops-to-sequential"; }

  ::llvm::StringRef getDescription() const override { return "Pass to convert scf::ParallelOp to scf::ForOp"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ParallelLoopsToSequential");
  }
  ::llvm::StringRef getName() const override { return "ParallelLoopsToSequential"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ParallelLoopsToSequentialBase<DerivedT>)

protected:
};

template <typename DerivedT>
class PropagateShapeKnowledgeToKernelsBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = PropagateShapeKnowledgeToKernelsBase;

  PropagateShapeKnowledgeToKernelsBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  PropagateShapeKnowledgeToKernelsBase(const PropagateShapeKnowledgeToKernelsBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("propagate-shape-knowledge-to-kernels");
  }
  ::llvm::StringRef getArgument() const override { return "propagate-shape-knowledge-to-kernels"; }

  ::llvm::StringRef getDescription() const override { return "Pass to propagate shape information into kernels"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("PropagateShapeKnowledgeToKernels");
  }
  ::llvm::StringRef getName() const override { return "PropagateShapeKnowledgeToKernels"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(PropagateShapeKnowledgeToKernelsBase<DerivedT>)

protected:
};

template <typename DerivedT>
class PropagateTfAbiKnowledgeToKernelsBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = PropagateTfAbiKnowledgeToKernelsBase;

  PropagateTfAbiKnowledgeToKernelsBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  PropagateTfAbiKnowledgeToKernelsBase(const PropagateTfAbiKnowledgeToKernelsBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("propagate-tf-abi-knowledge-to-kernels");
  }
  ::llvm::StringRef getArgument() const override { return "propagate-tf-abi-knowledge-to-kernels"; }

  ::llvm::StringRef getDescription() const override { return "Pass to propagate tensorflow ABI knowledge to kernels"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("PropagateTfAbiKnowledgeToKernels");
  }
  ::llvm::StringRef getName() const override { return "PropagateTfAbiKnowledgeToKernels"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(PropagateTfAbiKnowledgeToKernelsBase<DerivedT>)

protected:
};

template <typename DerivedT>
class RewriteTFFrameworkAssertBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = RewriteTFFrameworkAssertBase;

  RewriteTFFrameworkAssertBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  RewriteTFFrameworkAssertBase(const RewriteTFFrameworkAssertBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("rewrite-tf-framework-assert");
  }
  ::llvm::StringRef getArgument() const override { return "rewrite-tf-framework-assert"; }

  ::llvm::StringRef getDescription() const override { return "Pass to rewrite TFAssertOps to CondBranchOp"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("RewriteTFFrameworkAssert");
  }
  ::llvm::StringRef getName() const override { return "RewriteTFFrameworkAssert"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(RewriteTFFrameworkAssertBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ShapeToDescriptorsPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ShapeToDescriptorsPassBase;

  ShapeToDescriptorsPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ShapeToDescriptorsPassBase(const ShapeToDescriptorsPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("shape-to-descriptors");
  }
  ::llvm::StringRef getArgument() const override { return "shape-to-descriptors"; }

  ::llvm::StringRef getDescription() const override { return "Pass to transform shape computations to descriptors"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ShapeToDescriptorsPass");
  }
  ::llvm::StringRef getName() const override { return "ShapeToDescriptorsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ShapeToDescriptorsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TFKernelToLLVMPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TFKernelToLLVMPassBase;

  TFKernelToLLVMPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TFKernelToLLVMPassBase(const TFKernelToLLVMPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-kernel-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "tf-kernel-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return "Pass for applying LLVM legalization patterns."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TFKernelToLLVMPass");
  }
  ::llvm::StringRef getName() const override { return "TFKernelToLLVMPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TFKernelToLLVMPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<std::string> blob_annotation_{*this, "blob-annotation", ::llvm::cl::desc("Blob attribute name"), ::llvm::cl::init("gpu.binary_blob")};
};

template <typename DerivedT>
class TFToJITInvocationPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TFToJITInvocationPassBase;

  TFToJITInvocationPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TFToJITInvocationPassBase(const TFToJITInvocationPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-to-jit-invocation");
  }
  ::llvm::StringRef getArgument() const override { return "tf-to-jit-invocation"; }

  ::llvm::StringRef getDescription() const override { return "Pass to rewrite all TF operations to JIT invocations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TFToJITInvocationPass");
  }
  ::llvm::StringRef getName() const override { return "TFToJITInvocationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TFToJITInvocationPassBase<DerivedT>)

protected:
  ::mlir::Pass::ListOption<int64_t> tile_sizes_{*this, "tile-sizes", ::llvm::cl::desc("Tiling sizes"), llvm::cl::ZeroOrMore};
  ::mlir::Pass::ListOption<int64_t> unroll_factors_{*this, "unroll-factors", ::llvm::cl::desc("Unrolling in each tile dimension"), llvm::cl::ZeroOrMore};
  ::mlir::Pass::Option<int64_t> max_supported_rank_{*this, "max-supported-rank", ::llvm::cl::desc("Max rank that this kernel supports")};
  ::mlir::Pass::Option<bool> enable_ftz_{*this, "enable-ftz", ::llvm::cl::desc("Enable the denormal flush to zero mode when generating code")};
  ::mlir::Pass::Option<bool> index_64bit_{*this, "index_64bit", ::llvm::cl::desc("Enable the 64 bit indexing for GPU kernels")};
  ::mlir::Pass::Option<bool> cpu_codegen_{*this, "cpu-codegen", ::llvm::cl::desc("CPU codegen (false implies GPU)")};
  ::mlir::Pass::Option<bool> jit_i64_indexed_for_large_tensors_{*this, "jit_i64_indexed_for_large_tensors", ::llvm::cl::desc("Enable JIT compilation of i64-indexed kernels for large input tensors."), ::llvm::cl::init(false)};
};
#undef GEN_PASS_CLASSES
#endif // GEN_PASS_CLASSES
