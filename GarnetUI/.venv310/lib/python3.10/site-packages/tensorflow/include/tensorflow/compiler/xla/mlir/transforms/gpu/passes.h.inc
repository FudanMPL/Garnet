/* Autogenerated by mlir-tblgen; don't manually edit */

#ifdef GEN_PASS_DECL
// Generate declarations for all passes.
#define GEN_PASS_DECL_ADDHLOTRACEANNOTATIONSPASS
#define GEN_PASS_DECL_CONVERTGPUTOGPURUNTIMEPASS
#define GEN_PASS_DECL_CONVERTLAUNCHFUNCTOCUDAGRAPHPASS
#define GEN_PASS_DECL_CONVERTLMHLOGPUTOGPURUNTIMEPASS
#define GEN_PASS_DECL_CONVERTLMHLOTOGPULAUNCHPASS
#define GEN_PASS_DECL_CONVERTLMHLOTOGPURUNTIMEPASS
#define GEN_PASS_DECL_CONVERTMEMREFGETGLOBALTOARGPASS
#undef GEN_PASS_DECL
#endif // GEN_PASS_DECL

//===----------------------------------------------------------------------===//
// AddHloTraceAnnotationsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_ADDHLOTRACEANNOTATIONSPASS
#undef GEN_PASS_DECL_ADDHLOTRACEANNOTATIONSPASS
#endif // GEN_PASS_DECL_ADDHLOTRACEANNOTATIONSPASS
#ifdef GEN_PASS_DEF_ADDHLOTRACEANNOTATIONSPASS
namespace impl {

template <typename DerivedT>
class AddHloTraceAnnotationsPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = AddHloTraceAnnotationsPassBase;

  AddHloTraceAnnotationsPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  AddHloTraceAnnotationsPassBase(const AddHloTraceAnnotationsPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-add-hlo-trace-annotations");
  }
  ::llvm::StringRef getArgument() const override { return "xla-add-hlo-trace-annotations"; }

  ::llvm::StringRef getDescription() const override { return "Adds HLO trace annotations to the supported operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AddHloTraceAnnotationsPass");
  }
  ::llvm::StringRef getName() const override { return "AddHloTraceAnnotationsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AddHloTraceAnnotationsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_ADDHLOTRACEANNOTATIONSPASS
#endif // GEN_PASS_DEF_ADDHLOTRACEANNOTATIONSPASS

//===----------------------------------------------------------------------===//
// ConvertGpuToGpuRuntimePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTGPUTOGPURUNTIMEPASS
#undef GEN_PASS_DECL_CONVERTGPUTOGPURUNTIMEPASS
#endif // GEN_PASS_DECL_CONVERTGPUTOGPURUNTIMEPASS
#ifdef GEN_PASS_DEF_CONVERTGPUTOGPURUNTIMEPASS
namespace impl {

template <typename DerivedT>
class ConvertGpuToGpuRuntimePassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ConvertGpuToGpuRuntimePassBase;

  ConvertGpuToGpuRuntimePassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertGpuToGpuRuntimePassBase(const ConvertGpuToGpuRuntimePassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-to-gpu-runtime");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-to-gpu-runtime"; }

  ::llvm::StringRef getDescription() const override { return "Converts gpu operations to XLA Gpu runtime custom calls"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertGpuToGpuRuntimePass");
  }
  ::llvm::StringRef getName() const override { return "ConvertGpuToGpuRuntimePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertGpuToGpuRuntimePassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CONVERTGPUTOGPURUNTIMEPASS
#endif // GEN_PASS_DEF_CONVERTGPUTOGPURUNTIMEPASS

//===----------------------------------------------------------------------===//
// ConvertLaunchFuncToCudaGraphPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTLAUNCHFUNCTOCUDAGRAPHPASS
#undef GEN_PASS_DECL_CONVERTLAUNCHFUNCTOCUDAGRAPHPASS
#endif // GEN_PASS_DECL_CONVERTLAUNCHFUNCTOCUDAGRAPHPASS
#ifdef GEN_PASS_DEF_CONVERTLAUNCHFUNCTOCUDAGRAPHPASS
namespace impl {

template <typename DerivedT>
class ConvertLaunchFuncToCudaGraphPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ConvertLaunchFuncToCudaGraphPassBase;

  ConvertLaunchFuncToCudaGraphPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertLaunchFuncToCudaGraphPassBase(const ConvertLaunchFuncToCudaGraphPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-launch-func-to-cuda-graphs");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-launch-func-to-cuda-graphs"; }

  ::llvm::StringRef getDescription() const override { return "Capture sequence of Gpu function launches as cuda graphs"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertLaunchFuncToCudaGraphPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertLaunchFuncToCudaGraphPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertLaunchFuncToCudaGraphPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CONVERTLAUNCHFUNCTOCUDAGRAPHPASS
#endif // GEN_PASS_DEF_CONVERTLAUNCHFUNCTOCUDAGRAPHPASS

//===----------------------------------------------------------------------===//
// ConvertLmhloGpuToGpuRuntimePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTLMHLOGPUTOGPURUNTIMEPASS
#undef GEN_PASS_DECL_CONVERTLMHLOGPUTOGPURUNTIMEPASS
#endif // GEN_PASS_DECL_CONVERTLMHLOGPUTOGPURUNTIMEPASS
#ifdef GEN_PASS_DEF_CONVERTLMHLOGPUTOGPURUNTIMEPASS
namespace impl {

template <typename DerivedT>
class ConvertLmhloGpuToGpuRuntimePassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ConvertLmhloGpuToGpuRuntimePassBase;

  ConvertLmhloGpuToGpuRuntimePassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertLmhloGpuToGpuRuntimePassBase(const ConvertLmhloGpuToGpuRuntimePassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-lmhlo-gpu-to-gpu-runtime");
  }
  ::llvm::StringRef getArgument() const override { return "xla-lmhlo-gpu-to-gpu-runtime"; }

  ::llvm::StringRef getDescription() const override { return "Converts lmhlo_gpu operations to XLA Gpu runtime custom calls"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertLmhloGpuToGpuRuntimePass");
  }
  ::llvm::StringRef getName() const override { return "ConvertLmhloGpuToGpuRuntimePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertLmhloGpuToGpuRuntimePassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CONVERTLMHLOGPUTOGPURUNTIMEPASS
#endif // GEN_PASS_DEF_CONVERTLMHLOGPUTOGPURUNTIMEPASS

//===----------------------------------------------------------------------===//
// ConvertLmhloToGpuLaunchPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTLMHLOTOGPULAUNCHPASS
#undef GEN_PASS_DECL_CONVERTLMHLOTOGPULAUNCHPASS
#endif // GEN_PASS_DECL_CONVERTLMHLOTOGPULAUNCHPASS
#ifdef GEN_PASS_DEF_CONVERTLMHLOTOGPULAUNCHPASS
namespace impl {

template <typename DerivedT>
class ConvertLmhloToGpuLaunchPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ConvertLmhloToGpuLaunchPassBase;

  ConvertLmhloToGpuLaunchPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertLmhloToGpuLaunchPassBase(const ConvertLmhloToGpuLaunchPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-lmhlo-to-gpu-launch");
  }
  ::llvm::StringRef getArgument() const override { return "xla-lmhlo-to-gpu-launch"; }

  ::llvm::StringRef getDescription() const override { return "Converts lmhlo fusions to Gpu dialect kernel launch"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertLmhloToGpuLaunchPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertLmhloToGpuLaunchPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertLmhloToGpuLaunchPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CONVERTLMHLOTOGPULAUNCHPASS
#endif // GEN_PASS_DEF_CONVERTLMHLOTOGPULAUNCHPASS

//===----------------------------------------------------------------------===//
// ConvertLmhloToGpuRuntimePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTLMHLOTOGPURUNTIMEPASS
#undef GEN_PASS_DECL_CONVERTLMHLOTOGPURUNTIMEPASS
#endif // GEN_PASS_DECL_CONVERTLMHLOTOGPURUNTIMEPASS
#ifdef GEN_PASS_DEF_CONVERTLMHLOTOGPURUNTIMEPASS
namespace impl {

template <typename DerivedT>
class ConvertLmhloToGpuRuntimePassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ConvertLmhloToGpuRuntimePassBase;

  ConvertLmhloToGpuRuntimePassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertLmhloToGpuRuntimePassBase(const ConvertLmhloToGpuRuntimePassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-lmhlo-to-gpu-runtime");
  }
  ::llvm::StringRef getArgument() const override { return "xla-lmhlo-to-gpu-runtime"; }

  ::llvm::StringRef getDescription() const override { return "Converts lmhlo operations to XLA Gpu runtime custom calls"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertLmhloToGpuRuntimePass");
  }
  ::llvm::StringRef getName() const override { return "ConvertLmhloToGpuRuntimePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertLmhloToGpuRuntimePassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CONVERTLMHLOTOGPURUNTIMEPASS
#endif // GEN_PASS_DEF_CONVERTLMHLOTOGPURUNTIMEPASS

//===----------------------------------------------------------------------===//
// ConvertMemrefGetGlobalToArgPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTMEMREFGETGLOBALTOARGPASS
struct ConvertMemrefGetGlobalToArgPassOptions {
  int64_t min_num_elements_ = 0;
};
#undef GEN_PASS_DECL_CONVERTMEMREFGETGLOBALTOARGPASS
#endif // GEN_PASS_DECL_CONVERTMEMREFGETGLOBALTOARGPASS
#ifdef GEN_PASS_DEF_CONVERTMEMREFGETGLOBALTOARGPASS
namespace impl {

template <typename DerivedT>
class ConvertMemrefGetGlobalToArgPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ConvertMemrefGetGlobalToArgPassBase;

  ConvertMemrefGetGlobalToArgPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertMemrefGetGlobalToArgPassBase(const ConvertMemrefGetGlobalToArgPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-memref-get-global-to-arg");
  }
  ::llvm::StringRef getArgument() const override { return "xla-memref-get-global-to-arg"; }

  ::llvm::StringRef getDescription() const override { return "Converts memref.get_global corresponding to lmhlo constants"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertMemrefGetGlobalToArgPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertMemrefGetGlobalToArgPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertMemrefGetGlobalToArgPassBase<DerivedT>)

  ConvertMemrefGetGlobalToArgPassBase(const ConvertMemrefGetGlobalToArgPassOptions &options) : ConvertMemrefGetGlobalToArgPassBase() {
    min_num_elements_ = options.min_num_elements_;
  }
protected:
  ::mlir::Pass::Option<int64_t> min_num_elements_{*this, "min-num-elements", ::llvm::cl::desc("Do not convert `memref.get_global` operation if the number of elements is smaller than the given value."), ::llvm::cl::init(0)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CONVERTMEMREFGETGLOBALTOARGPASS
#endif // GEN_PASS_DEF_CONVERTMEMREFGETGLOBALTOARGPASS
#ifdef GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// AddHloTraceAnnotationsPass Registration
//===----------------------------------------------------------------------===//

inline void registerAddHloTraceAnnotationsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createAddHloTraceAnnotationsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerAddHloTraceAnnotationsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createAddHloTraceAnnotationsPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertGpuToGpuRuntimePass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertGpuToGpuRuntimePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertGpuToGpuRuntimePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertGpuToGpuRuntimePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertGpuToGpuRuntimePass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertLaunchFuncToCudaGraphPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertLaunchFuncToCudaGraphPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertLaunchFuncToCudaGraphPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertLaunchFuncToCudaGraphPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertLaunchFuncToCudaGraphPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertLmhloGpuToGpuRuntimePass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertLmhloGpuToGpuRuntimePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertLmhloGpuToGpuRuntimePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertLmhloGpuToGpuRuntimePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertLmhloGpuToGpuRuntimePass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertLmhloToGpuLaunchPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertLmhloToGpuLaunchPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertLmhloToGpuLaunchPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertLmhloToGpuLaunchPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertLmhloToGpuLaunchPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertLmhloToGpuRuntimePass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertLmhloToGpuRuntimePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertLmhloToGpuRuntimePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertLmhloToGpuRuntimePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertLmhloToGpuRuntimePass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertMemrefGetGlobalToArgPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertMemrefGetGlobalToArgPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertMemrefGetGlobalToArgPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertMemrefGetGlobalToArgPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertMemrefGetGlobalToArgPass();
  });
}

//===----------------------------------------------------------------------===//
// GpuTransforms Registration
//===----------------------------------------------------------------------===//

inline void registerGpuTransformsPasses() {
  registerAddHloTraceAnnotationsPass();
  registerConvertGpuToGpuRuntimePass();
  registerConvertLaunchFuncToCudaGraphPass();
  registerConvertLmhloGpuToGpuRuntimePass();
  registerConvertLmhloToGpuLaunchPass();
  registerConvertLmhloToGpuRuntimePass();
  registerConvertMemrefGetGlobalToArgPass();
}
#undef GEN_PASS_REGISTRATION
#endif // GEN_PASS_REGISTRATION
// Deprecated. Please use the new per-pass macros.
#ifdef GEN_PASS_CLASSES

template <typename DerivedT>
class AddHloTraceAnnotationsPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = AddHloTraceAnnotationsPassBase;

  AddHloTraceAnnotationsPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  AddHloTraceAnnotationsPassBase(const AddHloTraceAnnotationsPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-add-hlo-trace-annotations");
  }
  ::llvm::StringRef getArgument() const override { return "xla-add-hlo-trace-annotations"; }

  ::llvm::StringRef getDescription() const override { return "Adds HLO trace annotations to the supported operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AddHloTraceAnnotationsPass");
  }
  ::llvm::StringRef getName() const override { return "AddHloTraceAnnotationsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AddHloTraceAnnotationsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ConvertGpuToGpuRuntimePassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ConvertGpuToGpuRuntimePassBase;

  ConvertGpuToGpuRuntimePassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertGpuToGpuRuntimePassBase(const ConvertGpuToGpuRuntimePassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-to-gpu-runtime");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-to-gpu-runtime"; }

  ::llvm::StringRef getDescription() const override { return "Converts gpu operations to XLA Gpu runtime custom calls"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertGpuToGpuRuntimePass");
  }
  ::llvm::StringRef getName() const override { return "ConvertGpuToGpuRuntimePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertGpuToGpuRuntimePassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ConvertLaunchFuncToCudaGraphPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ConvertLaunchFuncToCudaGraphPassBase;

  ConvertLaunchFuncToCudaGraphPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertLaunchFuncToCudaGraphPassBase(const ConvertLaunchFuncToCudaGraphPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-launch-func-to-cuda-graphs");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-launch-func-to-cuda-graphs"; }

  ::llvm::StringRef getDescription() const override { return "Capture sequence of Gpu function launches as cuda graphs"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertLaunchFuncToCudaGraphPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertLaunchFuncToCudaGraphPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertLaunchFuncToCudaGraphPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ConvertLmhloGpuToGpuRuntimePassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ConvertLmhloGpuToGpuRuntimePassBase;

  ConvertLmhloGpuToGpuRuntimePassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertLmhloGpuToGpuRuntimePassBase(const ConvertLmhloGpuToGpuRuntimePassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-lmhlo-gpu-to-gpu-runtime");
  }
  ::llvm::StringRef getArgument() const override { return "xla-lmhlo-gpu-to-gpu-runtime"; }

  ::llvm::StringRef getDescription() const override { return "Converts lmhlo_gpu operations to XLA Gpu runtime custom calls"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertLmhloGpuToGpuRuntimePass");
  }
  ::llvm::StringRef getName() const override { return "ConvertLmhloGpuToGpuRuntimePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertLmhloGpuToGpuRuntimePassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ConvertLmhloToGpuLaunchPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ConvertLmhloToGpuLaunchPassBase;

  ConvertLmhloToGpuLaunchPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertLmhloToGpuLaunchPassBase(const ConvertLmhloToGpuLaunchPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-lmhlo-to-gpu-launch");
  }
  ::llvm::StringRef getArgument() const override { return "xla-lmhlo-to-gpu-launch"; }

  ::llvm::StringRef getDescription() const override { return "Converts lmhlo fusions to Gpu dialect kernel launch"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertLmhloToGpuLaunchPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertLmhloToGpuLaunchPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertLmhloToGpuLaunchPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ConvertLmhloToGpuRuntimePassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ConvertLmhloToGpuRuntimePassBase;

  ConvertLmhloToGpuRuntimePassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertLmhloToGpuRuntimePassBase(const ConvertLmhloToGpuRuntimePassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-lmhlo-to-gpu-runtime");
  }
  ::llvm::StringRef getArgument() const override { return "xla-lmhlo-to-gpu-runtime"; }

  ::llvm::StringRef getDescription() const override { return "Converts lmhlo operations to XLA Gpu runtime custom calls"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertLmhloToGpuRuntimePass");
  }
  ::llvm::StringRef getName() const override { return "ConvertLmhloToGpuRuntimePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertLmhloToGpuRuntimePassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ConvertMemrefGetGlobalToArgPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ConvertMemrefGetGlobalToArgPassBase;

  ConvertMemrefGetGlobalToArgPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertMemrefGetGlobalToArgPassBase(const ConvertMemrefGetGlobalToArgPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-memref-get-global-to-arg");
  }
  ::llvm::StringRef getArgument() const override { return "xla-memref-get-global-to-arg"; }

  ::llvm::StringRef getDescription() const override { return "Converts memref.get_global corresponding to lmhlo constants"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertMemrefGetGlobalToArgPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertMemrefGetGlobalToArgPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertMemrefGetGlobalToArgPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<int64_t> min_num_elements_{*this, "min-num-elements", ::llvm::cl::desc("Do not convert `memref.get_global` operation if the number of elements is smaller than the given value."), ::llvm::cl::init(0)};
};
#undef GEN_PASS_CLASSES
#endif // GEN_PASS_CLASSES
