// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tensorflow/core/protobuf/coordination_service.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "tensorflow/compiler/xla/pjrt/distributed/protocol.pb.h"
#include "tensorflow/core/framework/device_attributes.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[37]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto;
namespace tensorflow {
class BarrierRequest;
class BarrierRequestDefaultTypeInternal;
extern BarrierRequestDefaultTypeInternal _BarrierRequest_default_instance_;
class BarrierResponse;
class BarrierResponseDefaultTypeInternal;
extern BarrierResponseDefaultTypeInternal _BarrierResponse_default_instance_;
class CancelBarrierRequest;
class CancelBarrierRequestDefaultTypeInternal;
extern CancelBarrierRequestDefaultTypeInternal _CancelBarrierRequest_default_instance_;
class CancelBarrierResponse;
class CancelBarrierResponseDefaultTypeInternal;
extern CancelBarrierResponseDefaultTypeInternal _CancelBarrierResponse_default_instance_;
class CoordinatedTask;
class CoordinatedTaskDefaultTypeInternal;
extern CoordinatedTaskDefaultTypeInternal _CoordinatedTask_default_instance_;
class CoordinatedTaskStateInfo;
class CoordinatedTaskStateInfoDefaultTypeInternal;
extern CoordinatedTaskStateInfoDefaultTypeInternal _CoordinatedTaskStateInfo_default_instance_;
class CoordinationServiceDeviceInfo;
class CoordinationServiceDeviceInfoDefaultTypeInternal;
extern CoordinationServiceDeviceInfoDefaultTypeInternal _CoordinationServiceDeviceInfo_default_instance_;
class CoordinationServiceError;
class CoordinationServiceErrorDefaultTypeInternal;
extern CoordinationServiceErrorDefaultTypeInternal _CoordinationServiceError_default_instance_;
class DeleteKeyValueRequest;
class DeleteKeyValueRequestDefaultTypeInternal;
extern DeleteKeyValueRequestDefaultTypeInternal _DeleteKeyValueRequest_default_instance_;
class DeleteKeyValueResponse;
class DeleteKeyValueResponseDefaultTypeInternal;
extern DeleteKeyValueResponseDefaultTypeInternal _DeleteKeyValueResponse_default_instance_;
class GetKeyValueDirRequest;
class GetKeyValueDirRequestDefaultTypeInternal;
extern GetKeyValueDirRequestDefaultTypeInternal _GetKeyValueDirRequest_default_instance_;
class GetKeyValueDirResponse;
class GetKeyValueDirResponseDefaultTypeInternal;
extern GetKeyValueDirResponseDefaultTypeInternal _GetKeyValueDirResponse_default_instance_;
class GetKeyValueRequest;
class GetKeyValueRequestDefaultTypeInternal;
extern GetKeyValueRequestDefaultTypeInternal _GetKeyValueRequest_default_instance_;
class GetKeyValueResponse;
class GetKeyValueResponseDefaultTypeInternal;
extern GetKeyValueResponseDefaultTypeInternal _GetKeyValueResponse_default_instance_;
class GetTaskStateRequest;
class GetTaskStateRequestDefaultTypeInternal;
extern GetTaskStateRequestDefaultTypeInternal _GetTaskStateRequest_default_instance_;
class GetTaskStateResponse;
class GetTaskStateResponseDefaultTypeInternal;
extern GetTaskStateResponseDefaultTypeInternal _GetTaskStateResponse_default_instance_;
class HeartbeatRequest;
class HeartbeatRequestDefaultTypeInternal;
extern HeartbeatRequestDefaultTypeInternal _HeartbeatRequest_default_instance_;
class HeartbeatResponse;
class HeartbeatResponseDefaultTypeInternal;
extern HeartbeatResponseDefaultTypeInternal _HeartbeatResponse_default_instance_;
class InsertKeyValueRequest;
class InsertKeyValueRequestDefaultTypeInternal;
extern InsertKeyValueRequestDefaultTypeInternal _InsertKeyValueRequest_default_instance_;
class InsertKeyValueResponse;
class InsertKeyValueResponseDefaultTypeInternal;
extern InsertKeyValueResponseDefaultTypeInternal _InsertKeyValueResponse_default_instance_;
class KeyValueEntry;
class KeyValueEntryDefaultTypeInternal;
extern KeyValueEntryDefaultTypeInternal _KeyValueEntry_default_instance_;
class RegisterTaskRequest;
class RegisterTaskRequestDefaultTypeInternal;
extern RegisterTaskRequestDefaultTypeInternal _RegisterTaskRequest_default_instance_;
class RegisterTaskResponse;
class RegisterTaskResponseDefaultTypeInternal;
extern RegisterTaskResponseDefaultTypeInternal _RegisterTaskResponse_default_instance_;
class ReportErrorToServiceRequest;
class ReportErrorToServiceRequestDefaultTypeInternal;
extern ReportErrorToServiceRequestDefaultTypeInternal _ReportErrorToServiceRequest_default_instance_;
class ReportErrorToServiceResponse;
class ReportErrorToServiceResponseDefaultTypeInternal;
extern ReportErrorToServiceResponseDefaultTypeInternal _ReportErrorToServiceResponse_default_instance_;
class ReportErrorToTaskRequest;
class ReportErrorToTaskRequestDefaultTypeInternal;
extern ReportErrorToTaskRequestDefaultTypeInternal _ReportErrorToTaskRequest_default_instance_;
class ReportErrorToTaskResponse;
class ReportErrorToTaskResponseDefaultTypeInternal;
extern ReportErrorToTaskResponseDefaultTypeInternal _ReportErrorToTaskResponse_default_instance_;
class ResetTaskRequest;
class ResetTaskRequestDefaultTypeInternal;
extern ResetTaskRequestDefaultTypeInternal _ResetTaskRequest_default_instance_;
class ResetTaskResponse;
class ResetTaskResponseDefaultTypeInternal;
extern ResetTaskResponseDefaultTypeInternal _ResetTaskResponse_default_instance_;
class ShutdownTaskRequest;
class ShutdownTaskRequestDefaultTypeInternal;
extern ShutdownTaskRequestDefaultTypeInternal _ShutdownTaskRequest_default_instance_;
class ShutdownTaskResponse;
class ShutdownTaskResponseDefaultTypeInternal;
extern ShutdownTaskResponseDefaultTypeInternal _ShutdownTaskResponse_default_instance_;
class TfDeviceList;
class TfDeviceListDefaultTypeInternal;
extern TfDeviceListDefaultTypeInternal _TfDeviceList_default_instance_;
class TryGetKeyValueRequest;
class TryGetKeyValueRequestDefaultTypeInternal;
extern TryGetKeyValueRequestDefaultTypeInternal _TryGetKeyValueRequest_default_instance_;
class TryGetKeyValueResponse;
class TryGetKeyValueResponseDefaultTypeInternal;
extern TryGetKeyValueResponseDefaultTypeInternal _TryGetKeyValueResponse_default_instance_;
class WaitForAllTasksRequest;
class WaitForAllTasksRequestDefaultTypeInternal;
extern WaitForAllTasksRequestDefaultTypeInternal _WaitForAllTasksRequest_default_instance_;
class WaitForAllTasksResponse;
class WaitForAllTasksResponseDefaultTypeInternal;
extern WaitForAllTasksResponseDefaultTypeInternal _WaitForAllTasksResponse_default_instance_;
class XlaDeviceList;
class XlaDeviceListDefaultTypeInternal;
extern XlaDeviceListDefaultTypeInternal _XlaDeviceList_default_instance_;
}  // namespace tensorflow
PROTOBUF_NAMESPACE_OPEN
template<> ::tensorflow::BarrierRequest* Arena::CreateMaybeMessage<::tensorflow::BarrierRequest>(Arena*);
template<> ::tensorflow::BarrierResponse* Arena::CreateMaybeMessage<::tensorflow::BarrierResponse>(Arena*);
template<> ::tensorflow::CancelBarrierRequest* Arena::CreateMaybeMessage<::tensorflow::CancelBarrierRequest>(Arena*);
template<> ::tensorflow::CancelBarrierResponse* Arena::CreateMaybeMessage<::tensorflow::CancelBarrierResponse>(Arena*);
template<> ::tensorflow::CoordinatedTask* Arena::CreateMaybeMessage<::tensorflow::CoordinatedTask>(Arena*);
template<> ::tensorflow::CoordinatedTaskStateInfo* Arena::CreateMaybeMessage<::tensorflow::CoordinatedTaskStateInfo>(Arena*);
template<> ::tensorflow::CoordinationServiceDeviceInfo* Arena::CreateMaybeMessage<::tensorflow::CoordinationServiceDeviceInfo>(Arena*);
template<> ::tensorflow::CoordinationServiceError* Arena::CreateMaybeMessage<::tensorflow::CoordinationServiceError>(Arena*);
template<> ::tensorflow::DeleteKeyValueRequest* Arena::CreateMaybeMessage<::tensorflow::DeleteKeyValueRequest>(Arena*);
template<> ::tensorflow::DeleteKeyValueResponse* Arena::CreateMaybeMessage<::tensorflow::DeleteKeyValueResponse>(Arena*);
template<> ::tensorflow::GetKeyValueDirRequest* Arena::CreateMaybeMessage<::tensorflow::GetKeyValueDirRequest>(Arena*);
template<> ::tensorflow::GetKeyValueDirResponse* Arena::CreateMaybeMessage<::tensorflow::GetKeyValueDirResponse>(Arena*);
template<> ::tensorflow::GetKeyValueRequest* Arena::CreateMaybeMessage<::tensorflow::GetKeyValueRequest>(Arena*);
template<> ::tensorflow::GetKeyValueResponse* Arena::CreateMaybeMessage<::tensorflow::GetKeyValueResponse>(Arena*);
template<> ::tensorflow::GetTaskStateRequest* Arena::CreateMaybeMessage<::tensorflow::GetTaskStateRequest>(Arena*);
template<> ::tensorflow::GetTaskStateResponse* Arena::CreateMaybeMessage<::tensorflow::GetTaskStateResponse>(Arena*);
template<> ::tensorflow::HeartbeatRequest* Arena::CreateMaybeMessage<::tensorflow::HeartbeatRequest>(Arena*);
template<> ::tensorflow::HeartbeatResponse* Arena::CreateMaybeMessage<::tensorflow::HeartbeatResponse>(Arena*);
template<> ::tensorflow::InsertKeyValueRequest* Arena::CreateMaybeMessage<::tensorflow::InsertKeyValueRequest>(Arena*);
template<> ::tensorflow::InsertKeyValueResponse* Arena::CreateMaybeMessage<::tensorflow::InsertKeyValueResponse>(Arena*);
template<> ::tensorflow::KeyValueEntry* Arena::CreateMaybeMessage<::tensorflow::KeyValueEntry>(Arena*);
template<> ::tensorflow::RegisterTaskRequest* Arena::CreateMaybeMessage<::tensorflow::RegisterTaskRequest>(Arena*);
template<> ::tensorflow::RegisterTaskResponse* Arena::CreateMaybeMessage<::tensorflow::RegisterTaskResponse>(Arena*);
template<> ::tensorflow::ReportErrorToServiceRequest* Arena::CreateMaybeMessage<::tensorflow::ReportErrorToServiceRequest>(Arena*);
template<> ::tensorflow::ReportErrorToServiceResponse* Arena::CreateMaybeMessage<::tensorflow::ReportErrorToServiceResponse>(Arena*);
template<> ::tensorflow::ReportErrorToTaskRequest* Arena::CreateMaybeMessage<::tensorflow::ReportErrorToTaskRequest>(Arena*);
template<> ::tensorflow::ReportErrorToTaskResponse* Arena::CreateMaybeMessage<::tensorflow::ReportErrorToTaskResponse>(Arena*);
template<> ::tensorflow::ResetTaskRequest* Arena::CreateMaybeMessage<::tensorflow::ResetTaskRequest>(Arena*);
template<> ::tensorflow::ResetTaskResponse* Arena::CreateMaybeMessage<::tensorflow::ResetTaskResponse>(Arena*);
template<> ::tensorflow::ShutdownTaskRequest* Arena::CreateMaybeMessage<::tensorflow::ShutdownTaskRequest>(Arena*);
template<> ::tensorflow::ShutdownTaskResponse* Arena::CreateMaybeMessage<::tensorflow::ShutdownTaskResponse>(Arena*);
template<> ::tensorflow::TfDeviceList* Arena::CreateMaybeMessage<::tensorflow::TfDeviceList>(Arena*);
template<> ::tensorflow::TryGetKeyValueRequest* Arena::CreateMaybeMessage<::tensorflow::TryGetKeyValueRequest>(Arena*);
template<> ::tensorflow::TryGetKeyValueResponse* Arena::CreateMaybeMessage<::tensorflow::TryGetKeyValueResponse>(Arena*);
template<> ::tensorflow::WaitForAllTasksRequest* Arena::CreateMaybeMessage<::tensorflow::WaitForAllTasksRequest>(Arena*);
template<> ::tensorflow::WaitForAllTasksResponse* Arena::CreateMaybeMessage<::tensorflow::WaitForAllTasksResponse>(Arena*);
template<> ::tensorflow::XlaDeviceList* Arena::CreateMaybeMessage<::tensorflow::XlaDeviceList>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace tensorflow {

enum CoordinatedTaskState : int {
  TASKSTATE_UNSPECIFIED = 0,
  TASKSTATE_UNINITIALIZED = 1,
  TASKSTATE_DISCONNECTED = 2,
  TASKSTATE_CONNECTED = 3,
  TASKSTATE_ERROR = 4,
  CoordinatedTaskState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CoordinatedTaskState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CoordinatedTaskState_IsValid(int value);
constexpr CoordinatedTaskState CoordinatedTaskState_MIN = TASKSTATE_UNSPECIFIED;
constexpr CoordinatedTaskState CoordinatedTaskState_MAX = TASKSTATE_ERROR;
constexpr int CoordinatedTaskState_ARRAYSIZE = CoordinatedTaskState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CoordinatedTaskState_descriptor();
template<typename T>
inline const std::string& CoordinatedTaskState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CoordinatedTaskState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CoordinatedTaskState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CoordinatedTaskState_descriptor(), enum_t_value);
}
inline bool CoordinatedTaskState_Parse(
    const std::string& name, CoordinatedTaskState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CoordinatedTaskState>(
    CoordinatedTaskState_descriptor(), name, value);
}
// ===================================================================

class CoordinatedTask :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.CoordinatedTask) */ {
 public:
  CoordinatedTask();
  virtual ~CoordinatedTask();

  CoordinatedTask(const CoordinatedTask& from);
  CoordinatedTask(CoordinatedTask&& from) noexcept
    : CoordinatedTask() {
    *this = ::std::move(from);
  }

  inline CoordinatedTask& operator=(const CoordinatedTask& from) {
    CopyFrom(from);
    return *this;
  }
  inline CoordinatedTask& operator=(CoordinatedTask&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CoordinatedTask& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CoordinatedTask* internal_default_instance() {
    return reinterpret_cast<const CoordinatedTask*>(
               &_CoordinatedTask_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CoordinatedTask& a, CoordinatedTask& b) {
    a.Swap(&b);
  }
  inline void Swap(CoordinatedTask* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CoordinatedTask* New() const final {
    return CreateMaybeMessage<CoordinatedTask>(nullptr);
  }

  CoordinatedTask* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CoordinatedTask>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CoordinatedTask& from);
  void MergeFrom(const CoordinatedTask& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CoordinatedTask* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.CoordinatedTask";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto);
    return ::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJobNameFieldNumber = 1,
    kTaskIdFieldNumber = 2,
  };
  // string job_name = 1;
  void clear_job_name();
  const std::string& job_name() const;
  void set_job_name(const std::string& value);
  void set_job_name(std::string&& value);
  void set_job_name(const char* value);
  void set_job_name(const char* value, size_t size);
  std::string* mutable_job_name();
  std::string* release_job_name();
  void set_allocated_job_name(std::string* job_name);

  // int32 task_id = 2;
  void clear_task_id();
  ::PROTOBUF_NAMESPACE_ID::int32 task_id() const;
  void set_task_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:tensorflow.CoordinatedTask)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr job_name_;
  ::PROTOBUF_NAMESPACE_ID::int32 task_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class CoordinationServiceError :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.CoordinationServiceError) */ {
 public:
  CoordinationServiceError();
  virtual ~CoordinationServiceError();

  CoordinationServiceError(const CoordinationServiceError& from);
  CoordinationServiceError(CoordinationServiceError&& from) noexcept
    : CoordinationServiceError() {
    *this = ::std::move(from);
  }

  inline CoordinationServiceError& operator=(const CoordinationServiceError& from) {
    CopyFrom(from);
    return *this;
  }
  inline CoordinationServiceError& operator=(CoordinationServiceError&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CoordinationServiceError& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CoordinationServiceError* internal_default_instance() {
    return reinterpret_cast<const CoordinationServiceError*>(
               &_CoordinationServiceError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CoordinationServiceError& a, CoordinationServiceError& b) {
    a.Swap(&b);
  }
  inline void Swap(CoordinationServiceError* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CoordinationServiceError* New() const final {
    return CreateMaybeMessage<CoordinationServiceError>(nullptr);
  }

  CoordinationServiceError* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CoordinationServiceError>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CoordinationServiceError& from);
  void MergeFrom(const CoordinationServiceError& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CoordinationServiceError* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.CoordinationServiceError";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto);
    return ::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceTaskFieldNumber = 4,
    kIsReportedErrorFieldNumber = 3,
  };
  // .tensorflow.CoordinatedTask source_task = 4;
  bool has_source_task() const;
  void clear_source_task();
  const ::tensorflow::CoordinatedTask& source_task() const;
  ::tensorflow::CoordinatedTask* release_source_task();
  ::tensorflow::CoordinatedTask* mutable_source_task();
  void set_allocated_source_task(::tensorflow::CoordinatedTask* source_task);

  // bool is_reported_error = 3;
  void clear_is_reported_error();
  bool is_reported_error() const;
  void set_is_reported_error(bool value);

  // @@protoc_insertion_point(class_scope:tensorflow.CoordinationServiceError)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::tensorflow::CoordinatedTask* source_task_;
  bool is_reported_error_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class CoordinatedTaskStateInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.CoordinatedTaskStateInfo) */ {
 public:
  CoordinatedTaskStateInfo();
  virtual ~CoordinatedTaskStateInfo();

  CoordinatedTaskStateInfo(const CoordinatedTaskStateInfo& from);
  CoordinatedTaskStateInfo(CoordinatedTaskStateInfo&& from) noexcept
    : CoordinatedTaskStateInfo() {
    *this = ::std::move(from);
  }

  inline CoordinatedTaskStateInfo& operator=(const CoordinatedTaskStateInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CoordinatedTaskStateInfo& operator=(CoordinatedTaskStateInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CoordinatedTaskStateInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CoordinatedTaskStateInfo* internal_default_instance() {
    return reinterpret_cast<const CoordinatedTaskStateInfo*>(
               &_CoordinatedTaskStateInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CoordinatedTaskStateInfo& a, CoordinatedTaskStateInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(CoordinatedTaskStateInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CoordinatedTaskStateInfo* New() const final {
    return CreateMaybeMessage<CoordinatedTaskStateInfo>(nullptr);
  }

  CoordinatedTaskStateInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CoordinatedTaskStateInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CoordinatedTaskStateInfo& from);
  void MergeFrom(const CoordinatedTaskStateInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CoordinatedTaskStateInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.CoordinatedTaskStateInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto);
    return ::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 4,
    kTaskFieldNumber = 1,
    kErrorPayloadFieldNumber = 5,
    kStateFieldNumber = 2,
    kErrorCodeFieldNumber = 3,
  };
  // string error_message = 4;
  void clear_error_message();
  const std::string& error_message() const;
  void set_error_message(const std::string& value);
  void set_error_message(std::string&& value);
  void set_error_message(const char* value);
  void set_error_message(const char* value, size_t size);
  std::string* mutable_error_message();
  std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);

  // .tensorflow.CoordinatedTask task = 1;
  bool has_task() const;
  void clear_task();
  const ::tensorflow::CoordinatedTask& task() const;
  ::tensorflow::CoordinatedTask* release_task();
  ::tensorflow::CoordinatedTask* mutable_task();
  void set_allocated_task(::tensorflow::CoordinatedTask* task);

  // .tensorflow.CoordinationServiceError error_payload = 5;
  bool has_error_payload() const;
  void clear_error_payload();
  const ::tensorflow::CoordinationServiceError& error_payload() const;
  ::tensorflow::CoordinationServiceError* release_error_payload();
  ::tensorflow::CoordinationServiceError* mutable_error_payload();
  void set_allocated_error_payload(::tensorflow::CoordinationServiceError* error_payload);

  // .tensorflow.CoordinatedTaskState state = 2;
  void clear_state();
  ::tensorflow::CoordinatedTaskState state() const;
  void set_state(::tensorflow::CoordinatedTaskState value);

  // int32 error_code = 3;
  void clear_error_code();
  ::PROTOBUF_NAMESPACE_ID::int32 error_code() const;
  void set_error_code(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:tensorflow.CoordinatedTaskStateInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
  ::tensorflow::CoordinatedTask* task_;
  ::tensorflow::CoordinationServiceError* error_payload_;
  int state_;
  ::PROTOBUF_NAMESPACE_ID::int32 error_code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class TfDeviceList :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.TfDeviceList) */ {
 public:
  TfDeviceList();
  virtual ~TfDeviceList();

  TfDeviceList(const TfDeviceList& from);
  TfDeviceList(TfDeviceList&& from) noexcept
    : TfDeviceList() {
    *this = ::std::move(from);
  }

  inline TfDeviceList& operator=(const TfDeviceList& from) {
    CopyFrom(from);
    return *this;
  }
  inline TfDeviceList& operator=(TfDeviceList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TfDeviceList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TfDeviceList* internal_default_instance() {
    return reinterpret_cast<const TfDeviceList*>(
               &_TfDeviceList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TfDeviceList& a, TfDeviceList& b) {
    a.Swap(&b);
  }
  inline void Swap(TfDeviceList* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TfDeviceList* New() const final {
    return CreateMaybeMessage<TfDeviceList>(nullptr);
  }

  TfDeviceList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TfDeviceList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TfDeviceList& from);
  void MergeFrom(const TfDeviceList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TfDeviceList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.TfDeviceList";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto);
    return ::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDevicesFieldNumber = 1,
  };
  // repeated .tensorflow.DeviceAttributes devices = 1;
  int devices_size() const;
  void clear_devices();
  ::tensorflow::DeviceAttributes* mutable_devices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::DeviceAttributes >*
      mutable_devices();
  const ::tensorflow::DeviceAttributes& devices(int index) const;
  ::tensorflow::DeviceAttributes* add_devices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::DeviceAttributes >&
      devices() const;

  // @@protoc_insertion_point(class_scope:tensorflow.TfDeviceList)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::DeviceAttributes > devices_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class XlaDeviceList :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.XlaDeviceList) */ {
 public:
  XlaDeviceList();
  virtual ~XlaDeviceList();

  XlaDeviceList(const XlaDeviceList& from);
  XlaDeviceList(XlaDeviceList&& from) noexcept
    : XlaDeviceList() {
    *this = ::std::move(from);
  }

  inline XlaDeviceList& operator=(const XlaDeviceList& from) {
    CopyFrom(from);
    return *this;
  }
  inline XlaDeviceList& operator=(XlaDeviceList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const XlaDeviceList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const XlaDeviceList* internal_default_instance() {
    return reinterpret_cast<const XlaDeviceList*>(
               &_XlaDeviceList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(XlaDeviceList& a, XlaDeviceList& b) {
    a.Swap(&b);
  }
  inline void Swap(XlaDeviceList* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline XlaDeviceList* New() const final {
    return CreateMaybeMessage<XlaDeviceList>(nullptr);
  }

  XlaDeviceList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<XlaDeviceList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const XlaDeviceList& from);
  void MergeFrom(const XlaDeviceList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(XlaDeviceList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.XlaDeviceList";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto);
    return ::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDevicesFieldNumber = 1,
  };
  // .xla.GlobalTopologyProto devices = 1;
  bool has_devices() const;
  void clear_devices();
  const ::xla::GlobalTopologyProto& devices() const;
  ::xla::GlobalTopologyProto* release_devices();
  ::xla::GlobalTopologyProto* mutable_devices();
  void set_allocated_devices(::xla::GlobalTopologyProto* devices);

  // @@protoc_insertion_point(class_scope:tensorflow.XlaDeviceList)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::xla::GlobalTopologyProto* devices_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class CoordinationServiceDeviceInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.CoordinationServiceDeviceInfo) */ {
 public:
  CoordinationServiceDeviceInfo();
  virtual ~CoordinationServiceDeviceInfo();

  CoordinationServiceDeviceInfo(const CoordinationServiceDeviceInfo& from);
  CoordinationServiceDeviceInfo(CoordinationServiceDeviceInfo&& from) noexcept
    : CoordinationServiceDeviceInfo() {
    *this = ::std::move(from);
  }

  inline CoordinationServiceDeviceInfo& operator=(const CoordinationServiceDeviceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CoordinationServiceDeviceInfo& operator=(CoordinationServiceDeviceInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CoordinationServiceDeviceInfo& default_instance();

  enum TypeCase {
    kTf = 1,
    kXla = 2,
    TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CoordinationServiceDeviceInfo* internal_default_instance() {
    return reinterpret_cast<const CoordinationServiceDeviceInfo*>(
               &_CoordinationServiceDeviceInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CoordinationServiceDeviceInfo& a, CoordinationServiceDeviceInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(CoordinationServiceDeviceInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CoordinationServiceDeviceInfo* New() const final {
    return CreateMaybeMessage<CoordinationServiceDeviceInfo>(nullptr);
  }

  CoordinationServiceDeviceInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CoordinationServiceDeviceInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CoordinationServiceDeviceInfo& from);
  void MergeFrom(const CoordinationServiceDeviceInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CoordinationServiceDeviceInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.CoordinationServiceDeviceInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto);
    return ::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTfFieldNumber = 1,
    kXlaFieldNumber = 2,
  };
  // .tensorflow.TfDeviceList tf = 1;
  bool has_tf() const;
  void clear_tf();
  const ::tensorflow::TfDeviceList& tf() const;
  ::tensorflow::TfDeviceList* release_tf();
  ::tensorflow::TfDeviceList* mutable_tf();
  void set_allocated_tf(::tensorflow::TfDeviceList* tf);

  // .tensorflow.XlaDeviceList xla = 2;
  bool has_xla() const;
  void clear_xla();
  const ::tensorflow::XlaDeviceList& xla() const;
  ::tensorflow::XlaDeviceList* release_xla();
  ::tensorflow::XlaDeviceList* mutable_xla();
  void set_allocated_xla(::tensorflow::XlaDeviceList* xla);

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:tensorflow.CoordinationServiceDeviceInfo)
 private:
  class _Internal;
  void set_has_tf();
  void set_has_xla();

  inline bool has_type() const;
  inline void clear_has_type();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  union TypeUnion {
    TypeUnion() {}
    ::tensorflow::TfDeviceList* tf_;
    ::tensorflow::XlaDeviceList* xla_;
  } type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class RegisterTaskRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.RegisterTaskRequest) */ {
 public:
  RegisterTaskRequest();
  virtual ~RegisterTaskRequest();

  RegisterTaskRequest(const RegisterTaskRequest& from);
  RegisterTaskRequest(RegisterTaskRequest&& from) noexcept
    : RegisterTaskRequest() {
    *this = ::std::move(from);
  }

  inline RegisterTaskRequest& operator=(const RegisterTaskRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterTaskRequest& operator=(RegisterTaskRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RegisterTaskRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegisterTaskRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterTaskRequest*>(
               &_RegisterTaskRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RegisterTaskRequest& a, RegisterTaskRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterTaskRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RegisterTaskRequest* New() const final {
    return CreateMaybeMessage<RegisterTaskRequest>(nullptr);
  }

  RegisterTaskRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegisterTaskRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RegisterTaskRequest& from);
  void MergeFrom(const RegisterTaskRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterTaskRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.RegisterTaskRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto);
    return ::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceTaskFieldNumber = 5,
    kIncarnationFieldNumber = 3,
  };
  // .tensorflow.CoordinatedTask source_task = 5;
  bool has_source_task() const;
  void clear_source_task();
  const ::tensorflow::CoordinatedTask& source_task() const;
  ::tensorflow::CoordinatedTask* release_source_task();
  ::tensorflow::CoordinatedTask* mutable_source_task();
  void set_allocated_source_task(::tensorflow::CoordinatedTask* source_task);

  // fixed64 incarnation = 3;
  void clear_incarnation();
  ::PROTOBUF_NAMESPACE_ID::uint64 incarnation() const;
  void set_incarnation(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:tensorflow.RegisterTaskRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::tensorflow::CoordinatedTask* source_task_;
  ::PROTOBUF_NAMESPACE_ID::uint64 incarnation_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class RegisterTaskResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.RegisterTaskResponse) */ {
 public:
  RegisterTaskResponse();
  virtual ~RegisterTaskResponse();

  RegisterTaskResponse(const RegisterTaskResponse& from);
  RegisterTaskResponse(RegisterTaskResponse&& from) noexcept
    : RegisterTaskResponse() {
    *this = ::std::move(from);
  }

  inline RegisterTaskResponse& operator=(const RegisterTaskResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterTaskResponse& operator=(RegisterTaskResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RegisterTaskResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegisterTaskResponse* internal_default_instance() {
    return reinterpret_cast<const RegisterTaskResponse*>(
               &_RegisterTaskResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RegisterTaskResponse& a, RegisterTaskResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterTaskResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RegisterTaskResponse* New() const final {
    return CreateMaybeMessage<RegisterTaskResponse>(nullptr);
  }

  RegisterTaskResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegisterTaskResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RegisterTaskResponse& from);
  void MergeFrom(const RegisterTaskResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterTaskResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.RegisterTaskResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto);
    return ::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeaderIncarnationFieldNumber = 1,
  };
  // fixed64 leader_incarnation = 1;
  void clear_leader_incarnation();
  ::PROTOBUF_NAMESPACE_ID::uint64 leader_incarnation() const;
  void set_leader_incarnation(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:tensorflow.RegisterTaskResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint64 leader_incarnation_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class HeartbeatRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.HeartbeatRequest) */ {
 public:
  HeartbeatRequest();
  virtual ~HeartbeatRequest();

  HeartbeatRequest(const HeartbeatRequest& from);
  HeartbeatRequest(HeartbeatRequest&& from) noexcept
    : HeartbeatRequest() {
    *this = ::std::move(from);
  }

  inline HeartbeatRequest& operator=(const HeartbeatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeartbeatRequest& operator=(HeartbeatRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HeartbeatRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HeartbeatRequest* internal_default_instance() {
    return reinterpret_cast<const HeartbeatRequest*>(
               &_HeartbeatRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(HeartbeatRequest& a, HeartbeatRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HeartbeatRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HeartbeatRequest* New() const final {
    return CreateMaybeMessage<HeartbeatRequest>(nullptr);
  }

  HeartbeatRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HeartbeatRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HeartbeatRequest& from);
  void MergeFrom(const HeartbeatRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartbeatRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.HeartbeatRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto);
    return ::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceTaskFieldNumber = 4,
    kIncarnationFieldNumber = 3,
  };
  // .tensorflow.CoordinatedTask source_task = 4;
  bool has_source_task() const;
  void clear_source_task();
  const ::tensorflow::CoordinatedTask& source_task() const;
  ::tensorflow::CoordinatedTask* release_source_task();
  ::tensorflow::CoordinatedTask* mutable_source_task();
  void set_allocated_source_task(::tensorflow::CoordinatedTask* source_task);

  // fixed64 incarnation = 3;
  void clear_incarnation();
  ::PROTOBUF_NAMESPACE_ID::uint64 incarnation() const;
  void set_incarnation(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:tensorflow.HeartbeatRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::tensorflow::CoordinatedTask* source_task_;
  ::PROTOBUF_NAMESPACE_ID::uint64 incarnation_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class HeartbeatResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.HeartbeatResponse) */ {
 public:
  HeartbeatResponse();
  virtual ~HeartbeatResponse();

  HeartbeatResponse(const HeartbeatResponse& from);
  HeartbeatResponse(HeartbeatResponse&& from) noexcept
    : HeartbeatResponse() {
    *this = ::std::move(from);
  }

  inline HeartbeatResponse& operator=(const HeartbeatResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeartbeatResponse& operator=(HeartbeatResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HeartbeatResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HeartbeatResponse* internal_default_instance() {
    return reinterpret_cast<const HeartbeatResponse*>(
               &_HeartbeatResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(HeartbeatResponse& a, HeartbeatResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(HeartbeatResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HeartbeatResponse* New() const final {
    return CreateMaybeMessage<HeartbeatResponse>(nullptr);
  }

  HeartbeatResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HeartbeatResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HeartbeatResponse& from);
  void MergeFrom(const HeartbeatResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartbeatResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.HeartbeatResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto);
    return ::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeaderIncarnationFieldNumber = 1,
  };
  // fixed64 leader_incarnation = 1;
  void clear_leader_incarnation();
  ::PROTOBUF_NAMESPACE_ID::uint64 leader_incarnation() const;
  void set_leader_incarnation(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:tensorflow.HeartbeatResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint64 leader_incarnation_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class WaitForAllTasksRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.WaitForAllTasksRequest) */ {
 public:
  WaitForAllTasksRequest();
  virtual ~WaitForAllTasksRequest();

  WaitForAllTasksRequest(const WaitForAllTasksRequest& from);
  WaitForAllTasksRequest(WaitForAllTasksRequest&& from) noexcept
    : WaitForAllTasksRequest() {
    *this = ::std::move(from);
  }

  inline WaitForAllTasksRequest& operator=(const WaitForAllTasksRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WaitForAllTasksRequest& operator=(WaitForAllTasksRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const WaitForAllTasksRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WaitForAllTasksRequest* internal_default_instance() {
    return reinterpret_cast<const WaitForAllTasksRequest*>(
               &_WaitForAllTasksRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(WaitForAllTasksRequest& a, WaitForAllTasksRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(WaitForAllTasksRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WaitForAllTasksRequest* New() const final {
    return CreateMaybeMessage<WaitForAllTasksRequest>(nullptr);
  }

  WaitForAllTasksRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WaitForAllTasksRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const WaitForAllTasksRequest& from);
  void MergeFrom(const WaitForAllTasksRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WaitForAllTasksRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.WaitForAllTasksRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto);
    return ::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocalDeviceInfoFieldNumber = 4,
    kSourceTaskFieldNumber = 5,
  };
  // .tensorflow.CoordinationServiceDeviceInfo local_device_info = 4;
  bool has_local_device_info() const;
  void clear_local_device_info();
  const ::tensorflow::CoordinationServiceDeviceInfo& local_device_info() const;
  ::tensorflow::CoordinationServiceDeviceInfo* release_local_device_info();
  ::tensorflow::CoordinationServiceDeviceInfo* mutable_local_device_info();
  void set_allocated_local_device_info(::tensorflow::CoordinationServiceDeviceInfo* local_device_info);

  // .tensorflow.CoordinatedTask source_task = 5;
  bool has_source_task() const;
  void clear_source_task();
  const ::tensorflow::CoordinatedTask& source_task() const;
  ::tensorflow::CoordinatedTask* release_source_task();
  ::tensorflow::CoordinatedTask* mutable_source_task();
  void set_allocated_source_task(::tensorflow::CoordinatedTask* source_task);

  // @@protoc_insertion_point(class_scope:tensorflow.WaitForAllTasksRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::tensorflow::CoordinationServiceDeviceInfo* local_device_info_;
  ::tensorflow::CoordinatedTask* source_task_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class WaitForAllTasksResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.WaitForAllTasksResponse) */ {
 public:
  WaitForAllTasksResponse();
  virtual ~WaitForAllTasksResponse();

  WaitForAllTasksResponse(const WaitForAllTasksResponse& from);
  WaitForAllTasksResponse(WaitForAllTasksResponse&& from) noexcept
    : WaitForAllTasksResponse() {
    *this = ::std::move(from);
  }

  inline WaitForAllTasksResponse& operator=(const WaitForAllTasksResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline WaitForAllTasksResponse& operator=(WaitForAllTasksResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const WaitForAllTasksResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WaitForAllTasksResponse* internal_default_instance() {
    return reinterpret_cast<const WaitForAllTasksResponse*>(
               &_WaitForAllTasksResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(WaitForAllTasksResponse& a, WaitForAllTasksResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(WaitForAllTasksResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WaitForAllTasksResponse* New() const final {
    return CreateMaybeMessage<WaitForAllTasksResponse>(nullptr);
  }

  WaitForAllTasksResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WaitForAllTasksResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const WaitForAllTasksResponse& from);
  void MergeFrom(const WaitForAllTasksResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WaitForAllTasksResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.WaitForAllTasksResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto);
    return ::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClusterDeviceInfoFieldNumber = 3,
    kLeaderIncarnationFieldNumber = 1,
  };
  // .tensorflow.CoordinationServiceDeviceInfo cluster_device_info = 3;
  bool has_cluster_device_info() const;
  void clear_cluster_device_info();
  const ::tensorflow::CoordinationServiceDeviceInfo& cluster_device_info() const;
  ::tensorflow::CoordinationServiceDeviceInfo* release_cluster_device_info();
  ::tensorflow::CoordinationServiceDeviceInfo* mutable_cluster_device_info();
  void set_allocated_cluster_device_info(::tensorflow::CoordinationServiceDeviceInfo* cluster_device_info);

  // fixed64 leader_incarnation = 1;
  void clear_leader_incarnation();
  ::PROTOBUF_NAMESPACE_ID::uint64 leader_incarnation() const;
  void set_leader_incarnation(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:tensorflow.WaitForAllTasksResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::tensorflow::CoordinationServiceDeviceInfo* cluster_device_info_;
  ::PROTOBUF_NAMESPACE_ID::uint64 leader_incarnation_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ShutdownTaskRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.ShutdownTaskRequest) */ {
 public:
  ShutdownTaskRequest();
  virtual ~ShutdownTaskRequest();

  ShutdownTaskRequest(const ShutdownTaskRequest& from);
  ShutdownTaskRequest(ShutdownTaskRequest&& from) noexcept
    : ShutdownTaskRequest() {
    *this = ::std::move(from);
  }

  inline ShutdownTaskRequest& operator=(const ShutdownTaskRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShutdownTaskRequest& operator=(ShutdownTaskRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ShutdownTaskRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ShutdownTaskRequest* internal_default_instance() {
    return reinterpret_cast<const ShutdownTaskRequest*>(
               &_ShutdownTaskRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ShutdownTaskRequest& a, ShutdownTaskRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ShutdownTaskRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ShutdownTaskRequest* New() const final {
    return CreateMaybeMessage<ShutdownTaskRequest>(nullptr);
  }

  ShutdownTaskRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ShutdownTaskRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ShutdownTaskRequest& from);
  void MergeFrom(const ShutdownTaskRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShutdownTaskRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.ShutdownTaskRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto);
    return ::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceTaskFieldNumber = 1,
  };
  // .tensorflow.CoordinatedTask source_task = 1;
  bool has_source_task() const;
  void clear_source_task();
  const ::tensorflow::CoordinatedTask& source_task() const;
  ::tensorflow::CoordinatedTask* release_source_task();
  ::tensorflow::CoordinatedTask* mutable_source_task();
  void set_allocated_source_task(::tensorflow::CoordinatedTask* source_task);

  // @@protoc_insertion_point(class_scope:tensorflow.ShutdownTaskRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::tensorflow::CoordinatedTask* source_task_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ShutdownTaskResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.ShutdownTaskResponse) */ {
 public:
  ShutdownTaskResponse();
  virtual ~ShutdownTaskResponse();

  ShutdownTaskResponse(const ShutdownTaskResponse& from);
  ShutdownTaskResponse(ShutdownTaskResponse&& from) noexcept
    : ShutdownTaskResponse() {
    *this = ::std::move(from);
  }

  inline ShutdownTaskResponse& operator=(const ShutdownTaskResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShutdownTaskResponse& operator=(ShutdownTaskResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ShutdownTaskResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ShutdownTaskResponse* internal_default_instance() {
    return reinterpret_cast<const ShutdownTaskResponse*>(
               &_ShutdownTaskResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ShutdownTaskResponse& a, ShutdownTaskResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ShutdownTaskResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ShutdownTaskResponse* New() const final {
    return CreateMaybeMessage<ShutdownTaskResponse>(nullptr);
  }

  ShutdownTaskResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ShutdownTaskResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ShutdownTaskResponse& from);
  void MergeFrom(const ShutdownTaskResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShutdownTaskResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.ShutdownTaskResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto);
    return ::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:tensorflow.ShutdownTaskResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ResetTaskRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.ResetTaskRequest) */ {
 public:
  ResetTaskRequest();
  virtual ~ResetTaskRequest();

  ResetTaskRequest(const ResetTaskRequest& from);
  ResetTaskRequest(ResetTaskRequest&& from) noexcept
    : ResetTaskRequest() {
    *this = ::std::move(from);
  }

  inline ResetTaskRequest& operator=(const ResetTaskRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResetTaskRequest& operator=(ResetTaskRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ResetTaskRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResetTaskRequest* internal_default_instance() {
    return reinterpret_cast<const ResetTaskRequest*>(
               &_ResetTaskRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ResetTaskRequest& a, ResetTaskRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ResetTaskRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResetTaskRequest* New() const final {
    return CreateMaybeMessage<ResetTaskRequest>(nullptr);
  }

  ResetTaskRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResetTaskRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ResetTaskRequest& from);
  void MergeFrom(const ResetTaskRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResetTaskRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.ResetTaskRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto);
    return ::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceTaskFieldNumber = 1,
  };
  // .tensorflow.CoordinatedTask source_task = 1;
  bool has_source_task() const;
  void clear_source_task();
  const ::tensorflow::CoordinatedTask& source_task() const;
  ::tensorflow::CoordinatedTask* release_source_task();
  ::tensorflow::CoordinatedTask* mutable_source_task();
  void set_allocated_source_task(::tensorflow::CoordinatedTask* source_task);

  // @@protoc_insertion_point(class_scope:tensorflow.ResetTaskRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::tensorflow::CoordinatedTask* source_task_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ResetTaskResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.ResetTaskResponse) */ {
 public:
  ResetTaskResponse();
  virtual ~ResetTaskResponse();

  ResetTaskResponse(const ResetTaskResponse& from);
  ResetTaskResponse(ResetTaskResponse&& from) noexcept
    : ResetTaskResponse() {
    *this = ::std::move(from);
  }

  inline ResetTaskResponse& operator=(const ResetTaskResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResetTaskResponse& operator=(ResetTaskResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ResetTaskResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResetTaskResponse* internal_default_instance() {
    return reinterpret_cast<const ResetTaskResponse*>(
               &_ResetTaskResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ResetTaskResponse& a, ResetTaskResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ResetTaskResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResetTaskResponse* New() const final {
    return CreateMaybeMessage<ResetTaskResponse>(nullptr);
  }

  ResetTaskResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResetTaskResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ResetTaskResponse& from);
  void MergeFrom(const ResetTaskResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResetTaskResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.ResetTaskResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto);
    return ::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:tensorflow.ResetTaskResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ReportErrorToTaskRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.ReportErrorToTaskRequest) */ {
 public:
  ReportErrorToTaskRequest();
  virtual ~ReportErrorToTaskRequest();

  ReportErrorToTaskRequest(const ReportErrorToTaskRequest& from);
  ReportErrorToTaskRequest(ReportErrorToTaskRequest&& from) noexcept
    : ReportErrorToTaskRequest() {
    *this = ::std::move(from);
  }

  inline ReportErrorToTaskRequest& operator=(const ReportErrorToTaskRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReportErrorToTaskRequest& operator=(ReportErrorToTaskRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ReportErrorToTaskRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReportErrorToTaskRequest* internal_default_instance() {
    return reinterpret_cast<const ReportErrorToTaskRequest*>(
               &_ReportErrorToTaskRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ReportErrorToTaskRequest& a, ReportErrorToTaskRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReportErrorToTaskRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReportErrorToTaskRequest* New() const final {
    return CreateMaybeMessage<ReportErrorToTaskRequest>(nullptr);
  }

  ReportErrorToTaskRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReportErrorToTaskRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReportErrorToTaskRequest& from);
  void MergeFrom(const ReportErrorToTaskRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReportErrorToTaskRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.ReportErrorToTaskRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto);
    return ::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 2,
    kErrorPayloadFieldNumber = 5,
    kErrorCodeFieldNumber = 1,
  };
  // string error_message = 2;
  void clear_error_message();
  const std::string& error_message() const;
  void set_error_message(const std::string& value);
  void set_error_message(std::string&& value);
  void set_error_message(const char* value);
  void set_error_message(const char* value, size_t size);
  std::string* mutable_error_message();
  std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);

  // .tensorflow.CoordinationServiceError error_payload = 5;
  bool has_error_payload() const;
  void clear_error_payload();
  const ::tensorflow::CoordinationServiceError& error_payload() const;
  ::tensorflow::CoordinationServiceError* release_error_payload();
  ::tensorflow::CoordinationServiceError* mutable_error_payload();
  void set_allocated_error_payload(::tensorflow::CoordinationServiceError* error_payload);

  // int32 error_code = 1;
  void clear_error_code();
  ::PROTOBUF_NAMESPACE_ID::int32 error_code() const;
  void set_error_code(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:tensorflow.ReportErrorToTaskRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
  ::tensorflow::CoordinationServiceError* error_payload_;
  ::PROTOBUF_NAMESPACE_ID::int32 error_code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ReportErrorToTaskResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.ReportErrorToTaskResponse) */ {
 public:
  ReportErrorToTaskResponse();
  virtual ~ReportErrorToTaskResponse();

  ReportErrorToTaskResponse(const ReportErrorToTaskResponse& from);
  ReportErrorToTaskResponse(ReportErrorToTaskResponse&& from) noexcept
    : ReportErrorToTaskResponse() {
    *this = ::std::move(from);
  }

  inline ReportErrorToTaskResponse& operator=(const ReportErrorToTaskResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReportErrorToTaskResponse& operator=(ReportErrorToTaskResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ReportErrorToTaskResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReportErrorToTaskResponse* internal_default_instance() {
    return reinterpret_cast<const ReportErrorToTaskResponse*>(
               &_ReportErrorToTaskResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ReportErrorToTaskResponse& a, ReportErrorToTaskResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ReportErrorToTaskResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReportErrorToTaskResponse* New() const final {
    return CreateMaybeMessage<ReportErrorToTaskResponse>(nullptr);
  }

  ReportErrorToTaskResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReportErrorToTaskResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReportErrorToTaskResponse& from);
  void MergeFrom(const ReportErrorToTaskResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReportErrorToTaskResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.ReportErrorToTaskResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto);
    return ::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:tensorflow.ReportErrorToTaskResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ReportErrorToServiceRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.ReportErrorToServiceRequest) */ {
 public:
  ReportErrorToServiceRequest();
  virtual ~ReportErrorToServiceRequest();

  ReportErrorToServiceRequest(const ReportErrorToServiceRequest& from);
  ReportErrorToServiceRequest(ReportErrorToServiceRequest&& from) noexcept
    : ReportErrorToServiceRequest() {
    *this = ::std::move(from);
  }

  inline ReportErrorToServiceRequest& operator=(const ReportErrorToServiceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReportErrorToServiceRequest& operator=(ReportErrorToServiceRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ReportErrorToServiceRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReportErrorToServiceRequest* internal_default_instance() {
    return reinterpret_cast<const ReportErrorToServiceRequest*>(
               &_ReportErrorToServiceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ReportErrorToServiceRequest& a, ReportErrorToServiceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReportErrorToServiceRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReportErrorToServiceRequest* New() const final {
    return CreateMaybeMessage<ReportErrorToServiceRequest>(nullptr);
  }

  ReportErrorToServiceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReportErrorToServiceRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReportErrorToServiceRequest& from);
  void MergeFrom(const ReportErrorToServiceRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReportErrorToServiceRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.ReportErrorToServiceRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto);
    return ::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 2,
    kErrorOriginFieldNumber = 5,
    kErrorCodeFieldNumber = 1,
  };
  // string error_message = 2;
  void clear_error_message();
  const std::string& error_message() const;
  void set_error_message(const std::string& value);
  void set_error_message(std::string&& value);
  void set_error_message(const char* value);
  void set_error_message(const char* value, size_t size);
  std::string* mutable_error_message();
  std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);

  // .tensorflow.CoordinatedTask error_origin = 5;
  bool has_error_origin() const;
  void clear_error_origin();
  const ::tensorflow::CoordinatedTask& error_origin() const;
  ::tensorflow::CoordinatedTask* release_error_origin();
  ::tensorflow::CoordinatedTask* mutable_error_origin();
  void set_allocated_error_origin(::tensorflow::CoordinatedTask* error_origin);

  // int32 error_code = 1;
  void clear_error_code();
  ::PROTOBUF_NAMESPACE_ID::int32 error_code() const;
  void set_error_code(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:tensorflow.ReportErrorToServiceRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
  ::tensorflow::CoordinatedTask* error_origin_;
  ::PROTOBUF_NAMESPACE_ID::int32 error_code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ReportErrorToServiceResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.ReportErrorToServiceResponse) */ {
 public:
  ReportErrorToServiceResponse();
  virtual ~ReportErrorToServiceResponse();

  ReportErrorToServiceResponse(const ReportErrorToServiceResponse& from);
  ReportErrorToServiceResponse(ReportErrorToServiceResponse&& from) noexcept
    : ReportErrorToServiceResponse() {
    *this = ::std::move(from);
  }

  inline ReportErrorToServiceResponse& operator=(const ReportErrorToServiceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReportErrorToServiceResponse& operator=(ReportErrorToServiceResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ReportErrorToServiceResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReportErrorToServiceResponse* internal_default_instance() {
    return reinterpret_cast<const ReportErrorToServiceResponse*>(
               &_ReportErrorToServiceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ReportErrorToServiceResponse& a, ReportErrorToServiceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ReportErrorToServiceResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReportErrorToServiceResponse* New() const final {
    return CreateMaybeMessage<ReportErrorToServiceResponse>(nullptr);
  }

  ReportErrorToServiceResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReportErrorToServiceResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReportErrorToServiceResponse& from);
  void MergeFrom(const ReportErrorToServiceResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReportErrorToServiceResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.ReportErrorToServiceResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto);
    return ::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:tensorflow.ReportErrorToServiceResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class GetTaskStateRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.GetTaskStateRequest) */ {
 public:
  GetTaskStateRequest();
  virtual ~GetTaskStateRequest();

  GetTaskStateRequest(const GetTaskStateRequest& from);
  GetTaskStateRequest(GetTaskStateRequest&& from) noexcept
    : GetTaskStateRequest() {
    *this = ::std::move(from);
  }

  inline GetTaskStateRequest& operator=(const GetTaskStateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTaskStateRequest& operator=(GetTaskStateRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetTaskStateRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetTaskStateRequest* internal_default_instance() {
    return reinterpret_cast<const GetTaskStateRequest*>(
               &_GetTaskStateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(GetTaskStateRequest& a, GetTaskStateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTaskStateRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetTaskStateRequest* New() const final {
    return CreateMaybeMessage<GetTaskStateRequest>(nullptr);
  }

  GetTaskStateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetTaskStateRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetTaskStateRequest& from);
  void MergeFrom(const GetTaskStateRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTaskStateRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.GetTaskStateRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto);
    return ::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceTaskFieldNumber = 1,
  };
  // repeated .tensorflow.CoordinatedTask source_task = 1;
  int source_task_size() const;
  void clear_source_task();
  ::tensorflow::CoordinatedTask* mutable_source_task(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::CoordinatedTask >*
      mutable_source_task();
  const ::tensorflow::CoordinatedTask& source_task(int index) const;
  ::tensorflow::CoordinatedTask* add_source_task();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::CoordinatedTask >&
      source_task() const;

  // @@protoc_insertion_point(class_scope:tensorflow.GetTaskStateRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::CoordinatedTask > source_task_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class GetTaskStateResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.GetTaskStateResponse) */ {
 public:
  GetTaskStateResponse();
  virtual ~GetTaskStateResponse();

  GetTaskStateResponse(const GetTaskStateResponse& from);
  GetTaskStateResponse(GetTaskStateResponse&& from) noexcept
    : GetTaskStateResponse() {
    *this = ::std::move(from);
  }

  inline GetTaskStateResponse& operator=(const GetTaskStateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTaskStateResponse& operator=(GetTaskStateResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetTaskStateResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetTaskStateResponse* internal_default_instance() {
    return reinterpret_cast<const GetTaskStateResponse*>(
               &_GetTaskStateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(GetTaskStateResponse& a, GetTaskStateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTaskStateResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetTaskStateResponse* New() const final {
    return CreateMaybeMessage<GetTaskStateResponse>(nullptr);
  }

  GetTaskStateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetTaskStateResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetTaskStateResponse& from);
  void MergeFrom(const GetTaskStateResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTaskStateResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.GetTaskStateResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto);
    return ::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskStateFieldNumber = 1,
  };
  // repeated .tensorflow.CoordinatedTaskStateInfo task_state = 1;
  int task_state_size() const;
  void clear_task_state();
  ::tensorflow::CoordinatedTaskStateInfo* mutable_task_state(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::CoordinatedTaskStateInfo >*
      mutable_task_state();
  const ::tensorflow::CoordinatedTaskStateInfo& task_state(int index) const;
  ::tensorflow::CoordinatedTaskStateInfo* add_task_state();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::CoordinatedTaskStateInfo >&
      task_state() const;

  // @@protoc_insertion_point(class_scope:tensorflow.GetTaskStateResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::CoordinatedTaskStateInfo > task_state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class KeyValueEntry :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.KeyValueEntry) */ {
 public:
  KeyValueEntry();
  virtual ~KeyValueEntry();

  KeyValueEntry(const KeyValueEntry& from);
  KeyValueEntry(KeyValueEntry&& from) noexcept
    : KeyValueEntry() {
    *this = ::std::move(from);
  }

  inline KeyValueEntry& operator=(const KeyValueEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyValueEntry& operator=(KeyValueEntry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const KeyValueEntry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KeyValueEntry* internal_default_instance() {
    return reinterpret_cast<const KeyValueEntry*>(
               &_KeyValueEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(KeyValueEntry& a, KeyValueEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyValueEntry* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline KeyValueEntry* New() const final {
    return CreateMaybeMessage<KeyValueEntry>(nullptr);
  }

  KeyValueEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<KeyValueEntry>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const KeyValueEntry& from);
  void MergeFrom(const KeyValueEntry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyValueEntry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.KeyValueEntry";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto);
    return ::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string key = 1;
  void clear_key();
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);

  // bytes value = 2;
  void clear_value();
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);

  // @@protoc_insertion_point(class_scope:tensorflow.KeyValueEntry)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class InsertKeyValueRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.InsertKeyValueRequest) */ {
 public:
  InsertKeyValueRequest();
  virtual ~InsertKeyValueRequest();

  InsertKeyValueRequest(const InsertKeyValueRequest& from);
  InsertKeyValueRequest(InsertKeyValueRequest&& from) noexcept
    : InsertKeyValueRequest() {
    *this = ::std::move(from);
  }

  inline InsertKeyValueRequest& operator=(const InsertKeyValueRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertKeyValueRequest& operator=(InsertKeyValueRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InsertKeyValueRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InsertKeyValueRequest* internal_default_instance() {
    return reinterpret_cast<const InsertKeyValueRequest*>(
               &_InsertKeyValueRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(InsertKeyValueRequest& a, InsertKeyValueRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InsertKeyValueRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InsertKeyValueRequest* New() const final {
    return CreateMaybeMessage<InsertKeyValueRequest>(nullptr);
  }

  InsertKeyValueRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InsertKeyValueRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InsertKeyValueRequest& from);
  void MergeFrom(const InsertKeyValueRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertKeyValueRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.InsertKeyValueRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto);
    return ::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKvFieldNumber = 1,
  };
  // .tensorflow.KeyValueEntry kv = 1;
  bool has_kv() const;
  void clear_kv();
  const ::tensorflow::KeyValueEntry& kv() const;
  ::tensorflow::KeyValueEntry* release_kv();
  ::tensorflow::KeyValueEntry* mutable_kv();
  void set_allocated_kv(::tensorflow::KeyValueEntry* kv);

  // @@protoc_insertion_point(class_scope:tensorflow.InsertKeyValueRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::tensorflow::KeyValueEntry* kv_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class InsertKeyValueResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.InsertKeyValueResponse) */ {
 public:
  InsertKeyValueResponse();
  virtual ~InsertKeyValueResponse();

  InsertKeyValueResponse(const InsertKeyValueResponse& from);
  InsertKeyValueResponse(InsertKeyValueResponse&& from) noexcept
    : InsertKeyValueResponse() {
    *this = ::std::move(from);
  }

  inline InsertKeyValueResponse& operator=(const InsertKeyValueResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertKeyValueResponse& operator=(InsertKeyValueResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InsertKeyValueResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InsertKeyValueResponse* internal_default_instance() {
    return reinterpret_cast<const InsertKeyValueResponse*>(
               &_InsertKeyValueResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(InsertKeyValueResponse& a, InsertKeyValueResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(InsertKeyValueResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InsertKeyValueResponse* New() const final {
    return CreateMaybeMessage<InsertKeyValueResponse>(nullptr);
  }

  InsertKeyValueResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InsertKeyValueResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InsertKeyValueResponse& from);
  void MergeFrom(const InsertKeyValueResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertKeyValueResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.InsertKeyValueResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto);
    return ::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:tensorflow.InsertKeyValueResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class GetKeyValueRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.GetKeyValueRequest) */ {
 public:
  GetKeyValueRequest();
  virtual ~GetKeyValueRequest();

  GetKeyValueRequest(const GetKeyValueRequest& from);
  GetKeyValueRequest(GetKeyValueRequest&& from) noexcept
    : GetKeyValueRequest() {
    *this = ::std::move(from);
  }

  inline GetKeyValueRequest& operator=(const GetKeyValueRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetKeyValueRequest& operator=(GetKeyValueRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetKeyValueRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetKeyValueRequest* internal_default_instance() {
    return reinterpret_cast<const GetKeyValueRequest*>(
               &_GetKeyValueRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(GetKeyValueRequest& a, GetKeyValueRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetKeyValueRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetKeyValueRequest* New() const final {
    return CreateMaybeMessage<GetKeyValueRequest>(nullptr);
  }

  GetKeyValueRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetKeyValueRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetKeyValueRequest& from);
  void MergeFrom(const GetKeyValueRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetKeyValueRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.GetKeyValueRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto);
    return ::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
  };
  // string key = 1;
  void clear_key();
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);

  // @@protoc_insertion_point(class_scope:tensorflow.GetKeyValueRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class GetKeyValueResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.GetKeyValueResponse) */ {
 public:
  GetKeyValueResponse();
  virtual ~GetKeyValueResponse();

  GetKeyValueResponse(const GetKeyValueResponse& from);
  GetKeyValueResponse(GetKeyValueResponse&& from) noexcept
    : GetKeyValueResponse() {
    *this = ::std::move(from);
  }

  inline GetKeyValueResponse& operator=(const GetKeyValueResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetKeyValueResponse& operator=(GetKeyValueResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetKeyValueResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetKeyValueResponse* internal_default_instance() {
    return reinterpret_cast<const GetKeyValueResponse*>(
               &_GetKeyValueResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(GetKeyValueResponse& a, GetKeyValueResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetKeyValueResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetKeyValueResponse* New() const final {
    return CreateMaybeMessage<GetKeyValueResponse>(nullptr);
  }

  GetKeyValueResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetKeyValueResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetKeyValueResponse& from);
  void MergeFrom(const GetKeyValueResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetKeyValueResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.GetKeyValueResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto);
    return ::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKvFieldNumber = 1,
  };
  // .tensorflow.KeyValueEntry kv = 1;
  bool has_kv() const;
  void clear_kv();
  const ::tensorflow::KeyValueEntry& kv() const;
  ::tensorflow::KeyValueEntry* release_kv();
  ::tensorflow::KeyValueEntry* mutable_kv();
  void set_allocated_kv(::tensorflow::KeyValueEntry* kv);

  // @@protoc_insertion_point(class_scope:tensorflow.GetKeyValueResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::tensorflow::KeyValueEntry* kv_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class TryGetKeyValueRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.TryGetKeyValueRequest) */ {
 public:
  TryGetKeyValueRequest();
  virtual ~TryGetKeyValueRequest();

  TryGetKeyValueRequest(const TryGetKeyValueRequest& from);
  TryGetKeyValueRequest(TryGetKeyValueRequest&& from) noexcept
    : TryGetKeyValueRequest() {
    *this = ::std::move(from);
  }

  inline TryGetKeyValueRequest& operator=(const TryGetKeyValueRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TryGetKeyValueRequest& operator=(TryGetKeyValueRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TryGetKeyValueRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TryGetKeyValueRequest* internal_default_instance() {
    return reinterpret_cast<const TryGetKeyValueRequest*>(
               &_TryGetKeyValueRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(TryGetKeyValueRequest& a, TryGetKeyValueRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TryGetKeyValueRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TryGetKeyValueRequest* New() const final {
    return CreateMaybeMessage<TryGetKeyValueRequest>(nullptr);
  }

  TryGetKeyValueRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TryGetKeyValueRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TryGetKeyValueRequest& from);
  void MergeFrom(const TryGetKeyValueRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TryGetKeyValueRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.TryGetKeyValueRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto);
    return ::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
  };
  // string key = 1;
  void clear_key();
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);

  // @@protoc_insertion_point(class_scope:tensorflow.TryGetKeyValueRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class TryGetKeyValueResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.TryGetKeyValueResponse) */ {
 public:
  TryGetKeyValueResponse();
  virtual ~TryGetKeyValueResponse();

  TryGetKeyValueResponse(const TryGetKeyValueResponse& from);
  TryGetKeyValueResponse(TryGetKeyValueResponse&& from) noexcept
    : TryGetKeyValueResponse() {
    *this = ::std::move(from);
  }

  inline TryGetKeyValueResponse& operator=(const TryGetKeyValueResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TryGetKeyValueResponse& operator=(TryGetKeyValueResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TryGetKeyValueResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TryGetKeyValueResponse* internal_default_instance() {
    return reinterpret_cast<const TryGetKeyValueResponse*>(
               &_TryGetKeyValueResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(TryGetKeyValueResponse& a, TryGetKeyValueResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TryGetKeyValueResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TryGetKeyValueResponse* New() const final {
    return CreateMaybeMessage<TryGetKeyValueResponse>(nullptr);
  }

  TryGetKeyValueResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TryGetKeyValueResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TryGetKeyValueResponse& from);
  void MergeFrom(const TryGetKeyValueResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TryGetKeyValueResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.TryGetKeyValueResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto);
    return ::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKvFieldNumber = 1,
  };
  // .tensorflow.KeyValueEntry kv = 1;
  bool has_kv() const;
  void clear_kv();
  const ::tensorflow::KeyValueEntry& kv() const;
  ::tensorflow::KeyValueEntry* release_kv();
  ::tensorflow::KeyValueEntry* mutable_kv();
  void set_allocated_kv(::tensorflow::KeyValueEntry* kv);

  // @@protoc_insertion_point(class_scope:tensorflow.TryGetKeyValueResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::tensorflow::KeyValueEntry* kv_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class GetKeyValueDirRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.GetKeyValueDirRequest) */ {
 public:
  GetKeyValueDirRequest();
  virtual ~GetKeyValueDirRequest();

  GetKeyValueDirRequest(const GetKeyValueDirRequest& from);
  GetKeyValueDirRequest(GetKeyValueDirRequest&& from) noexcept
    : GetKeyValueDirRequest() {
    *this = ::std::move(from);
  }

  inline GetKeyValueDirRequest& operator=(const GetKeyValueDirRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetKeyValueDirRequest& operator=(GetKeyValueDirRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetKeyValueDirRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetKeyValueDirRequest* internal_default_instance() {
    return reinterpret_cast<const GetKeyValueDirRequest*>(
               &_GetKeyValueDirRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(GetKeyValueDirRequest& a, GetKeyValueDirRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetKeyValueDirRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetKeyValueDirRequest* New() const final {
    return CreateMaybeMessage<GetKeyValueDirRequest>(nullptr);
  }

  GetKeyValueDirRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetKeyValueDirRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetKeyValueDirRequest& from);
  void MergeFrom(const GetKeyValueDirRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetKeyValueDirRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.GetKeyValueDirRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto);
    return ::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDirectoryKeyFieldNumber = 1,
  };
  // string directory_key = 1;
  void clear_directory_key();
  const std::string& directory_key() const;
  void set_directory_key(const std::string& value);
  void set_directory_key(std::string&& value);
  void set_directory_key(const char* value);
  void set_directory_key(const char* value, size_t size);
  std::string* mutable_directory_key();
  std::string* release_directory_key();
  void set_allocated_directory_key(std::string* directory_key);

  // @@protoc_insertion_point(class_scope:tensorflow.GetKeyValueDirRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr directory_key_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class GetKeyValueDirResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.GetKeyValueDirResponse) */ {
 public:
  GetKeyValueDirResponse();
  virtual ~GetKeyValueDirResponse();

  GetKeyValueDirResponse(const GetKeyValueDirResponse& from);
  GetKeyValueDirResponse(GetKeyValueDirResponse&& from) noexcept
    : GetKeyValueDirResponse() {
    *this = ::std::move(from);
  }

  inline GetKeyValueDirResponse& operator=(const GetKeyValueDirResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetKeyValueDirResponse& operator=(GetKeyValueDirResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetKeyValueDirResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetKeyValueDirResponse* internal_default_instance() {
    return reinterpret_cast<const GetKeyValueDirResponse*>(
               &_GetKeyValueDirResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(GetKeyValueDirResponse& a, GetKeyValueDirResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetKeyValueDirResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetKeyValueDirResponse* New() const final {
    return CreateMaybeMessage<GetKeyValueDirResponse>(nullptr);
  }

  GetKeyValueDirResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetKeyValueDirResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetKeyValueDirResponse& from);
  void MergeFrom(const GetKeyValueDirResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetKeyValueDirResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.GetKeyValueDirResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto);
    return ::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKvFieldNumber = 2,
    kDirectoryKeyFieldNumber = 1,
  };
  // repeated .tensorflow.KeyValueEntry kv = 2;
  int kv_size() const;
  void clear_kv();
  ::tensorflow::KeyValueEntry* mutable_kv(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::KeyValueEntry >*
      mutable_kv();
  const ::tensorflow::KeyValueEntry& kv(int index) const;
  ::tensorflow::KeyValueEntry* add_kv();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::KeyValueEntry >&
      kv() const;

  // string directory_key = 1;
  void clear_directory_key();
  const std::string& directory_key() const;
  void set_directory_key(const std::string& value);
  void set_directory_key(std::string&& value);
  void set_directory_key(const char* value);
  void set_directory_key(const char* value, size_t size);
  std::string* mutable_directory_key();
  std::string* release_directory_key();
  void set_allocated_directory_key(std::string* directory_key);

  // @@protoc_insertion_point(class_scope:tensorflow.GetKeyValueDirResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::KeyValueEntry > kv_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr directory_key_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class DeleteKeyValueRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.DeleteKeyValueRequest) */ {
 public:
  DeleteKeyValueRequest();
  virtual ~DeleteKeyValueRequest();

  DeleteKeyValueRequest(const DeleteKeyValueRequest& from);
  DeleteKeyValueRequest(DeleteKeyValueRequest&& from) noexcept
    : DeleteKeyValueRequest() {
    *this = ::std::move(from);
  }

  inline DeleteKeyValueRequest& operator=(const DeleteKeyValueRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteKeyValueRequest& operator=(DeleteKeyValueRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DeleteKeyValueRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteKeyValueRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteKeyValueRequest*>(
               &_DeleteKeyValueRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(DeleteKeyValueRequest& a, DeleteKeyValueRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteKeyValueRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteKeyValueRequest* New() const final {
    return CreateMaybeMessage<DeleteKeyValueRequest>(nullptr);
  }

  DeleteKeyValueRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteKeyValueRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DeleteKeyValueRequest& from);
  void MergeFrom(const DeleteKeyValueRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteKeyValueRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.DeleteKeyValueRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto);
    return ::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kIsDirectoryFieldNumber = 2,
  };
  // string key = 1;
  void clear_key();
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);

  // bool is_directory = 2;
  void clear_is_directory();
  bool is_directory() const;
  void set_is_directory(bool value);

  // @@protoc_insertion_point(class_scope:tensorflow.DeleteKeyValueRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  bool is_directory_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class DeleteKeyValueResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.DeleteKeyValueResponse) */ {
 public:
  DeleteKeyValueResponse();
  virtual ~DeleteKeyValueResponse();

  DeleteKeyValueResponse(const DeleteKeyValueResponse& from);
  DeleteKeyValueResponse(DeleteKeyValueResponse&& from) noexcept
    : DeleteKeyValueResponse() {
    *this = ::std::move(from);
  }

  inline DeleteKeyValueResponse& operator=(const DeleteKeyValueResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteKeyValueResponse& operator=(DeleteKeyValueResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DeleteKeyValueResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteKeyValueResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteKeyValueResponse*>(
               &_DeleteKeyValueResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(DeleteKeyValueResponse& a, DeleteKeyValueResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteKeyValueResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteKeyValueResponse* New() const final {
    return CreateMaybeMessage<DeleteKeyValueResponse>(nullptr);
  }

  DeleteKeyValueResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteKeyValueResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DeleteKeyValueResponse& from);
  void MergeFrom(const DeleteKeyValueResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteKeyValueResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.DeleteKeyValueResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto);
    return ::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:tensorflow.DeleteKeyValueResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class BarrierRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.BarrierRequest) */ {
 public:
  BarrierRequest();
  virtual ~BarrierRequest();

  BarrierRequest(const BarrierRequest& from);
  BarrierRequest(BarrierRequest&& from) noexcept
    : BarrierRequest() {
    *this = ::std::move(from);
  }

  inline BarrierRequest& operator=(const BarrierRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BarrierRequest& operator=(BarrierRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BarrierRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BarrierRequest* internal_default_instance() {
    return reinterpret_cast<const BarrierRequest*>(
               &_BarrierRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(BarrierRequest& a, BarrierRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BarrierRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BarrierRequest* New() const final {
    return CreateMaybeMessage<BarrierRequest>(nullptr);
  }

  BarrierRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BarrierRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BarrierRequest& from);
  void MergeFrom(const BarrierRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BarrierRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.BarrierRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto);
    return ::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTasksFieldNumber = 3,
    kBarrierIdFieldNumber = 1,
    kSourceTaskFieldNumber = 4,
    kBarrierTimeoutInMsFieldNumber = 2,
  };
  // repeated .tensorflow.CoordinatedTask tasks = 3;
  int tasks_size() const;
  void clear_tasks();
  ::tensorflow::CoordinatedTask* mutable_tasks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::CoordinatedTask >*
      mutable_tasks();
  const ::tensorflow::CoordinatedTask& tasks(int index) const;
  ::tensorflow::CoordinatedTask* add_tasks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::CoordinatedTask >&
      tasks() const;

  // string barrier_id = 1;
  void clear_barrier_id();
  const std::string& barrier_id() const;
  void set_barrier_id(const std::string& value);
  void set_barrier_id(std::string&& value);
  void set_barrier_id(const char* value);
  void set_barrier_id(const char* value, size_t size);
  std::string* mutable_barrier_id();
  std::string* release_barrier_id();
  void set_allocated_barrier_id(std::string* barrier_id);

  // .tensorflow.CoordinatedTask source_task = 4;
  bool has_source_task() const;
  void clear_source_task();
  const ::tensorflow::CoordinatedTask& source_task() const;
  ::tensorflow::CoordinatedTask* release_source_task();
  ::tensorflow::CoordinatedTask* mutable_source_task();
  void set_allocated_source_task(::tensorflow::CoordinatedTask* source_task);

  // int64 barrier_timeout_in_ms = 2;
  void clear_barrier_timeout_in_ms();
  ::PROTOBUF_NAMESPACE_ID::int64 barrier_timeout_in_ms() const;
  void set_barrier_timeout_in_ms(::PROTOBUF_NAMESPACE_ID::int64 value);

  // @@protoc_insertion_point(class_scope:tensorflow.BarrierRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::CoordinatedTask > tasks_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr barrier_id_;
  ::tensorflow::CoordinatedTask* source_task_;
  ::PROTOBUF_NAMESPACE_ID::int64 barrier_timeout_in_ms_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class BarrierResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.BarrierResponse) */ {
 public:
  BarrierResponse();
  virtual ~BarrierResponse();

  BarrierResponse(const BarrierResponse& from);
  BarrierResponse(BarrierResponse&& from) noexcept
    : BarrierResponse() {
    *this = ::std::move(from);
  }

  inline BarrierResponse& operator=(const BarrierResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BarrierResponse& operator=(BarrierResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BarrierResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BarrierResponse* internal_default_instance() {
    return reinterpret_cast<const BarrierResponse*>(
               &_BarrierResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(BarrierResponse& a, BarrierResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BarrierResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BarrierResponse* New() const final {
    return CreateMaybeMessage<BarrierResponse>(nullptr);
  }

  BarrierResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BarrierResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BarrierResponse& from);
  void MergeFrom(const BarrierResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BarrierResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.BarrierResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto);
    return ::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:tensorflow.BarrierResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class CancelBarrierRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.CancelBarrierRequest) */ {
 public:
  CancelBarrierRequest();
  virtual ~CancelBarrierRequest();

  CancelBarrierRequest(const CancelBarrierRequest& from);
  CancelBarrierRequest(CancelBarrierRequest&& from) noexcept
    : CancelBarrierRequest() {
    *this = ::std::move(from);
  }

  inline CancelBarrierRequest& operator=(const CancelBarrierRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelBarrierRequest& operator=(CancelBarrierRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CancelBarrierRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CancelBarrierRequest* internal_default_instance() {
    return reinterpret_cast<const CancelBarrierRequest*>(
               &_CancelBarrierRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(CancelBarrierRequest& a, CancelBarrierRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CancelBarrierRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CancelBarrierRequest* New() const final {
    return CreateMaybeMessage<CancelBarrierRequest>(nullptr);
  }

  CancelBarrierRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CancelBarrierRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CancelBarrierRequest& from);
  void MergeFrom(const CancelBarrierRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CancelBarrierRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.CancelBarrierRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto);
    return ::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBarrierIdFieldNumber = 1,
    kSourceTaskFieldNumber = 2,
  };
  // string barrier_id = 1;
  void clear_barrier_id();
  const std::string& barrier_id() const;
  void set_barrier_id(const std::string& value);
  void set_barrier_id(std::string&& value);
  void set_barrier_id(const char* value);
  void set_barrier_id(const char* value, size_t size);
  std::string* mutable_barrier_id();
  std::string* release_barrier_id();
  void set_allocated_barrier_id(std::string* barrier_id);

  // .tensorflow.CoordinatedTask source_task = 2;
  bool has_source_task() const;
  void clear_source_task();
  const ::tensorflow::CoordinatedTask& source_task() const;
  ::tensorflow::CoordinatedTask* release_source_task();
  ::tensorflow::CoordinatedTask* mutable_source_task();
  void set_allocated_source_task(::tensorflow::CoordinatedTask* source_task);

  // @@protoc_insertion_point(class_scope:tensorflow.CancelBarrierRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr barrier_id_;
  ::tensorflow::CoordinatedTask* source_task_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// -------------------------------------------------------------------

class CancelBarrierResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.CancelBarrierResponse) */ {
 public:
  CancelBarrierResponse();
  virtual ~CancelBarrierResponse();

  CancelBarrierResponse(const CancelBarrierResponse& from);
  CancelBarrierResponse(CancelBarrierResponse&& from) noexcept
    : CancelBarrierResponse() {
    *this = ::std::move(from);
  }

  inline CancelBarrierResponse& operator=(const CancelBarrierResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelBarrierResponse& operator=(CancelBarrierResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CancelBarrierResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CancelBarrierResponse* internal_default_instance() {
    return reinterpret_cast<const CancelBarrierResponse*>(
               &_CancelBarrierResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(CancelBarrierResponse& a, CancelBarrierResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CancelBarrierResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CancelBarrierResponse* New() const final {
    return CreateMaybeMessage<CancelBarrierResponse>(nullptr);
  }

  CancelBarrierResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CancelBarrierResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CancelBarrierResponse& from);
  void MergeFrom(const CancelBarrierResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CancelBarrierResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.CancelBarrierResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto);
    return ::descriptor_table_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:tensorflow.CancelBarrierResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CoordinatedTask

// string job_name = 1;
inline void CoordinatedTask::clear_job_name() {
  job_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CoordinatedTask::job_name() const {
  // @@protoc_insertion_point(field_get:tensorflow.CoordinatedTask.job_name)
  return job_name_.GetNoArena();
}
inline void CoordinatedTask::set_job_name(const std::string& value) {
  
  job_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.CoordinatedTask.job_name)
}
inline void CoordinatedTask::set_job_name(std::string&& value) {
  
  job_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.CoordinatedTask.job_name)
}
inline void CoordinatedTask::set_job_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  job_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.CoordinatedTask.job_name)
}
inline void CoordinatedTask::set_job_name(const char* value, size_t size) {
  
  job_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.CoordinatedTask.job_name)
}
inline std::string* CoordinatedTask::mutable_job_name() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.CoordinatedTask.job_name)
  return job_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CoordinatedTask::release_job_name() {
  // @@protoc_insertion_point(field_release:tensorflow.CoordinatedTask.job_name)
  
  return job_name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CoordinatedTask::set_allocated_job_name(std::string* job_name) {
  if (job_name != nullptr) {
    
  } else {
    
  }
  job_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), job_name);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.CoordinatedTask.job_name)
}

// int32 task_id = 2;
inline void CoordinatedTask::clear_task_id() {
  task_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CoordinatedTask::task_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.CoordinatedTask.task_id)
  return task_id_;
}
inline void CoordinatedTask::set_task_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  task_id_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.CoordinatedTask.task_id)
}

// -------------------------------------------------------------------

// CoordinationServiceError

// bool is_reported_error = 3;
inline void CoordinationServiceError::clear_is_reported_error() {
  is_reported_error_ = false;
}
inline bool CoordinationServiceError::is_reported_error() const {
  // @@protoc_insertion_point(field_get:tensorflow.CoordinationServiceError.is_reported_error)
  return is_reported_error_;
}
inline void CoordinationServiceError::set_is_reported_error(bool value) {
  
  is_reported_error_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.CoordinationServiceError.is_reported_error)
}

// .tensorflow.CoordinatedTask source_task = 4;
inline bool CoordinationServiceError::has_source_task() const {
  return this != internal_default_instance() && source_task_ != nullptr;
}
inline void CoordinationServiceError::clear_source_task() {
  if (GetArenaNoVirtual() == nullptr && source_task_ != nullptr) {
    delete source_task_;
  }
  source_task_ = nullptr;
}
inline const ::tensorflow::CoordinatedTask& CoordinationServiceError::source_task() const {
  const ::tensorflow::CoordinatedTask* p = source_task_;
  // @@protoc_insertion_point(field_get:tensorflow.CoordinationServiceError.source_task)
  return p != nullptr ? *p : *reinterpret_cast<const ::tensorflow::CoordinatedTask*>(
      &::tensorflow::_CoordinatedTask_default_instance_);
}
inline ::tensorflow::CoordinatedTask* CoordinationServiceError::release_source_task() {
  // @@protoc_insertion_point(field_release:tensorflow.CoordinationServiceError.source_task)
  
  ::tensorflow::CoordinatedTask* temp = source_task_;
  source_task_ = nullptr;
  return temp;
}
inline ::tensorflow::CoordinatedTask* CoordinationServiceError::mutable_source_task() {
  
  if (source_task_ == nullptr) {
    auto* p = CreateMaybeMessage<::tensorflow::CoordinatedTask>(GetArenaNoVirtual());
    source_task_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.CoordinationServiceError.source_task)
  return source_task_;
}
inline void CoordinationServiceError::set_allocated_source_task(::tensorflow::CoordinatedTask* source_task) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete source_task_;
  }
  if (source_task) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      source_task = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_task, submessage_arena);
    }
    
  } else {
    
  }
  source_task_ = source_task;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.CoordinationServiceError.source_task)
}

// -------------------------------------------------------------------

// CoordinatedTaskStateInfo

// .tensorflow.CoordinatedTask task = 1;
inline bool CoordinatedTaskStateInfo::has_task() const {
  return this != internal_default_instance() && task_ != nullptr;
}
inline void CoordinatedTaskStateInfo::clear_task() {
  if (GetArenaNoVirtual() == nullptr && task_ != nullptr) {
    delete task_;
  }
  task_ = nullptr;
}
inline const ::tensorflow::CoordinatedTask& CoordinatedTaskStateInfo::task() const {
  const ::tensorflow::CoordinatedTask* p = task_;
  // @@protoc_insertion_point(field_get:tensorflow.CoordinatedTaskStateInfo.task)
  return p != nullptr ? *p : *reinterpret_cast<const ::tensorflow::CoordinatedTask*>(
      &::tensorflow::_CoordinatedTask_default_instance_);
}
inline ::tensorflow::CoordinatedTask* CoordinatedTaskStateInfo::release_task() {
  // @@protoc_insertion_point(field_release:tensorflow.CoordinatedTaskStateInfo.task)
  
  ::tensorflow::CoordinatedTask* temp = task_;
  task_ = nullptr;
  return temp;
}
inline ::tensorflow::CoordinatedTask* CoordinatedTaskStateInfo::mutable_task() {
  
  if (task_ == nullptr) {
    auto* p = CreateMaybeMessage<::tensorflow::CoordinatedTask>(GetArenaNoVirtual());
    task_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.CoordinatedTaskStateInfo.task)
  return task_;
}
inline void CoordinatedTaskStateInfo::set_allocated_task(::tensorflow::CoordinatedTask* task) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete task_;
  }
  if (task) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      task = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, task, submessage_arena);
    }
    
  } else {
    
  }
  task_ = task;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.CoordinatedTaskStateInfo.task)
}

// .tensorflow.CoordinatedTaskState state = 2;
inline void CoordinatedTaskStateInfo::clear_state() {
  state_ = 0;
}
inline ::tensorflow::CoordinatedTaskState CoordinatedTaskStateInfo::state() const {
  // @@protoc_insertion_point(field_get:tensorflow.CoordinatedTaskStateInfo.state)
  return static_cast< ::tensorflow::CoordinatedTaskState >(state_);
}
inline void CoordinatedTaskStateInfo::set_state(::tensorflow::CoordinatedTaskState value) {
  
  state_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.CoordinatedTaskStateInfo.state)
}

// int32 error_code = 3;
inline void CoordinatedTaskStateInfo::clear_error_code() {
  error_code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CoordinatedTaskStateInfo::error_code() const {
  // @@protoc_insertion_point(field_get:tensorflow.CoordinatedTaskStateInfo.error_code)
  return error_code_;
}
inline void CoordinatedTaskStateInfo::set_error_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  error_code_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.CoordinatedTaskStateInfo.error_code)
}

// string error_message = 4;
inline void CoordinatedTaskStateInfo::clear_error_message() {
  error_message_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CoordinatedTaskStateInfo::error_message() const {
  // @@protoc_insertion_point(field_get:tensorflow.CoordinatedTaskStateInfo.error_message)
  return error_message_.GetNoArena();
}
inline void CoordinatedTaskStateInfo::set_error_message(const std::string& value) {
  
  error_message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.CoordinatedTaskStateInfo.error_message)
}
inline void CoordinatedTaskStateInfo::set_error_message(std::string&& value) {
  
  error_message_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.CoordinatedTaskStateInfo.error_message)
}
inline void CoordinatedTaskStateInfo::set_error_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  error_message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.CoordinatedTaskStateInfo.error_message)
}
inline void CoordinatedTaskStateInfo::set_error_message(const char* value, size_t size) {
  
  error_message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.CoordinatedTaskStateInfo.error_message)
}
inline std::string* CoordinatedTaskStateInfo::mutable_error_message() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.CoordinatedTaskStateInfo.error_message)
  return error_message_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CoordinatedTaskStateInfo::release_error_message() {
  // @@protoc_insertion_point(field_release:tensorflow.CoordinatedTaskStateInfo.error_message)
  
  return error_message_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CoordinatedTaskStateInfo::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  error_message_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_message);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.CoordinatedTaskStateInfo.error_message)
}

// .tensorflow.CoordinationServiceError error_payload = 5;
inline bool CoordinatedTaskStateInfo::has_error_payload() const {
  return this != internal_default_instance() && error_payload_ != nullptr;
}
inline void CoordinatedTaskStateInfo::clear_error_payload() {
  if (GetArenaNoVirtual() == nullptr && error_payload_ != nullptr) {
    delete error_payload_;
  }
  error_payload_ = nullptr;
}
inline const ::tensorflow::CoordinationServiceError& CoordinatedTaskStateInfo::error_payload() const {
  const ::tensorflow::CoordinationServiceError* p = error_payload_;
  // @@protoc_insertion_point(field_get:tensorflow.CoordinatedTaskStateInfo.error_payload)
  return p != nullptr ? *p : *reinterpret_cast<const ::tensorflow::CoordinationServiceError*>(
      &::tensorflow::_CoordinationServiceError_default_instance_);
}
inline ::tensorflow::CoordinationServiceError* CoordinatedTaskStateInfo::release_error_payload() {
  // @@protoc_insertion_point(field_release:tensorflow.CoordinatedTaskStateInfo.error_payload)
  
  ::tensorflow::CoordinationServiceError* temp = error_payload_;
  error_payload_ = nullptr;
  return temp;
}
inline ::tensorflow::CoordinationServiceError* CoordinatedTaskStateInfo::mutable_error_payload() {
  
  if (error_payload_ == nullptr) {
    auto* p = CreateMaybeMessage<::tensorflow::CoordinationServiceError>(GetArenaNoVirtual());
    error_payload_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.CoordinatedTaskStateInfo.error_payload)
  return error_payload_;
}
inline void CoordinatedTaskStateInfo::set_allocated_error_payload(::tensorflow::CoordinationServiceError* error_payload) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete error_payload_;
  }
  if (error_payload) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      error_payload = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error_payload, submessage_arena);
    }
    
  } else {
    
  }
  error_payload_ = error_payload;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.CoordinatedTaskStateInfo.error_payload)
}

// -------------------------------------------------------------------

// TfDeviceList

// repeated .tensorflow.DeviceAttributes devices = 1;
inline int TfDeviceList::devices_size() const {
  return devices_.size();
}
inline ::tensorflow::DeviceAttributes* TfDeviceList::mutable_devices(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.TfDeviceList.devices)
  return devices_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::DeviceAttributes >*
TfDeviceList::mutable_devices() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.TfDeviceList.devices)
  return &devices_;
}
inline const ::tensorflow::DeviceAttributes& TfDeviceList::devices(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.TfDeviceList.devices)
  return devices_.Get(index);
}
inline ::tensorflow::DeviceAttributes* TfDeviceList::add_devices() {
  // @@protoc_insertion_point(field_add:tensorflow.TfDeviceList.devices)
  return devices_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::DeviceAttributes >&
TfDeviceList::devices() const {
  // @@protoc_insertion_point(field_list:tensorflow.TfDeviceList.devices)
  return devices_;
}

// -------------------------------------------------------------------

// XlaDeviceList

// .xla.GlobalTopologyProto devices = 1;
inline bool XlaDeviceList::has_devices() const {
  return this != internal_default_instance() && devices_ != nullptr;
}
inline const ::xla::GlobalTopologyProto& XlaDeviceList::devices() const {
  const ::xla::GlobalTopologyProto* p = devices_;
  // @@protoc_insertion_point(field_get:tensorflow.XlaDeviceList.devices)
  return p != nullptr ? *p : *reinterpret_cast<const ::xla::GlobalTopologyProto*>(
      &::xla::_GlobalTopologyProto_default_instance_);
}
inline ::xla::GlobalTopologyProto* XlaDeviceList::release_devices() {
  // @@protoc_insertion_point(field_release:tensorflow.XlaDeviceList.devices)
  
  ::xla::GlobalTopologyProto* temp = devices_;
  devices_ = nullptr;
  return temp;
}
inline ::xla::GlobalTopologyProto* XlaDeviceList::mutable_devices() {
  
  if (devices_ == nullptr) {
    auto* p = CreateMaybeMessage<::xla::GlobalTopologyProto>(GetArenaNoVirtual());
    devices_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.XlaDeviceList.devices)
  return devices_;
}
inline void XlaDeviceList::set_allocated_devices(::xla::GlobalTopologyProto* devices) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(devices_);
  }
  if (devices) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      devices = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, devices, submessage_arena);
    }
    
  } else {
    
  }
  devices_ = devices;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.XlaDeviceList.devices)
}

// -------------------------------------------------------------------

// CoordinationServiceDeviceInfo

// .tensorflow.TfDeviceList tf = 1;
inline bool CoordinationServiceDeviceInfo::has_tf() const {
  return type_case() == kTf;
}
inline void CoordinationServiceDeviceInfo::set_has_tf() {
  _oneof_case_[0] = kTf;
}
inline void CoordinationServiceDeviceInfo::clear_tf() {
  if (has_tf()) {
    delete type_.tf_;
    clear_has_type();
  }
}
inline ::tensorflow::TfDeviceList* CoordinationServiceDeviceInfo::release_tf() {
  // @@protoc_insertion_point(field_release:tensorflow.CoordinationServiceDeviceInfo.tf)
  if (has_tf()) {
    clear_has_type();
      ::tensorflow::TfDeviceList* temp = type_.tf_;
    type_.tf_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::TfDeviceList& CoordinationServiceDeviceInfo::tf() const {
  // @@protoc_insertion_point(field_get:tensorflow.CoordinationServiceDeviceInfo.tf)
  return has_tf()
      ? *type_.tf_
      : *reinterpret_cast< ::tensorflow::TfDeviceList*>(&::tensorflow::_TfDeviceList_default_instance_);
}
inline ::tensorflow::TfDeviceList* CoordinationServiceDeviceInfo::mutable_tf() {
  if (!has_tf()) {
    clear_type();
    set_has_tf();
    type_.tf_ = CreateMaybeMessage< ::tensorflow::TfDeviceList >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.CoordinationServiceDeviceInfo.tf)
  return type_.tf_;
}

// .tensorflow.XlaDeviceList xla = 2;
inline bool CoordinationServiceDeviceInfo::has_xla() const {
  return type_case() == kXla;
}
inline void CoordinationServiceDeviceInfo::set_has_xla() {
  _oneof_case_[0] = kXla;
}
inline void CoordinationServiceDeviceInfo::clear_xla() {
  if (has_xla()) {
    delete type_.xla_;
    clear_has_type();
  }
}
inline ::tensorflow::XlaDeviceList* CoordinationServiceDeviceInfo::release_xla() {
  // @@protoc_insertion_point(field_release:tensorflow.CoordinationServiceDeviceInfo.xla)
  if (has_xla()) {
    clear_has_type();
      ::tensorflow::XlaDeviceList* temp = type_.xla_;
    type_.xla_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::XlaDeviceList& CoordinationServiceDeviceInfo::xla() const {
  // @@protoc_insertion_point(field_get:tensorflow.CoordinationServiceDeviceInfo.xla)
  return has_xla()
      ? *type_.xla_
      : *reinterpret_cast< ::tensorflow::XlaDeviceList*>(&::tensorflow::_XlaDeviceList_default_instance_);
}
inline ::tensorflow::XlaDeviceList* CoordinationServiceDeviceInfo::mutable_xla() {
  if (!has_xla()) {
    clear_type();
    set_has_xla();
    type_.xla_ = CreateMaybeMessage< ::tensorflow::XlaDeviceList >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.CoordinationServiceDeviceInfo.xla)
  return type_.xla_;
}

inline bool CoordinationServiceDeviceInfo::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void CoordinationServiceDeviceInfo::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline CoordinationServiceDeviceInfo::TypeCase CoordinationServiceDeviceInfo::type_case() const {
  return CoordinationServiceDeviceInfo::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RegisterTaskRequest

// fixed64 incarnation = 3;
inline void RegisterTaskRequest::clear_incarnation() {
  incarnation_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RegisterTaskRequest::incarnation() const {
  // @@protoc_insertion_point(field_get:tensorflow.RegisterTaskRequest.incarnation)
  return incarnation_;
}
inline void RegisterTaskRequest::set_incarnation(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  incarnation_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.RegisterTaskRequest.incarnation)
}

// .tensorflow.CoordinatedTask source_task = 5;
inline bool RegisterTaskRequest::has_source_task() const {
  return this != internal_default_instance() && source_task_ != nullptr;
}
inline void RegisterTaskRequest::clear_source_task() {
  if (GetArenaNoVirtual() == nullptr && source_task_ != nullptr) {
    delete source_task_;
  }
  source_task_ = nullptr;
}
inline const ::tensorflow::CoordinatedTask& RegisterTaskRequest::source_task() const {
  const ::tensorflow::CoordinatedTask* p = source_task_;
  // @@protoc_insertion_point(field_get:tensorflow.RegisterTaskRequest.source_task)
  return p != nullptr ? *p : *reinterpret_cast<const ::tensorflow::CoordinatedTask*>(
      &::tensorflow::_CoordinatedTask_default_instance_);
}
inline ::tensorflow::CoordinatedTask* RegisterTaskRequest::release_source_task() {
  // @@protoc_insertion_point(field_release:tensorflow.RegisterTaskRequest.source_task)
  
  ::tensorflow::CoordinatedTask* temp = source_task_;
  source_task_ = nullptr;
  return temp;
}
inline ::tensorflow::CoordinatedTask* RegisterTaskRequest::mutable_source_task() {
  
  if (source_task_ == nullptr) {
    auto* p = CreateMaybeMessage<::tensorflow::CoordinatedTask>(GetArenaNoVirtual());
    source_task_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.RegisterTaskRequest.source_task)
  return source_task_;
}
inline void RegisterTaskRequest::set_allocated_source_task(::tensorflow::CoordinatedTask* source_task) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete source_task_;
  }
  if (source_task) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      source_task = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_task, submessage_arena);
    }
    
  } else {
    
  }
  source_task_ = source_task;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.RegisterTaskRequest.source_task)
}

// -------------------------------------------------------------------

// RegisterTaskResponse

// fixed64 leader_incarnation = 1;
inline void RegisterTaskResponse::clear_leader_incarnation() {
  leader_incarnation_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RegisterTaskResponse::leader_incarnation() const {
  // @@protoc_insertion_point(field_get:tensorflow.RegisterTaskResponse.leader_incarnation)
  return leader_incarnation_;
}
inline void RegisterTaskResponse::set_leader_incarnation(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  leader_incarnation_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.RegisterTaskResponse.leader_incarnation)
}

// -------------------------------------------------------------------

// HeartbeatRequest

// fixed64 incarnation = 3;
inline void HeartbeatRequest::clear_incarnation() {
  incarnation_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 HeartbeatRequest::incarnation() const {
  // @@protoc_insertion_point(field_get:tensorflow.HeartbeatRequest.incarnation)
  return incarnation_;
}
inline void HeartbeatRequest::set_incarnation(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  incarnation_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.HeartbeatRequest.incarnation)
}

// .tensorflow.CoordinatedTask source_task = 4;
inline bool HeartbeatRequest::has_source_task() const {
  return this != internal_default_instance() && source_task_ != nullptr;
}
inline void HeartbeatRequest::clear_source_task() {
  if (GetArenaNoVirtual() == nullptr && source_task_ != nullptr) {
    delete source_task_;
  }
  source_task_ = nullptr;
}
inline const ::tensorflow::CoordinatedTask& HeartbeatRequest::source_task() const {
  const ::tensorflow::CoordinatedTask* p = source_task_;
  // @@protoc_insertion_point(field_get:tensorflow.HeartbeatRequest.source_task)
  return p != nullptr ? *p : *reinterpret_cast<const ::tensorflow::CoordinatedTask*>(
      &::tensorflow::_CoordinatedTask_default_instance_);
}
inline ::tensorflow::CoordinatedTask* HeartbeatRequest::release_source_task() {
  // @@protoc_insertion_point(field_release:tensorflow.HeartbeatRequest.source_task)
  
  ::tensorflow::CoordinatedTask* temp = source_task_;
  source_task_ = nullptr;
  return temp;
}
inline ::tensorflow::CoordinatedTask* HeartbeatRequest::mutable_source_task() {
  
  if (source_task_ == nullptr) {
    auto* p = CreateMaybeMessage<::tensorflow::CoordinatedTask>(GetArenaNoVirtual());
    source_task_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.HeartbeatRequest.source_task)
  return source_task_;
}
inline void HeartbeatRequest::set_allocated_source_task(::tensorflow::CoordinatedTask* source_task) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete source_task_;
  }
  if (source_task) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      source_task = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_task, submessage_arena);
    }
    
  } else {
    
  }
  source_task_ = source_task;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.HeartbeatRequest.source_task)
}

// -------------------------------------------------------------------

// HeartbeatResponse

// fixed64 leader_incarnation = 1;
inline void HeartbeatResponse::clear_leader_incarnation() {
  leader_incarnation_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 HeartbeatResponse::leader_incarnation() const {
  // @@protoc_insertion_point(field_get:tensorflow.HeartbeatResponse.leader_incarnation)
  return leader_incarnation_;
}
inline void HeartbeatResponse::set_leader_incarnation(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  leader_incarnation_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.HeartbeatResponse.leader_incarnation)
}

// -------------------------------------------------------------------

// WaitForAllTasksRequest

// .tensorflow.CoordinationServiceDeviceInfo local_device_info = 4;
inline bool WaitForAllTasksRequest::has_local_device_info() const {
  return this != internal_default_instance() && local_device_info_ != nullptr;
}
inline void WaitForAllTasksRequest::clear_local_device_info() {
  if (GetArenaNoVirtual() == nullptr && local_device_info_ != nullptr) {
    delete local_device_info_;
  }
  local_device_info_ = nullptr;
}
inline const ::tensorflow::CoordinationServiceDeviceInfo& WaitForAllTasksRequest::local_device_info() const {
  const ::tensorflow::CoordinationServiceDeviceInfo* p = local_device_info_;
  // @@protoc_insertion_point(field_get:tensorflow.WaitForAllTasksRequest.local_device_info)
  return p != nullptr ? *p : *reinterpret_cast<const ::tensorflow::CoordinationServiceDeviceInfo*>(
      &::tensorflow::_CoordinationServiceDeviceInfo_default_instance_);
}
inline ::tensorflow::CoordinationServiceDeviceInfo* WaitForAllTasksRequest::release_local_device_info() {
  // @@protoc_insertion_point(field_release:tensorflow.WaitForAllTasksRequest.local_device_info)
  
  ::tensorflow::CoordinationServiceDeviceInfo* temp = local_device_info_;
  local_device_info_ = nullptr;
  return temp;
}
inline ::tensorflow::CoordinationServiceDeviceInfo* WaitForAllTasksRequest::mutable_local_device_info() {
  
  if (local_device_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::tensorflow::CoordinationServiceDeviceInfo>(GetArenaNoVirtual());
    local_device_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.WaitForAllTasksRequest.local_device_info)
  return local_device_info_;
}
inline void WaitForAllTasksRequest::set_allocated_local_device_info(::tensorflow::CoordinationServiceDeviceInfo* local_device_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete local_device_info_;
  }
  if (local_device_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      local_device_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, local_device_info, submessage_arena);
    }
    
  } else {
    
  }
  local_device_info_ = local_device_info;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.WaitForAllTasksRequest.local_device_info)
}

// .tensorflow.CoordinatedTask source_task = 5;
inline bool WaitForAllTasksRequest::has_source_task() const {
  return this != internal_default_instance() && source_task_ != nullptr;
}
inline void WaitForAllTasksRequest::clear_source_task() {
  if (GetArenaNoVirtual() == nullptr && source_task_ != nullptr) {
    delete source_task_;
  }
  source_task_ = nullptr;
}
inline const ::tensorflow::CoordinatedTask& WaitForAllTasksRequest::source_task() const {
  const ::tensorflow::CoordinatedTask* p = source_task_;
  // @@protoc_insertion_point(field_get:tensorflow.WaitForAllTasksRequest.source_task)
  return p != nullptr ? *p : *reinterpret_cast<const ::tensorflow::CoordinatedTask*>(
      &::tensorflow::_CoordinatedTask_default_instance_);
}
inline ::tensorflow::CoordinatedTask* WaitForAllTasksRequest::release_source_task() {
  // @@protoc_insertion_point(field_release:tensorflow.WaitForAllTasksRequest.source_task)
  
  ::tensorflow::CoordinatedTask* temp = source_task_;
  source_task_ = nullptr;
  return temp;
}
inline ::tensorflow::CoordinatedTask* WaitForAllTasksRequest::mutable_source_task() {
  
  if (source_task_ == nullptr) {
    auto* p = CreateMaybeMessage<::tensorflow::CoordinatedTask>(GetArenaNoVirtual());
    source_task_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.WaitForAllTasksRequest.source_task)
  return source_task_;
}
inline void WaitForAllTasksRequest::set_allocated_source_task(::tensorflow::CoordinatedTask* source_task) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete source_task_;
  }
  if (source_task) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      source_task = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_task, submessage_arena);
    }
    
  } else {
    
  }
  source_task_ = source_task;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.WaitForAllTasksRequest.source_task)
}

// -------------------------------------------------------------------

// WaitForAllTasksResponse

// fixed64 leader_incarnation = 1;
inline void WaitForAllTasksResponse::clear_leader_incarnation() {
  leader_incarnation_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 WaitForAllTasksResponse::leader_incarnation() const {
  // @@protoc_insertion_point(field_get:tensorflow.WaitForAllTasksResponse.leader_incarnation)
  return leader_incarnation_;
}
inline void WaitForAllTasksResponse::set_leader_incarnation(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  leader_incarnation_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.WaitForAllTasksResponse.leader_incarnation)
}

// .tensorflow.CoordinationServiceDeviceInfo cluster_device_info = 3;
inline bool WaitForAllTasksResponse::has_cluster_device_info() const {
  return this != internal_default_instance() && cluster_device_info_ != nullptr;
}
inline void WaitForAllTasksResponse::clear_cluster_device_info() {
  if (GetArenaNoVirtual() == nullptr && cluster_device_info_ != nullptr) {
    delete cluster_device_info_;
  }
  cluster_device_info_ = nullptr;
}
inline const ::tensorflow::CoordinationServiceDeviceInfo& WaitForAllTasksResponse::cluster_device_info() const {
  const ::tensorflow::CoordinationServiceDeviceInfo* p = cluster_device_info_;
  // @@protoc_insertion_point(field_get:tensorflow.WaitForAllTasksResponse.cluster_device_info)
  return p != nullptr ? *p : *reinterpret_cast<const ::tensorflow::CoordinationServiceDeviceInfo*>(
      &::tensorflow::_CoordinationServiceDeviceInfo_default_instance_);
}
inline ::tensorflow::CoordinationServiceDeviceInfo* WaitForAllTasksResponse::release_cluster_device_info() {
  // @@protoc_insertion_point(field_release:tensorflow.WaitForAllTasksResponse.cluster_device_info)
  
  ::tensorflow::CoordinationServiceDeviceInfo* temp = cluster_device_info_;
  cluster_device_info_ = nullptr;
  return temp;
}
inline ::tensorflow::CoordinationServiceDeviceInfo* WaitForAllTasksResponse::mutable_cluster_device_info() {
  
  if (cluster_device_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::tensorflow::CoordinationServiceDeviceInfo>(GetArenaNoVirtual());
    cluster_device_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.WaitForAllTasksResponse.cluster_device_info)
  return cluster_device_info_;
}
inline void WaitForAllTasksResponse::set_allocated_cluster_device_info(::tensorflow::CoordinationServiceDeviceInfo* cluster_device_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete cluster_device_info_;
  }
  if (cluster_device_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      cluster_device_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cluster_device_info, submessage_arena);
    }
    
  } else {
    
  }
  cluster_device_info_ = cluster_device_info;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.WaitForAllTasksResponse.cluster_device_info)
}

// -------------------------------------------------------------------

// ShutdownTaskRequest

// .tensorflow.CoordinatedTask source_task = 1;
inline bool ShutdownTaskRequest::has_source_task() const {
  return this != internal_default_instance() && source_task_ != nullptr;
}
inline void ShutdownTaskRequest::clear_source_task() {
  if (GetArenaNoVirtual() == nullptr && source_task_ != nullptr) {
    delete source_task_;
  }
  source_task_ = nullptr;
}
inline const ::tensorflow::CoordinatedTask& ShutdownTaskRequest::source_task() const {
  const ::tensorflow::CoordinatedTask* p = source_task_;
  // @@protoc_insertion_point(field_get:tensorflow.ShutdownTaskRequest.source_task)
  return p != nullptr ? *p : *reinterpret_cast<const ::tensorflow::CoordinatedTask*>(
      &::tensorflow::_CoordinatedTask_default_instance_);
}
inline ::tensorflow::CoordinatedTask* ShutdownTaskRequest::release_source_task() {
  // @@protoc_insertion_point(field_release:tensorflow.ShutdownTaskRequest.source_task)
  
  ::tensorflow::CoordinatedTask* temp = source_task_;
  source_task_ = nullptr;
  return temp;
}
inline ::tensorflow::CoordinatedTask* ShutdownTaskRequest::mutable_source_task() {
  
  if (source_task_ == nullptr) {
    auto* p = CreateMaybeMessage<::tensorflow::CoordinatedTask>(GetArenaNoVirtual());
    source_task_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.ShutdownTaskRequest.source_task)
  return source_task_;
}
inline void ShutdownTaskRequest::set_allocated_source_task(::tensorflow::CoordinatedTask* source_task) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete source_task_;
  }
  if (source_task) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      source_task = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_task, submessage_arena);
    }
    
  } else {
    
  }
  source_task_ = source_task;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.ShutdownTaskRequest.source_task)
}

// -------------------------------------------------------------------

// ShutdownTaskResponse

// -------------------------------------------------------------------

// ResetTaskRequest

// .tensorflow.CoordinatedTask source_task = 1;
inline bool ResetTaskRequest::has_source_task() const {
  return this != internal_default_instance() && source_task_ != nullptr;
}
inline void ResetTaskRequest::clear_source_task() {
  if (GetArenaNoVirtual() == nullptr && source_task_ != nullptr) {
    delete source_task_;
  }
  source_task_ = nullptr;
}
inline const ::tensorflow::CoordinatedTask& ResetTaskRequest::source_task() const {
  const ::tensorflow::CoordinatedTask* p = source_task_;
  // @@protoc_insertion_point(field_get:tensorflow.ResetTaskRequest.source_task)
  return p != nullptr ? *p : *reinterpret_cast<const ::tensorflow::CoordinatedTask*>(
      &::tensorflow::_CoordinatedTask_default_instance_);
}
inline ::tensorflow::CoordinatedTask* ResetTaskRequest::release_source_task() {
  // @@protoc_insertion_point(field_release:tensorflow.ResetTaskRequest.source_task)
  
  ::tensorflow::CoordinatedTask* temp = source_task_;
  source_task_ = nullptr;
  return temp;
}
inline ::tensorflow::CoordinatedTask* ResetTaskRequest::mutable_source_task() {
  
  if (source_task_ == nullptr) {
    auto* p = CreateMaybeMessage<::tensorflow::CoordinatedTask>(GetArenaNoVirtual());
    source_task_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.ResetTaskRequest.source_task)
  return source_task_;
}
inline void ResetTaskRequest::set_allocated_source_task(::tensorflow::CoordinatedTask* source_task) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete source_task_;
  }
  if (source_task) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      source_task = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_task, submessage_arena);
    }
    
  } else {
    
  }
  source_task_ = source_task;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.ResetTaskRequest.source_task)
}

// -------------------------------------------------------------------

// ResetTaskResponse

// -------------------------------------------------------------------

// ReportErrorToTaskRequest

// int32 error_code = 1;
inline void ReportErrorToTaskRequest::clear_error_code() {
  error_code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ReportErrorToTaskRequest::error_code() const {
  // @@protoc_insertion_point(field_get:tensorflow.ReportErrorToTaskRequest.error_code)
  return error_code_;
}
inline void ReportErrorToTaskRequest::set_error_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  error_code_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.ReportErrorToTaskRequest.error_code)
}

// string error_message = 2;
inline void ReportErrorToTaskRequest::clear_error_message() {
  error_message_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ReportErrorToTaskRequest::error_message() const {
  // @@protoc_insertion_point(field_get:tensorflow.ReportErrorToTaskRequest.error_message)
  return error_message_.GetNoArena();
}
inline void ReportErrorToTaskRequest::set_error_message(const std::string& value) {
  
  error_message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.ReportErrorToTaskRequest.error_message)
}
inline void ReportErrorToTaskRequest::set_error_message(std::string&& value) {
  
  error_message_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.ReportErrorToTaskRequest.error_message)
}
inline void ReportErrorToTaskRequest::set_error_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  error_message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.ReportErrorToTaskRequest.error_message)
}
inline void ReportErrorToTaskRequest::set_error_message(const char* value, size_t size) {
  
  error_message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.ReportErrorToTaskRequest.error_message)
}
inline std::string* ReportErrorToTaskRequest::mutable_error_message() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.ReportErrorToTaskRequest.error_message)
  return error_message_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ReportErrorToTaskRequest::release_error_message() {
  // @@protoc_insertion_point(field_release:tensorflow.ReportErrorToTaskRequest.error_message)
  
  return error_message_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ReportErrorToTaskRequest::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  error_message_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_message);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.ReportErrorToTaskRequest.error_message)
}

// .tensorflow.CoordinationServiceError error_payload = 5;
inline bool ReportErrorToTaskRequest::has_error_payload() const {
  return this != internal_default_instance() && error_payload_ != nullptr;
}
inline void ReportErrorToTaskRequest::clear_error_payload() {
  if (GetArenaNoVirtual() == nullptr && error_payload_ != nullptr) {
    delete error_payload_;
  }
  error_payload_ = nullptr;
}
inline const ::tensorflow::CoordinationServiceError& ReportErrorToTaskRequest::error_payload() const {
  const ::tensorflow::CoordinationServiceError* p = error_payload_;
  // @@protoc_insertion_point(field_get:tensorflow.ReportErrorToTaskRequest.error_payload)
  return p != nullptr ? *p : *reinterpret_cast<const ::tensorflow::CoordinationServiceError*>(
      &::tensorflow::_CoordinationServiceError_default_instance_);
}
inline ::tensorflow::CoordinationServiceError* ReportErrorToTaskRequest::release_error_payload() {
  // @@protoc_insertion_point(field_release:tensorflow.ReportErrorToTaskRequest.error_payload)
  
  ::tensorflow::CoordinationServiceError* temp = error_payload_;
  error_payload_ = nullptr;
  return temp;
}
inline ::tensorflow::CoordinationServiceError* ReportErrorToTaskRequest::mutable_error_payload() {
  
  if (error_payload_ == nullptr) {
    auto* p = CreateMaybeMessage<::tensorflow::CoordinationServiceError>(GetArenaNoVirtual());
    error_payload_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.ReportErrorToTaskRequest.error_payload)
  return error_payload_;
}
inline void ReportErrorToTaskRequest::set_allocated_error_payload(::tensorflow::CoordinationServiceError* error_payload) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete error_payload_;
  }
  if (error_payload) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      error_payload = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error_payload, submessage_arena);
    }
    
  } else {
    
  }
  error_payload_ = error_payload;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.ReportErrorToTaskRequest.error_payload)
}

// -------------------------------------------------------------------

// ReportErrorToTaskResponse

// -------------------------------------------------------------------

// ReportErrorToServiceRequest

// int32 error_code = 1;
inline void ReportErrorToServiceRequest::clear_error_code() {
  error_code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ReportErrorToServiceRequest::error_code() const {
  // @@protoc_insertion_point(field_get:tensorflow.ReportErrorToServiceRequest.error_code)
  return error_code_;
}
inline void ReportErrorToServiceRequest::set_error_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  error_code_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.ReportErrorToServiceRequest.error_code)
}

// string error_message = 2;
inline void ReportErrorToServiceRequest::clear_error_message() {
  error_message_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ReportErrorToServiceRequest::error_message() const {
  // @@protoc_insertion_point(field_get:tensorflow.ReportErrorToServiceRequest.error_message)
  return error_message_.GetNoArena();
}
inline void ReportErrorToServiceRequest::set_error_message(const std::string& value) {
  
  error_message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.ReportErrorToServiceRequest.error_message)
}
inline void ReportErrorToServiceRequest::set_error_message(std::string&& value) {
  
  error_message_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.ReportErrorToServiceRequest.error_message)
}
inline void ReportErrorToServiceRequest::set_error_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  error_message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.ReportErrorToServiceRequest.error_message)
}
inline void ReportErrorToServiceRequest::set_error_message(const char* value, size_t size) {
  
  error_message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.ReportErrorToServiceRequest.error_message)
}
inline std::string* ReportErrorToServiceRequest::mutable_error_message() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.ReportErrorToServiceRequest.error_message)
  return error_message_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ReportErrorToServiceRequest::release_error_message() {
  // @@protoc_insertion_point(field_release:tensorflow.ReportErrorToServiceRequest.error_message)
  
  return error_message_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ReportErrorToServiceRequest::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  error_message_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_message);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.ReportErrorToServiceRequest.error_message)
}

// .tensorflow.CoordinatedTask error_origin = 5;
inline bool ReportErrorToServiceRequest::has_error_origin() const {
  return this != internal_default_instance() && error_origin_ != nullptr;
}
inline void ReportErrorToServiceRequest::clear_error_origin() {
  if (GetArenaNoVirtual() == nullptr && error_origin_ != nullptr) {
    delete error_origin_;
  }
  error_origin_ = nullptr;
}
inline const ::tensorflow::CoordinatedTask& ReportErrorToServiceRequest::error_origin() const {
  const ::tensorflow::CoordinatedTask* p = error_origin_;
  // @@protoc_insertion_point(field_get:tensorflow.ReportErrorToServiceRequest.error_origin)
  return p != nullptr ? *p : *reinterpret_cast<const ::tensorflow::CoordinatedTask*>(
      &::tensorflow::_CoordinatedTask_default_instance_);
}
inline ::tensorflow::CoordinatedTask* ReportErrorToServiceRequest::release_error_origin() {
  // @@protoc_insertion_point(field_release:tensorflow.ReportErrorToServiceRequest.error_origin)
  
  ::tensorflow::CoordinatedTask* temp = error_origin_;
  error_origin_ = nullptr;
  return temp;
}
inline ::tensorflow::CoordinatedTask* ReportErrorToServiceRequest::mutable_error_origin() {
  
  if (error_origin_ == nullptr) {
    auto* p = CreateMaybeMessage<::tensorflow::CoordinatedTask>(GetArenaNoVirtual());
    error_origin_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.ReportErrorToServiceRequest.error_origin)
  return error_origin_;
}
inline void ReportErrorToServiceRequest::set_allocated_error_origin(::tensorflow::CoordinatedTask* error_origin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete error_origin_;
  }
  if (error_origin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      error_origin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error_origin, submessage_arena);
    }
    
  } else {
    
  }
  error_origin_ = error_origin;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.ReportErrorToServiceRequest.error_origin)
}

// -------------------------------------------------------------------

// ReportErrorToServiceResponse

// -------------------------------------------------------------------

// GetTaskStateRequest

// repeated .tensorflow.CoordinatedTask source_task = 1;
inline int GetTaskStateRequest::source_task_size() const {
  return source_task_.size();
}
inline void GetTaskStateRequest::clear_source_task() {
  source_task_.Clear();
}
inline ::tensorflow::CoordinatedTask* GetTaskStateRequest::mutable_source_task(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.GetTaskStateRequest.source_task)
  return source_task_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::CoordinatedTask >*
GetTaskStateRequest::mutable_source_task() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.GetTaskStateRequest.source_task)
  return &source_task_;
}
inline const ::tensorflow::CoordinatedTask& GetTaskStateRequest::source_task(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.GetTaskStateRequest.source_task)
  return source_task_.Get(index);
}
inline ::tensorflow::CoordinatedTask* GetTaskStateRequest::add_source_task() {
  // @@protoc_insertion_point(field_add:tensorflow.GetTaskStateRequest.source_task)
  return source_task_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::CoordinatedTask >&
GetTaskStateRequest::source_task() const {
  // @@protoc_insertion_point(field_list:tensorflow.GetTaskStateRequest.source_task)
  return source_task_;
}

// -------------------------------------------------------------------

// GetTaskStateResponse

// repeated .tensorflow.CoordinatedTaskStateInfo task_state = 1;
inline int GetTaskStateResponse::task_state_size() const {
  return task_state_.size();
}
inline void GetTaskStateResponse::clear_task_state() {
  task_state_.Clear();
}
inline ::tensorflow::CoordinatedTaskStateInfo* GetTaskStateResponse::mutable_task_state(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.GetTaskStateResponse.task_state)
  return task_state_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::CoordinatedTaskStateInfo >*
GetTaskStateResponse::mutable_task_state() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.GetTaskStateResponse.task_state)
  return &task_state_;
}
inline const ::tensorflow::CoordinatedTaskStateInfo& GetTaskStateResponse::task_state(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.GetTaskStateResponse.task_state)
  return task_state_.Get(index);
}
inline ::tensorflow::CoordinatedTaskStateInfo* GetTaskStateResponse::add_task_state() {
  // @@protoc_insertion_point(field_add:tensorflow.GetTaskStateResponse.task_state)
  return task_state_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::CoordinatedTaskStateInfo >&
GetTaskStateResponse::task_state() const {
  // @@protoc_insertion_point(field_list:tensorflow.GetTaskStateResponse.task_state)
  return task_state_;
}

// -------------------------------------------------------------------

// KeyValueEntry

// string key = 1;
inline void KeyValueEntry::clear_key() {
  key_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& KeyValueEntry::key() const {
  // @@protoc_insertion_point(field_get:tensorflow.KeyValueEntry.key)
  return key_.GetNoArena();
}
inline void KeyValueEntry::set_key(const std::string& value) {
  
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.KeyValueEntry.key)
}
inline void KeyValueEntry::set_key(std::string&& value) {
  
  key_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.KeyValueEntry.key)
}
inline void KeyValueEntry::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.KeyValueEntry.key)
}
inline void KeyValueEntry::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.KeyValueEntry.key)
}
inline std::string* KeyValueEntry::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.KeyValueEntry.key)
  return key_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* KeyValueEntry::release_key() {
  // @@protoc_insertion_point(field_release:tensorflow.KeyValueEntry.key)
  
  return key_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void KeyValueEntry::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.KeyValueEntry.key)
}

// bytes value = 2;
inline void KeyValueEntry::clear_value() {
  value_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& KeyValueEntry::value() const {
  // @@protoc_insertion_point(field_get:tensorflow.KeyValueEntry.value)
  return value_.GetNoArena();
}
inline void KeyValueEntry::set_value(const std::string& value) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.KeyValueEntry.value)
}
inline void KeyValueEntry::set_value(std::string&& value) {
  
  value_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.KeyValueEntry.value)
}
inline void KeyValueEntry::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.KeyValueEntry.value)
}
inline void KeyValueEntry::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.KeyValueEntry.value)
}
inline std::string* KeyValueEntry::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.KeyValueEntry.value)
  return value_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* KeyValueEntry::release_value() {
  // @@protoc_insertion_point(field_release:tensorflow.KeyValueEntry.value)
  
  return value_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void KeyValueEntry::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.KeyValueEntry.value)
}

// -------------------------------------------------------------------

// InsertKeyValueRequest

// .tensorflow.KeyValueEntry kv = 1;
inline bool InsertKeyValueRequest::has_kv() const {
  return this != internal_default_instance() && kv_ != nullptr;
}
inline void InsertKeyValueRequest::clear_kv() {
  if (GetArenaNoVirtual() == nullptr && kv_ != nullptr) {
    delete kv_;
  }
  kv_ = nullptr;
}
inline const ::tensorflow::KeyValueEntry& InsertKeyValueRequest::kv() const {
  const ::tensorflow::KeyValueEntry* p = kv_;
  // @@protoc_insertion_point(field_get:tensorflow.InsertKeyValueRequest.kv)
  return p != nullptr ? *p : *reinterpret_cast<const ::tensorflow::KeyValueEntry*>(
      &::tensorflow::_KeyValueEntry_default_instance_);
}
inline ::tensorflow::KeyValueEntry* InsertKeyValueRequest::release_kv() {
  // @@protoc_insertion_point(field_release:tensorflow.InsertKeyValueRequest.kv)
  
  ::tensorflow::KeyValueEntry* temp = kv_;
  kv_ = nullptr;
  return temp;
}
inline ::tensorflow::KeyValueEntry* InsertKeyValueRequest::mutable_kv() {
  
  if (kv_ == nullptr) {
    auto* p = CreateMaybeMessage<::tensorflow::KeyValueEntry>(GetArenaNoVirtual());
    kv_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.InsertKeyValueRequest.kv)
  return kv_;
}
inline void InsertKeyValueRequest::set_allocated_kv(::tensorflow::KeyValueEntry* kv) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete kv_;
  }
  if (kv) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      kv = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, kv, submessage_arena);
    }
    
  } else {
    
  }
  kv_ = kv;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.InsertKeyValueRequest.kv)
}

// -------------------------------------------------------------------

// InsertKeyValueResponse

// -------------------------------------------------------------------

// GetKeyValueRequest

// string key = 1;
inline void GetKeyValueRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& GetKeyValueRequest::key() const {
  // @@protoc_insertion_point(field_get:tensorflow.GetKeyValueRequest.key)
  return key_.GetNoArena();
}
inline void GetKeyValueRequest::set_key(const std::string& value) {
  
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.GetKeyValueRequest.key)
}
inline void GetKeyValueRequest::set_key(std::string&& value) {
  
  key_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.GetKeyValueRequest.key)
}
inline void GetKeyValueRequest::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.GetKeyValueRequest.key)
}
inline void GetKeyValueRequest::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.GetKeyValueRequest.key)
}
inline std::string* GetKeyValueRequest::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.GetKeyValueRequest.key)
  return key_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GetKeyValueRequest::release_key() {
  // @@protoc_insertion_point(field_release:tensorflow.GetKeyValueRequest.key)
  
  return key_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GetKeyValueRequest::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.GetKeyValueRequest.key)
}

// -------------------------------------------------------------------

// GetKeyValueResponse

// .tensorflow.KeyValueEntry kv = 1;
inline bool GetKeyValueResponse::has_kv() const {
  return this != internal_default_instance() && kv_ != nullptr;
}
inline void GetKeyValueResponse::clear_kv() {
  if (GetArenaNoVirtual() == nullptr && kv_ != nullptr) {
    delete kv_;
  }
  kv_ = nullptr;
}
inline const ::tensorflow::KeyValueEntry& GetKeyValueResponse::kv() const {
  const ::tensorflow::KeyValueEntry* p = kv_;
  // @@protoc_insertion_point(field_get:tensorflow.GetKeyValueResponse.kv)
  return p != nullptr ? *p : *reinterpret_cast<const ::tensorflow::KeyValueEntry*>(
      &::tensorflow::_KeyValueEntry_default_instance_);
}
inline ::tensorflow::KeyValueEntry* GetKeyValueResponse::release_kv() {
  // @@protoc_insertion_point(field_release:tensorflow.GetKeyValueResponse.kv)
  
  ::tensorflow::KeyValueEntry* temp = kv_;
  kv_ = nullptr;
  return temp;
}
inline ::tensorflow::KeyValueEntry* GetKeyValueResponse::mutable_kv() {
  
  if (kv_ == nullptr) {
    auto* p = CreateMaybeMessage<::tensorflow::KeyValueEntry>(GetArenaNoVirtual());
    kv_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.GetKeyValueResponse.kv)
  return kv_;
}
inline void GetKeyValueResponse::set_allocated_kv(::tensorflow::KeyValueEntry* kv) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete kv_;
  }
  if (kv) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      kv = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, kv, submessage_arena);
    }
    
  } else {
    
  }
  kv_ = kv;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.GetKeyValueResponse.kv)
}

// -------------------------------------------------------------------

// TryGetKeyValueRequest

// string key = 1;
inline void TryGetKeyValueRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& TryGetKeyValueRequest::key() const {
  // @@protoc_insertion_point(field_get:tensorflow.TryGetKeyValueRequest.key)
  return key_.GetNoArena();
}
inline void TryGetKeyValueRequest::set_key(const std::string& value) {
  
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.TryGetKeyValueRequest.key)
}
inline void TryGetKeyValueRequest::set_key(std::string&& value) {
  
  key_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.TryGetKeyValueRequest.key)
}
inline void TryGetKeyValueRequest::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.TryGetKeyValueRequest.key)
}
inline void TryGetKeyValueRequest::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.TryGetKeyValueRequest.key)
}
inline std::string* TryGetKeyValueRequest::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.TryGetKeyValueRequest.key)
  return key_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TryGetKeyValueRequest::release_key() {
  // @@protoc_insertion_point(field_release:tensorflow.TryGetKeyValueRequest.key)
  
  return key_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TryGetKeyValueRequest::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.TryGetKeyValueRequest.key)
}

// -------------------------------------------------------------------

// TryGetKeyValueResponse

// .tensorflow.KeyValueEntry kv = 1;
inline bool TryGetKeyValueResponse::has_kv() const {
  return this != internal_default_instance() && kv_ != nullptr;
}
inline void TryGetKeyValueResponse::clear_kv() {
  if (GetArenaNoVirtual() == nullptr && kv_ != nullptr) {
    delete kv_;
  }
  kv_ = nullptr;
}
inline const ::tensorflow::KeyValueEntry& TryGetKeyValueResponse::kv() const {
  const ::tensorflow::KeyValueEntry* p = kv_;
  // @@protoc_insertion_point(field_get:tensorflow.TryGetKeyValueResponse.kv)
  return p != nullptr ? *p : *reinterpret_cast<const ::tensorflow::KeyValueEntry*>(
      &::tensorflow::_KeyValueEntry_default_instance_);
}
inline ::tensorflow::KeyValueEntry* TryGetKeyValueResponse::release_kv() {
  // @@protoc_insertion_point(field_release:tensorflow.TryGetKeyValueResponse.kv)
  
  ::tensorflow::KeyValueEntry* temp = kv_;
  kv_ = nullptr;
  return temp;
}
inline ::tensorflow::KeyValueEntry* TryGetKeyValueResponse::mutable_kv() {
  
  if (kv_ == nullptr) {
    auto* p = CreateMaybeMessage<::tensorflow::KeyValueEntry>(GetArenaNoVirtual());
    kv_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.TryGetKeyValueResponse.kv)
  return kv_;
}
inline void TryGetKeyValueResponse::set_allocated_kv(::tensorflow::KeyValueEntry* kv) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete kv_;
  }
  if (kv) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      kv = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, kv, submessage_arena);
    }
    
  } else {
    
  }
  kv_ = kv;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.TryGetKeyValueResponse.kv)
}

// -------------------------------------------------------------------

// GetKeyValueDirRequest

// string directory_key = 1;
inline void GetKeyValueDirRequest::clear_directory_key() {
  directory_key_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& GetKeyValueDirRequest::directory_key() const {
  // @@protoc_insertion_point(field_get:tensorflow.GetKeyValueDirRequest.directory_key)
  return directory_key_.GetNoArena();
}
inline void GetKeyValueDirRequest::set_directory_key(const std::string& value) {
  
  directory_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.GetKeyValueDirRequest.directory_key)
}
inline void GetKeyValueDirRequest::set_directory_key(std::string&& value) {
  
  directory_key_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.GetKeyValueDirRequest.directory_key)
}
inline void GetKeyValueDirRequest::set_directory_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  directory_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.GetKeyValueDirRequest.directory_key)
}
inline void GetKeyValueDirRequest::set_directory_key(const char* value, size_t size) {
  
  directory_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.GetKeyValueDirRequest.directory_key)
}
inline std::string* GetKeyValueDirRequest::mutable_directory_key() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.GetKeyValueDirRequest.directory_key)
  return directory_key_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GetKeyValueDirRequest::release_directory_key() {
  // @@protoc_insertion_point(field_release:tensorflow.GetKeyValueDirRequest.directory_key)
  
  return directory_key_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GetKeyValueDirRequest::set_allocated_directory_key(std::string* directory_key) {
  if (directory_key != nullptr) {
    
  } else {
    
  }
  directory_key_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), directory_key);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.GetKeyValueDirRequest.directory_key)
}

// -------------------------------------------------------------------

// GetKeyValueDirResponse

// string directory_key = 1;
inline void GetKeyValueDirResponse::clear_directory_key() {
  directory_key_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& GetKeyValueDirResponse::directory_key() const {
  // @@protoc_insertion_point(field_get:tensorflow.GetKeyValueDirResponse.directory_key)
  return directory_key_.GetNoArena();
}
inline void GetKeyValueDirResponse::set_directory_key(const std::string& value) {
  
  directory_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.GetKeyValueDirResponse.directory_key)
}
inline void GetKeyValueDirResponse::set_directory_key(std::string&& value) {
  
  directory_key_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.GetKeyValueDirResponse.directory_key)
}
inline void GetKeyValueDirResponse::set_directory_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  directory_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.GetKeyValueDirResponse.directory_key)
}
inline void GetKeyValueDirResponse::set_directory_key(const char* value, size_t size) {
  
  directory_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.GetKeyValueDirResponse.directory_key)
}
inline std::string* GetKeyValueDirResponse::mutable_directory_key() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.GetKeyValueDirResponse.directory_key)
  return directory_key_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GetKeyValueDirResponse::release_directory_key() {
  // @@protoc_insertion_point(field_release:tensorflow.GetKeyValueDirResponse.directory_key)
  
  return directory_key_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GetKeyValueDirResponse::set_allocated_directory_key(std::string* directory_key) {
  if (directory_key != nullptr) {
    
  } else {
    
  }
  directory_key_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), directory_key);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.GetKeyValueDirResponse.directory_key)
}

// repeated .tensorflow.KeyValueEntry kv = 2;
inline int GetKeyValueDirResponse::kv_size() const {
  return kv_.size();
}
inline void GetKeyValueDirResponse::clear_kv() {
  kv_.Clear();
}
inline ::tensorflow::KeyValueEntry* GetKeyValueDirResponse::mutable_kv(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.GetKeyValueDirResponse.kv)
  return kv_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::KeyValueEntry >*
GetKeyValueDirResponse::mutable_kv() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.GetKeyValueDirResponse.kv)
  return &kv_;
}
inline const ::tensorflow::KeyValueEntry& GetKeyValueDirResponse::kv(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.GetKeyValueDirResponse.kv)
  return kv_.Get(index);
}
inline ::tensorflow::KeyValueEntry* GetKeyValueDirResponse::add_kv() {
  // @@protoc_insertion_point(field_add:tensorflow.GetKeyValueDirResponse.kv)
  return kv_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::KeyValueEntry >&
GetKeyValueDirResponse::kv() const {
  // @@protoc_insertion_point(field_list:tensorflow.GetKeyValueDirResponse.kv)
  return kv_;
}

// -------------------------------------------------------------------

// DeleteKeyValueRequest

// string key = 1;
inline void DeleteKeyValueRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& DeleteKeyValueRequest::key() const {
  // @@protoc_insertion_point(field_get:tensorflow.DeleteKeyValueRequest.key)
  return key_.GetNoArena();
}
inline void DeleteKeyValueRequest::set_key(const std::string& value) {
  
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.DeleteKeyValueRequest.key)
}
inline void DeleteKeyValueRequest::set_key(std::string&& value) {
  
  key_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.DeleteKeyValueRequest.key)
}
inline void DeleteKeyValueRequest::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.DeleteKeyValueRequest.key)
}
inline void DeleteKeyValueRequest::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.DeleteKeyValueRequest.key)
}
inline std::string* DeleteKeyValueRequest::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.DeleteKeyValueRequest.key)
  return key_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DeleteKeyValueRequest::release_key() {
  // @@protoc_insertion_point(field_release:tensorflow.DeleteKeyValueRequest.key)
  
  return key_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DeleteKeyValueRequest::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.DeleteKeyValueRequest.key)
}

// bool is_directory = 2;
inline void DeleteKeyValueRequest::clear_is_directory() {
  is_directory_ = false;
}
inline bool DeleteKeyValueRequest::is_directory() const {
  // @@protoc_insertion_point(field_get:tensorflow.DeleteKeyValueRequest.is_directory)
  return is_directory_;
}
inline void DeleteKeyValueRequest::set_is_directory(bool value) {
  
  is_directory_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.DeleteKeyValueRequest.is_directory)
}

// -------------------------------------------------------------------

// DeleteKeyValueResponse

// -------------------------------------------------------------------

// BarrierRequest

// string barrier_id = 1;
inline void BarrierRequest::clear_barrier_id() {
  barrier_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& BarrierRequest::barrier_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.BarrierRequest.barrier_id)
  return barrier_id_.GetNoArena();
}
inline void BarrierRequest::set_barrier_id(const std::string& value) {
  
  barrier_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.BarrierRequest.barrier_id)
}
inline void BarrierRequest::set_barrier_id(std::string&& value) {
  
  barrier_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.BarrierRequest.barrier_id)
}
inline void BarrierRequest::set_barrier_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  barrier_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.BarrierRequest.barrier_id)
}
inline void BarrierRequest::set_barrier_id(const char* value, size_t size) {
  
  barrier_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.BarrierRequest.barrier_id)
}
inline std::string* BarrierRequest::mutable_barrier_id() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.BarrierRequest.barrier_id)
  return barrier_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* BarrierRequest::release_barrier_id() {
  // @@protoc_insertion_point(field_release:tensorflow.BarrierRequest.barrier_id)
  
  return barrier_id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void BarrierRequest::set_allocated_barrier_id(std::string* barrier_id) {
  if (barrier_id != nullptr) {
    
  } else {
    
  }
  barrier_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), barrier_id);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.BarrierRequest.barrier_id)
}

// int64 barrier_timeout_in_ms = 2;
inline void BarrierRequest::clear_barrier_timeout_in_ms() {
  barrier_timeout_in_ms_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BarrierRequest::barrier_timeout_in_ms() const {
  // @@protoc_insertion_point(field_get:tensorflow.BarrierRequest.barrier_timeout_in_ms)
  return barrier_timeout_in_ms_;
}
inline void BarrierRequest::set_barrier_timeout_in_ms(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  barrier_timeout_in_ms_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.BarrierRequest.barrier_timeout_in_ms)
}

// repeated .tensorflow.CoordinatedTask tasks = 3;
inline int BarrierRequest::tasks_size() const {
  return tasks_.size();
}
inline void BarrierRequest::clear_tasks() {
  tasks_.Clear();
}
inline ::tensorflow::CoordinatedTask* BarrierRequest::mutable_tasks(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.BarrierRequest.tasks)
  return tasks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::CoordinatedTask >*
BarrierRequest::mutable_tasks() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.BarrierRequest.tasks)
  return &tasks_;
}
inline const ::tensorflow::CoordinatedTask& BarrierRequest::tasks(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.BarrierRequest.tasks)
  return tasks_.Get(index);
}
inline ::tensorflow::CoordinatedTask* BarrierRequest::add_tasks() {
  // @@protoc_insertion_point(field_add:tensorflow.BarrierRequest.tasks)
  return tasks_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::CoordinatedTask >&
BarrierRequest::tasks() const {
  // @@protoc_insertion_point(field_list:tensorflow.BarrierRequest.tasks)
  return tasks_;
}

// .tensorflow.CoordinatedTask source_task = 4;
inline bool BarrierRequest::has_source_task() const {
  return this != internal_default_instance() && source_task_ != nullptr;
}
inline void BarrierRequest::clear_source_task() {
  if (GetArenaNoVirtual() == nullptr && source_task_ != nullptr) {
    delete source_task_;
  }
  source_task_ = nullptr;
}
inline const ::tensorflow::CoordinatedTask& BarrierRequest::source_task() const {
  const ::tensorflow::CoordinatedTask* p = source_task_;
  // @@protoc_insertion_point(field_get:tensorflow.BarrierRequest.source_task)
  return p != nullptr ? *p : *reinterpret_cast<const ::tensorflow::CoordinatedTask*>(
      &::tensorflow::_CoordinatedTask_default_instance_);
}
inline ::tensorflow::CoordinatedTask* BarrierRequest::release_source_task() {
  // @@protoc_insertion_point(field_release:tensorflow.BarrierRequest.source_task)
  
  ::tensorflow::CoordinatedTask* temp = source_task_;
  source_task_ = nullptr;
  return temp;
}
inline ::tensorflow::CoordinatedTask* BarrierRequest::mutable_source_task() {
  
  if (source_task_ == nullptr) {
    auto* p = CreateMaybeMessage<::tensorflow::CoordinatedTask>(GetArenaNoVirtual());
    source_task_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.BarrierRequest.source_task)
  return source_task_;
}
inline void BarrierRequest::set_allocated_source_task(::tensorflow::CoordinatedTask* source_task) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete source_task_;
  }
  if (source_task) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      source_task = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_task, submessage_arena);
    }
    
  } else {
    
  }
  source_task_ = source_task;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.BarrierRequest.source_task)
}

// -------------------------------------------------------------------

// BarrierResponse

// -------------------------------------------------------------------

// CancelBarrierRequest

// string barrier_id = 1;
inline void CancelBarrierRequest::clear_barrier_id() {
  barrier_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CancelBarrierRequest::barrier_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.CancelBarrierRequest.barrier_id)
  return barrier_id_.GetNoArena();
}
inline void CancelBarrierRequest::set_barrier_id(const std::string& value) {
  
  barrier_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.CancelBarrierRequest.barrier_id)
}
inline void CancelBarrierRequest::set_barrier_id(std::string&& value) {
  
  barrier_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.CancelBarrierRequest.barrier_id)
}
inline void CancelBarrierRequest::set_barrier_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  barrier_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.CancelBarrierRequest.barrier_id)
}
inline void CancelBarrierRequest::set_barrier_id(const char* value, size_t size) {
  
  barrier_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.CancelBarrierRequest.barrier_id)
}
inline std::string* CancelBarrierRequest::mutable_barrier_id() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.CancelBarrierRequest.barrier_id)
  return barrier_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CancelBarrierRequest::release_barrier_id() {
  // @@protoc_insertion_point(field_release:tensorflow.CancelBarrierRequest.barrier_id)
  
  return barrier_id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CancelBarrierRequest::set_allocated_barrier_id(std::string* barrier_id) {
  if (barrier_id != nullptr) {
    
  } else {
    
  }
  barrier_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), barrier_id);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.CancelBarrierRequest.barrier_id)
}

// .tensorflow.CoordinatedTask source_task = 2;
inline bool CancelBarrierRequest::has_source_task() const {
  return this != internal_default_instance() && source_task_ != nullptr;
}
inline void CancelBarrierRequest::clear_source_task() {
  if (GetArenaNoVirtual() == nullptr && source_task_ != nullptr) {
    delete source_task_;
  }
  source_task_ = nullptr;
}
inline const ::tensorflow::CoordinatedTask& CancelBarrierRequest::source_task() const {
  const ::tensorflow::CoordinatedTask* p = source_task_;
  // @@protoc_insertion_point(field_get:tensorflow.CancelBarrierRequest.source_task)
  return p != nullptr ? *p : *reinterpret_cast<const ::tensorflow::CoordinatedTask*>(
      &::tensorflow::_CoordinatedTask_default_instance_);
}
inline ::tensorflow::CoordinatedTask* CancelBarrierRequest::release_source_task() {
  // @@protoc_insertion_point(field_release:tensorflow.CancelBarrierRequest.source_task)
  
  ::tensorflow::CoordinatedTask* temp = source_task_;
  source_task_ = nullptr;
  return temp;
}
inline ::tensorflow::CoordinatedTask* CancelBarrierRequest::mutable_source_task() {
  
  if (source_task_ == nullptr) {
    auto* p = CreateMaybeMessage<::tensorflow::CoordinatedTask>(GetArenaNoVirtual());
    source_task_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.CancelBarrierRequest.source_task)
  return source_task_;
}
inline void CancelBarrierRequest::set_allocated_source_task(::tensorflow::CoordinatedTask* source_task) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete source_task_;
  }
  if (source_task) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      source_task = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_task, submessage_arena);
    }
    
  } else {
    
  }
  source_task_ = source_task;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.CancelBarrierRequest.source_task)
}

// -------------------------------------------------------------------

// CancelBarrierResponse

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace tensorflow

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::tensorflow::CoordinatedTaskState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tensorflow::CoordinatedTaskState>() {
  return ::tensorflow::CoordinatedTaskState_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto
