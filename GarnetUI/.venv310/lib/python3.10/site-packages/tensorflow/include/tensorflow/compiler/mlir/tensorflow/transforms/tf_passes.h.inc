/* Autogenerated by mlir-tblgen; don't manually edit */

#ifdef GEN_PASS_DECL
// Generate declarations for all passes.
#define GEN_PASS_DECL_BATCHMATMULTOEINSUMPASS
#define GEN_PASS_DECL_BREAKUPISLANDSPASS
#define GEN_PASS_DECL_BROADCASTFOLDPASS
#define GEN_PASS_DECL_CANONICALIZECOMPILEANDREPLICATEATTRIBUTESPASS
#define GEN_PASS_DECL_CLUSTERCONSTANTSINKINGPASS
#define GEN_PASS_DECL_CLUSTERFORMATIONPASS
#define GEN_PASS_DECL_CLUSTEROUTLININGPASS
#define GEN_PASS_DECL_CLUSTERTFOPSBYHOSTPASS
#define GEN_PASS_DECL_CONSTANTOPDEVICEASSIGNMENTPASS
#define GEN_PASS_DECL_CONVERTLAUNCHFUNCTOTFCALLPASS
#define GEN_PASS_DECL_CONVERTREADONLYREFERENCEVARIABLESTORESOURCEVARIABLESPASS
#define GEN_PASS_DECL_CONVERTTFCONTROLFLOWTOSCFPASS
#define GEN_PASS_DECL_CONVERTTOLEGACYCOMPILEANDREPLICATEATTRIBUTESPASS
#define GEN_PASS_DECL_DECOMPOSEREDUCEDATASETPASS
#define GEN_PASS_DECL_DEVICEINDEXSELECTORPASS
#define GEN_PASS_DECL_DROPWHILESHAPEINVARIANTINDEVICECLUSTERPASS
#define GEN_PASS_DECL_DROPWHILESHAPEINVARIANTPASS
#define GEN_PASS_DECL_EXECUTORCHECKCONTROLDEPENDENCIESPASS
#define GEN_PASS_DECL_EXECUTORCONVERTCONTROLTODATAOUTPUTSPASS
#define GEN_PASS_DECL_EXECUTORDIALECTTOFUNCTIONALPASS
#define GEN_PASS_DECL_EXECUTORGRAPHPRUNINGPASS
#define GEN_PASS_DECL_EXECUTORISLANDCOARSENINGPASS
#define GEN_PASS_DECL_EXECUTORTPUV1ISLANDINLININGPASS
#define GEN_PASS_DECL_EXECUTORUPDATECONTROLDEPENDENCIESPASS
#define GEN_PASS_DECL_FUNCTIONALCONTROLFLOWTOCFGPASS
#define GEN_PASS_DECL_FUNCTIONALCONTROLFLOWTOREGIONSPASS
#define GEN_PASS_DECL_FUNCTIONALTOEXECUTORDIALECTCONVERSIONPASS
#define GEN_PASS_DECL_FUSEDKERNELMATCHERPASS
#define GEN_PASS_DECL_GROUPBYDIALECTPASS
#define GEN_PASS_DECL_GUARANTEEALLFUNCSONEUSEPASS
#define GEN_PASS_DECL_HOISTREPLICATEINVARIANTRESOURCEWRITESPASS
#define GEN_PASS_DECL_INITTEXTFILETOIMPORTPASS
#define GEN_PASS_DECL_LAUNCHOUTLININGPASS
#define GEN_PASS_DECL_LAYOUTASSIGNMENTPASS
#define GEN_PASS_DECL_LEGALIZEHLOTOTFPASS
#define GEN_PASS_DECL_LEGALIZETFGTOTFPASS
#define GEN_PASS_DECL_LOCALIZEVARHANDLESPASS
#define GEN_PASS_DECL_LOWERQUANTIZEDPASS
#define GEN_PASS_DECL_MARKINPUTOUTPUTALIASESPASS
#define GEN_PASS_DECL_MARKOPSFOROUTSIDECOMPILATIONPASS
#define GEN_PASS_DECL_MATERIALIZEPASSTHROUGHOP
#define GEN_PASS_DECL_MERGECONTROLFLOWPASS
#define GEN_PASS_DECL_MOVETRANSPOSESPASS
#define GEN_PASS_DECL_NAMEANONYMOUSITERATORSPASS
#define GEN_PASS_DECL_ORDERBYDIALECTPASS
#define GEN_PASS_DECL_OUTSIDECOMPILEDTOHOSTLAUNCHPASS
#define GEN_PASS_DECL_PARALLELEXECUTETOISLANDSPASS
#define GEN_PASS_DECL_PREPARETPUCOMPUTATIONFORTFEXPORTPASS
#define GEN_PASS_DECL_PROMOTERESOURCESTOARGSPASS
#define GEN_PASS_DECL_PROMOTEVARHANDLESTOARGSPASS
#define GEN_PASS_DECL_REGIONCONTROLFLOWTOFUNCTIONALPASS
#define GEN_PASS_DECL_REMOVEUNUSEDARGUMENTSPASS
#define GEN_PASS_DECL_REMOVEUNUSEDWHILERESULTSPASS
#define GEN_PASS_DECL_REPLICAIDTODEVICEORDINALPASS
#define GEN_PASS_DECL_REPLICATEINVARIANTOPHOISTINGPASS
#define GEN_PASS_DECL_REPLICATETOISLANDPASS
#define GEN_PASS_DECL_RESOURCEDEVICEINFERENCEPASS
#define GEN_PASS_DECL_REWRITETPUEMBEDDINGOPSPASS
#define GEN_PASS_DECL_SIMPLETFDEVICEASSIGNMENTPASS
#define GEN_PASS_DECL_SPLITINTOISLANDPEROPPASS
#define GEN_PASS_DECL_STACKOPSDECOMPOSITIONPASS
#define GEN_PASS_DECL_STRIPNOINLINEATTRIBUTEPASS
#define GEN_PASS_DECL_STRIPTFATTRIBUTESPASS
#define GEN_PASS_DECL_TFDATAOPTIMIZATIONPASS
#define GEN_PASS_DECL_TFDEVICEASSIGNMENTBYFUNCATTRPASS
#define GEN_PASS_DECL_TPUBRIDGEEXECUTORISLANDOUTLININGPASS
#define GEN_PASS_DECL_TPUCLEANUPCLUSTERATTRIBUTESPASS
#define GEN_PASS_DECL_TPUCLUSTERFORMATIONPASS
#define GEN_PASS_DECL_TPUCOLOCATECOMPOSITERESOURCEOPSPASS
#define GEN_PASS_DECL_TPUDEVICEPROPAGATIONPASS
#define GEN_PASS_DECL_TPUDYNAMICLAYOUTPASS
#define GEN_PASS_DECL_TPUEXTRACTHEADTAILOUTSIDECOMPILATIONPASS
#define GEN_PASS_DECL_TPUEXTRACTOUTSIDECOMPILATIONPASS
#define GEN_PASS_DECL_TPUHOSTCOMPUTATIONEXPANSIONPASS
#define GEN_PASS_DECL_TPUIDENTITYPRUNINGPASS
#define GEN_PASS_DECL_TPUMERGEVARIABLESWITHEXECUTEPASS
#define GEN_PASS_DECL_TPUPARALLELEXECUTESINKRESOURCEWRITEPASS
#define GEN_PASS_DECL_TPUREORDERREPLICATEANDPARTITIONEDINPUTSPASS
#define GEN_PASS_DECL_TPURESOURCEREADFORWRITEPASS
#define GEN_PASS_DECL_TPURESOURCEREADSWRITESPARTITIONINGPASS
#define GEN_PASS_DECL_TPUREWRITEPASS
#define GEN_PASS_DECL_TPUSHARDINGIDENTIFICATIONPASS
#define GEN_PASS_DECL_TPUSPACETODEPTHPASS
#define GEN_PASS_DECL_TPUUPDATEEMBEDDINGENQUEUEOPINPUTSPASS
#define GEN_PASS_DECL_TPUVARIABLERUNTIMEREFORMATTINGPASS
#define GEN_PASS_DECL_TENSORARRAYOPSDECOMPOSITIONPASS
#define GEN_PASS_DECL_TENSORDEVICECOPYCONVERSIONPASS
#define GEN_PASS_DECL_TENSORFLOWOPTIMIZEPASS
#define GEN_PASS_DECL_TENSORFLOWSHAPEINFERENCEPASS
#define GEN_PASS_DECL_TENSORLISTOPSDECOMPOSITIONPASS
#define GEN_PASS_DECL_TENSORFLOWGPUFUSION
#define GEN_PASS_DECL_TPUV1BRIDGEEXECUTORISLANDCOARSENINGPASS
#define GEN_PASS_DECL_TRANSFORMEINSUMPASS
#define GEN_PASS_DECL_UNROLLBATCHMATMULPASS
#define GEN_PASS_DECL_VERIFYSUITABLEFOREXPORTPASS
#undef GEN_PASS_DECL
#endif // GEN_PASS_DECL

//===----------------------------------------------------------------------===//
// BatchMatMulToEinsumPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_BATCHMATMULTOEINSUMPASS
#undef GEN_PASS_DECL_BATCHMATMULTOEINSUMPASS
#endif // GEN_PASS_DECL_BATCHMATMULTOEINSUMPASS
#ifdef GEN_PASS_DEF_BATCHMATMULTOEINSUMPASS
namespace impl {

template <typename DerivedT>
class BatchMatMulToEinsumPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = BatchMatMulToEinsumPassBase;

  BatchMatMulToEinsumPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  BatchMatMulToEinsumPassBase(const BatchMatMulToEinsumPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-batch-matmul-to-tf-einsum");
  }
  ::llvm::StringRef getArgument() const override { return "tf-batch-matmul-to-tf-einsum"; }

  ::llvm::StringRef getDescription() const override { return "Replace TF BatchMatMul op by TF Einsum op."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("BatchMatMulToEinsumPass");
  }
  ::llvm::StringRef getName() const override { return "BatchMatMulToEinsumPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(BatchMatMulToEinsumPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_BATCHMATMULTOEINSUMPASS
#endif // GEN_PASS_DEF_BATCHMATMULTOEINSUMPASS

//===----------------------------------------------------------------------===//
// BreakUpIslandsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_BREAKUPISLANDSPASS
#undef GEN_PASS_DECL_BREAKUPISLANDSPASS
#endif // GEN_PASS_DECL_BREAKUPISLANDSPASS
#ifdef GEN_PASS_DEF_BREAKUPISLANDSPASS
namespace impl {

template <typename DerivedT>
class BreakUpIslandsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = BreakUpIslandsPassBase;

  BreakUpIslandsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  BreakUpIslandsPassBase(const BreakUpIslandsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-executor-break-up-islands");
  }
  ::llvm::StringRef getArgument() const override { return "tf-executor-break-up-islands"; }

  ::llvm::StringRef getDescription() const override { return "Transform from TF control dialect to TF executor dialect."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("BreakUpIslandsPass");
  }
  ::llvm::StringRef getName() const override { return "BreakUpIslandsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<mlir::tf_executor::TensorFlowExecutorDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(BreakUpIslandsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_BREAKUPISLANDSPASS
#endif // GEN_PASS_DEF_BREAKUPISLANDSPASS

//===----------------------------------------------------------------------===//
// BroadcastFoldPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_BROADCASTFOLDPASS
#undef GEN_PASS_DECL_BROADCASTFOLDPASS
#endif // GEN_PASS_DECL_BROADCASTFOLDPASS
#ifdef GEN_PASS_DEF_BROADCASTFOLDPASS
namespace impl {

template <typename DerivedT>
class BroadcastFoldPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = BroadcastFoldPassBase;

  BroadcastFoldPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  BroadcastFoldPassBase(const BroadcastFoldPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-broadcast-fold");
  }
  ::llvm::StringRef getArgument() const override { return "tf-broadcast-fold"; }

  ::llvm::StringRef getDescription() const override { return "Fold explicit broadcasts into the following operations if they support implicit broadcasting on their operand."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("BroadcastFoldPass");
  }
  ::llvm::StringRef getName() const override { return "BroadcastFoldPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(BroadcastFoldPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_BROADCASTFOLDPASS
#endif // GEN_PASS_DEF_BROADCASTFOLDPASS

//===----------------------------------------------------------------------===//
// CanonicalizeCompileAndReplicateAttributesPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CANONICALIZECOMPILEANDREPLICATEATTRIBUTESPASS
#undef GEN_PASS_DECL_CANONICALIZECOMPILEANDREPLICATEATTRIBUTESPASS
#endif // GEN_PASS_DECL_CANONICALIZECOMPILEANDREPLICATEATTRIBUTESPASS
#ifdef GEN_PASS_DEF_CANONICALIZECOMPILEANDREPLICATEATTRIBUTESPASS
namespace impl {

template <typename DerivedT>
class CanonicalizeCompileAndReplicateAttributesPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = CanonicalizeCompileAndReplicateAttributesPassBase;

  CanonicalizeCompileAndReplicateAttributesPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  CanonicalizeCompileAndReplicateAttributesPassBase(const CanonicalizeCompileAndReplicateAttributesPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-canonicalize-compile-and-replicate-attributes");
  }
  ::llvm::StringRef getArgument() const override { return "tf-canonicalize-compile-and-replicate-attributes"; }

  ::llvm::StringRef getDescription() const override { return "Canonicalize compilation and replication attributes."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("CanonicalizeCompileAndReplicateAttributesPass");
  }
  ::llvm::StringRef getName() const override { return "CanonicalizeCompileAndReplicateAttributesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(CanonicalizeCompileAndReplicateAttributesPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CANONICALIZECOMPILEANDREPLICATEATTRIBUTESPASS
#endif // GEN_PASS_DEF_CANONICALIZECOMPILEANDREPLICATEATTRIBUTESPASS

//===----------------------------------------------------------------------===//
// ClusterConstantSinkingPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CLUSTERCONSTANTSINKINGPASS
#undef GEN_PASS_DECL_CLUSTERCONSTANTSINKINGPASS
#endif // GEN_PASS_DECL_CLUSTERCONSTANTSINKINGPASS
#ifdef GEN_PASS_DEF_CLUSTERCONSTANTSINKINGPASS
namespace impl {

template <typename DerivedT>
class ClusterConstantSinkingPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ClusterConstantSinkingPassBase;

  ClusterConstantSinkingPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ClusterConstantSinkingPassBase(const ClusterConstantSinkingPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-device-constant-sinking");
  }
  ::llvm::StringRef getArgument() const override { return "tf-device-constant-sinking"; }

  ::llvm::StringRef getDescription() const override { return "Sinks constants implicitly captured in a tf_device.cluster region."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ClusterConstantSinkingPass");
  }
  ::llvm::StringRef getName() const override { return "ClusterConstantSinkingPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ClusterConstantSinkingPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CLUSTERCONSTANTSINKINGPASS
#endif // GEN_PASS_DEF_CLUSTERCONSTANTSINKINGPASS

//===----------------------------------------------------------------------===//
// ClusterFormationPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CLUSTERFORMATIONPASS
#undef GEN_PASS_DECL_CLUSTERFORMATIONPASS
#endif // GEN_PASS_DECL_CLUSTERFORMATIONPASS
#ifdef GEN_PASS_DEF_CLUSTERFORMATIONPASS
namespace impl {

template <typename DerivedT>
class ClusterFormationPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ClusterFormationPassBase;

  ClusterFormationPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ClusterFormationPassBase(const ClusterFormationPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-device-cluster-formation");
  }
  ::llvm::StringRef getArgument() const override { return "tf-device-cluster-formation"; }

  ::llvm::StringRef getDescription() const override { return "Form clusters from instructions assigned to same device"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ClusterFormationPass");
  }
  ::llvm::StringRef getName() const override { return "ClusterFormationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<tf_device::TensorFlowDeviceDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ClusterFormationPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CLUSTERFORMATIONPASS
#endif // GEN_PASS_DEF_CLUSTERFORMATIONPASS

//===----------------------------------------------------------------------===//
// ClusterOutliningPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CLUSTEROUTLININGPASS
#undef GEN_PASS_DECL_CLUSTEROUTLININGPASS
#endif // GEN_PASS_DECL_CLUSTEROUTLININGPASS
#ifdef GEN_PASS_DEF_CLUSTEROUTLININGPASS
namespace impl {

template <typename DerivedT>
class ClusterOutliningPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ClusterOutliningPassBase;

  ClusterOutliningPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ClusterOutliningPassBase(const ClusterOutliningPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-device-cluster-outlining");
  }
  ::llvm::StringRef getArgument() const override { return "tf-device-cluster-outlining"; }

  ::llvm::StringRef getDescription() const override { return "Outlines regions of tf_device.cluster operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ClusterOutliningPass");
  }
  ::llvm::StringRef getName() const override { return "ClusterOutliningPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ClusterOutliningPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CLUSTEROUTLININGPASS
#endif // GEN_PASS_DEF_CLUSTEROUTLININGPASS

//===----------------------------------------------------------------------===//
// ClusterTFOpsByHostPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CLUSTERTFOPSBYHOSTPASS
#undef GEN_PASS_DECL_CLUSTERTFOPSBYHOSTPASS
#endif // GEN_PASS_DECL_CLUSTERTFOPSBYHOSTPASS
#ifdef GEN_PASS_DEF_CLUSTERTFOPSBYHOSTPASS
namespace impl {

template <typename DerivedT>
class ClusterTFOpsByHostPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ClusterTFOpsByHostPassBase;

  ClusterTFOpsByHostPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ClusterTFOpsByHostPassBase(const ClusterTFOpsByHostPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("cluster-tf-ops-by-host");
  }
  ::llvm::StringRef getArgument() const override { return "cluster-tf-ops-by-host"; }

  ::llvm::StringRef getDescription() const override { return "Cluster the TensorFlow ops by host so that each function only contains ops placed on the same host"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ClusterTFOpsByHostPass");
  }
  ::llvm::StringRef getName() const override { return "ClusterTFOpsByHostPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ClusterTFOpsByHostPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CLUSTERTFOPSBYHOSTPASS
#endif // GEN_PASS_DEF_CLUSTERTFOPSBYHOSTPASS

//===----------------------------------------------------------------------===//
// ConstantOpDeviceAssignmentPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONSTANTOPDEVICEASSIGNMENTPASS
#undef GEN_PASS_DECL_CONSTANTOPDEVICEASSIGNMENTPASS
#endif // GEN_PASS_DECL_CONSTANTOPDEVICEASSIGNMENTPASS
#ifdef GEN_PASS_DEF_CONSTANTOPDEVICEASSIGNMENTPASS
namespace impl {

template <typename DerivedT>
class ConstantOpDeviceAssignmentPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ConstantOpDeviceAssignmentPassBase;

  ConstantOpDeviceAssignmentPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConstantOpDeviceAssignmentPassBase(const ConstantOpDeviceAssignmentPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("constant-op-device-assignment");
  }
  ::llvm::StringRef getArgument() const override { return "constant-op-device-assignment"; }

  ::llvm::StringRef getDescription() const override { return "Assign device for tf.Const ops"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConstantOpDeviceAssignmentPass");
  }
  ::llvm::StringRef getName() const override { return "ConstantOpDeviceAssignmentPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConstantOpDeviceAssignmentPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CONSTANTOPDEVICEASSIGNMENTPASS
#endif // GEN_PASS_DEF_CONSTANTOPDEVICEASSIGNMENTPASS

//===----------------------------------------------------------------------===//
// ConvertLaunchFuncToTFCallPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTLAUNCHFUNCTOTFCALLPASS
#undef GEN_PASS_DECL_CONVERTLAUNCHFUNCTOTFCALLPASS
#endif // GEN_PASS_DECL_CONVERTLAUNCHFUNCTOTFCALLPASS
#ifdef GEN_PASS_DEF_CONVERTLAUNCHFUNCTOTFCALLPASS
namespace impl {

template <typename DerivedT>
class ConvertLaunchFuncToTFCallPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ConvertLaunchFuncToTFCallPassBase;

  ConvertLaunchFuncToTFCallPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertLaunchFuncToTFCallPassBase(const ConvertLaunchFuncToTFCallPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-device-convert-launch-func-to-tf-call");
  }
  ::llvm::StringRef getArgument() const override { return "tf-device-convert-launch-func-to-tf-call"; }

  ::llvm::StringRef getDescription() const override { return "Rewrites tf_device::LaunchFuncOp to TF::PartitionedCallOp"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertLaunchFuncToTFCallPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertLaunchFuncToTFCallPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertLaunchFuncToTFCallPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CONVERTLAUNCHFUNCTOTFCALLPASS
#endif // GEN_PASS_DEF_CONVERTLAUNCHFUNCTOTFCALLPASS

//===----------------------------------------------------------------------===//
// ConvertReadonlyReferenceVariablesToResourceVariablesPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTREADONLYREFERENCEVARIABLESTORESOURCEVARIABLESPASS
#undef GEN_PASS_DECL_CONVERTREADONLYREFERENCEVARIABLESTORESOURCEVARIABLESPASS
#endif // GEN_PASS_DECL_CONVERTREADONLYREFERENCEVARIABLESTORESOURCEVARIABLESPASS
#ifdef GEN_PASS_DEF_CONVERTREADONLYREFERENCEVARIABLESTORESOURCEVARIABLESPASS
namespace impl {

template <typename DerivedT>
class ConvertReadonlyReferenceVariablesToResourceVariablesPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ConvertReadonlyReferenceVariablesToResourceVariablesPassBase;

  ConvertReadonlyReferenceVariablesToResourceVariablesPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertReadonlyReferenceVariablesToResourceVariablesPassBase(const ConvertReadonlyReferenceVariablesToResourceVariablesPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-readonly-references-to-resources");
  }
  ::llvm::StringRef getArgument() const override { return "tf-readonly-references-to-resources"; }

  ::llvm::StringRef getDescription() const override { return "Convert readonly reference variables to resource variables."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertReadonlyReferenceVariablesToResourceVariablesPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertReadonlyReferenceVariablesToResourceVariablesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertReadonlyReferenceVariablesToResourceVariablesPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CONVERTREADONLYREFERENCEVARIABLESTORESOURCEVARIABLESPASS
#endif // GEN_PASS_DEF_CONVERTREADONLYREFERENCEVARIABLESTORESOURCEVARIABLESPASS

//===----------------------------------------------------------------------===//
// ConvertTfControlFlowToScfPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTTFCONTROLFLOWTOSCFPASS
#undef GEN_PASS_DECL_CONVERTTFCONTROLFLOWTOSCFPASS
#endif // GEN_PASS_DECL_CONVERTTFCONTROLFLOWTOSCFPASS
#ifdef GEN_PASS_DEF_CONVERTTFCONTROLFLOWTOSCFPASS
namespace impl {

template <typename DerivedT>
class ConvertTfControlFlowToScfPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ConvertTfControlFlowToScfPassBase;

  ConvertTfControlFlowToScfPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertTfControlFlowToScfPassBase(const ConvertTfControlFlowToScfPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-tf-control-flow-to-scf");
  }
  ::llvm::StringRef getArgument() const override { return "convert-tf-control-flow-to-scf"; }

  ::llvm::StringRef getDescription() const override { return "Convert TensorFlow control flow to SCF."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertTfControlFlowToScfPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertTfControlFlowToScfPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<scf::SCFDialect>();

  registry.insert<tensor::TensorDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertTfControlFlowToScfPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CONVERTTFCONTROLFLOWTOSCFPASS
#endif // GEN_PASS_DEF_CONVERTTFCONTROLFLOWTOSCFPASS

//===----------------------------------------------------------------------===//
// ConvertToLegacyCompileAndReplicateAttributesPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTTOLEGACYCOMPILEANDREPLICATEATTRIBUTESPASS
#undef GEN_PASS_DECL_CONVERTTOLEGACYCOMPILEANDREPLICATEATTRIBUTESPASS
#endif // GEN_PASS_DECL_CONVERTTOLEGACYCOMPILEANDREPLICATEATTRIBUTESPASS
#ifdef GEN_PASS_DEF_CONVERTTOLEGACYCOMPILEANDREPLICATEATTRIBUTESPASS
namespace impl {

template <typename DerivedT>
class ConvertToLegacyCompileAndReplicateAttributesPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ConvertToLegacyCompileAndReplicateAttributesPassBase;

  ConvertToLegacyCompileAndReplicateAttributesPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertToLegacyCompileAndReplicateAttributesPassBase(const ConvertToLegacyCompileAndReplicateAttributesPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-convert-to-legacy-compile-and-replicate-attributes");
  }
  ::llvm::StringRef getArgument() const override { return "tf-convert-to-legacy-compile-and-replicate-attributes"; }

  ::llvm::StringRef getDescription() const override { return "Convert unified compilation and replication attributes back to legacy attributes."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertToLegacyCompileAndReplicateAttributesPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertToLegacyCompileAndReplicateAttributesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertToLegacyCompileAndReplicateAttributesPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CONVERTTOLEGACYCOMPILEANDREPLICATEATTRIBUTESPASS
#endif // GEN_PASS_DEF_CONVERTTOLEGACYCOMPILEANDREPLICATEATTRIBUTESPASS

//===----------------------------------------------------------------------===//
// DecomposeReduceDatasetPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_DECOMPOSEREDUCEDATASETPASS
#undef GEN_PASS_DECL_DECOMPOSEREDUCEDATASETPASS
#endif // GEN_PASS_DECL_DECOMPOSEREDUCEDATASETPASS
#ifdef GEN_PASS_DEF_DECOMPOSEREDUCEDATASETPASS
namespace impl {

template <typename DerivedT>
class DecomposeReduceDatasetPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = DecomposeReduceDatasetPassBase;

  DecomposeReduceDatasetPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  DecomposeReduceDatasetPassBase(const DecomposeReduceDatasetPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-decompose-reduce-dataset");
  }
  ::llvm::StringRef getArgument() const override { return "tf-decompose-reduce-dataset"; }

  ::llvm::StringRef getDescription() const override { return "Decomposes ReduceDataset op into dataset operations."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("DecomposeReduceDatasetPass");
  }
  ::llvm::StringRef getName() const override { return "DecomposeReduceDatasetPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(DecomposeReduceDatasetPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_DECOMPOSEREDUCEDATASETPASS
#endif // GEN_PASS_DEF_DECOMPOSEREDUCEDATASETPASS

//===----------------------------------------------------------------------===//
// DeviceIndexSelectorPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_DEVICEINDEXSELECTORPASS
#undef GEN_PASS_DECL_DEVICEINDEXSELECTORPASS
#endif // GEN_PASS_DECL_DEVICEINDEXSELECTORPASS
#ifdef GEN_PASS_DEF_DEVICEINDEXSELECTORPASS
namespace impl {

template <typename DerivedT>
class DeviceIndexSelectorPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = DeviceIndexSelectorPassBase;

  DeviceIndexSelectorPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  DeviceIndexSelectorPassBase(const DeviceIndexSelectorPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-device-index-selector");
  }
  ::llvm::StringRef getArgument() const override { return "tf-device-index-selector"; }

  ::llvm::StringRef getDescription() const override { return "Fold tf.DeviceIndex to constant."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("DeviceIndexSelectorPass");
  }
  ::llvm::StringRef getName() const override { return "DeviceIndexSelectorPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(DeviceIndexSelectorPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_DEVICEINDEXSELECTORPASS
#endif // GEN_PASS_DEF_DEVICEINDEXSELECTORPASS

//===----------------------------------------------------------------------===//
// DropWhileShapeInvariantInDeviceClusterPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_DROPWHILESHAPEINVARIANTINDEVICECLUSTERPASS
#undef GEN_PASS_DECL_DROPWHILESHAPEINVARIANTINDEVICECLUSTERPASS
#endif // GEN_PASS_DECL_DROPWHILESHAPEINVARIANTINDEVICECLUSTERPASS
#ifdef GEN_PASS_DEF_DROPWHILESHAPEINVARIANTINDEVICECLUSTERPASS
namespace impl {

template <typename DerivedT>
class DropWhileShapeInvariantInDeviceClusterPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = DropWhileShapeInvariantInDeviceClusterPassBase;

  DropWhileShapeInvariantInDeviceClusterPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  DropWhileShapeInvariantInDeviceClusterPassBase(const DropWhileShapeInvariantInDeviceClusterPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-drop-while-shape-invariant-in-device-cluster");
  }
  ::llvm::StringRef getArgument() const override { return "tf-drop-while-shape-invariant-in-device-cluster"; }

  ::llvm::StringRef getDescription() const override { return "Drop `shape_invariant` attribute from While/WhileRegion ops inside device cluster."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("DropWhileShapeInvariantInDeviceClusterPass");
  }
  ::llvm::StringRef getName() const override { return "DropWhileShapeInvariantInDeviceClusterPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(DropWhileShapeInvariantInDeviceClusterPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_DROPWHILESHAPEINVARIANTINDEVICECLUSTERPASS
#endif // GEN_PASS_DEF_DROPWHILESHAPEINVARIANTINDEVICECLUSTERPASS

//===----------------------------------------------------------------------===//
// DropWhileShapeInvariantPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_DROPWHILESHAPEINVARIANTPASS
#undef GEN_PASS_DECL_DROPWHILESHAPEINVARIANTPASS
#endif // GEN_PASS_DECL_DROPWHILESHAPEINVARIANTPASS
#ifdef GEN_PASS_DEF_DROPWHILESHAPEINVARIANTPASS
namespace impl {

template <typename DerivedT>
class DropWhileShapeInvariantPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = DropWhileShapeInvariantPassBase;

  DropWhileShapeInvariantPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  DropWhileShapeInvariantPassBase(const DropWhileShapeInvariantPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-drop-while-shape-invariant");
  }
  ::llvm::StringRef getArgument() const override { return "tf-drop-while-shape-invariant"; }

  ::llvm::StringRef getDescription() const override { return "Drop `shape_invariant` attribute from While/WhileRegion ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("DropWhileShapeInvariantPass");
  }
  ::llvm::StringRef getName() const override { return "DropWhileShapeInvariantPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(DropWhileShapeInvariantPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_DROPWHILESHAPEINVARIANTPASS
#endif // GEN_PASS_DEF_DROPWHILESHAPEINVARIANTPASS

//===----------------------------------------------------------------------===//
// ExecutorCheckControlDependenciesPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_EXECUTORCHECKCONTROLDEPENDENCIESPASS
#undef GEN_PASS_DECL_EXECUTORCHECKCONTROLDEPENDENCIESPASS
#endif // GEN_PASS_DECL_EXECUTORCHECKCONTROLDEPENDENCIESPASS
#ifdef GEN_PASS_DEF_EXECUTORCHECKCONTROLDEPENDENCIESPASS
namespace impl {

template <typename DerivedT>
class ExecutorCheckControlDependenciesPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ExecutorCheckControlDependenciesPassBase;

  ExecutorCheckControlDependenciesPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ExecutorCheckControlDependenciesPassBase(const ExecutorCheckControlDependenciesPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-executor-check-control-dependencies");
  }
  ::llvm::StringRef getArgument() const override { return "tf-executor-check-control-dependencies"; }

  ::llvm::StringRef getDescription() const override { return "Checks control dependencies"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ExecutorCheckControlDependenciesPass");
  }
  ::llvm::StringRef getName() const override { return "ExecutorCheckControlDependenciesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ExecutorCheckControlDependenciesPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_EXECUTORCHECKCONTROLDEPENDENCIESPASS
#endif // GEN_PASS_DEF_EXECUTORCHECKCONTROLDEPENDENCIESPASS

//===----------------------------------------------------------------------===//
// ExecutorConvertControlToDataOutputsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_EXECUTORCONVERTCONTROLTODATAOUTPUTSPASS
#undef GEN_PASS_DECL_EXECUTORCONVERTCONTROLTODATAOUTPUTSPASS
#endif // GEN_PASS_DECL_EXECUTORCONVERTCONTROLTODATAOUTPUTSPASS
#ifdef GEN_PASS_DEF_EXECUTORCONVERTCONTROLTODATAOUTPUTSPASS
namespace impl {

template <typename DerivedT>
class ExecutorConvertControlToDataOutputsPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ExecutorConvertControlToDataOutputsPassBase;

  ExecutorConvertControlToDataOutputsPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ExecutorConvertControlToDataOutputsPassBase(const ExecutorConvertControlToDataOutputsPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-executor-convert-control-to-data-outputs");
  }
  ::llvm::StringRef getArgument() const override { return "tf-executor-convert-control-to-data-outputs"; }

  ::llvm::StringRef getDescription() const override { return "Chain control outputs of while loop body"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ExecutorConvertControlToDataOutputsPass");
  }
  ::llvm::StringRef getName() const override { return "ExecutorConvertControlToDataOutputsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ExecutorConvertControlToDataOutputsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_EXECUTORCONVERTCONTROLTODATAOUTPUTSPASS
#endif // GEN_PASS_DEF_EXECUTORCONVERTCONTROLTODATAOUTPUTSPASS

//===----------------------------------------------------------------------===//
// ExecutorDialectToFunctionalPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_EXECUTORDIALECTTOFUNCTIONALPASS
#undef GEN_PASS_DECL_EXECUTORDIALECTTOFUNCTIONALPASS
#endif // GEN_PASS_DECL_EXECUTORDIALECTTOFUNCTIONALPASS
#ifdef GEN_PASS_DEF_EXECUTORDIALECTTOFUNCTIONALPASS
namespace impl {

template <typename DerivedT>
class ExecutorDialectToFunctionalPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ExecutorDialectToFunctionalPassBase;

  ExecutorDialectToFunctionalPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ExecutorDialectToFunctionalPassBase(const ExecutorDialectToFunctionalPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-executor-to-functional-conversion");
  }
  ::llvm::StringRef getArgument() const override { return "tf-executor-to-functional-conversion"; }

  ::llvm::StringRef getDescription() const override { return "Lifts tf_executor.island inner ops from a tf_executor.graph"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ExecutorDialectToFunctionalPass");
  }
  ::llvm::StringRef getName() const override { return "ExecutorDialectToFunctionalPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ExecutorDialectToFunctionalPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_EXECUTORDIALECTTOFUNCTIONALPASS
#endif // GEN_PASS_DEF_EXECUTORDIALECTTOFUNCTIONALPASS

//===----------------------------------------------------------------------===//
// ExecutorGraphPruningPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_EXECUTORGRAPHPRUNINGPASS
struct ExecutorGraphPruningPassOptions {
  ::llvm::ArrayRef<std::string> ops_to_preserve_;
};
#undef GEN_PASS_DECL_EXECUTORGRAPHPRUNINGPASS
#endif // GEN_PASS_DECL_EXECUTORGRAPHPRUNINGPASS
#ifdef GEN_PASS_DEF_EXECUTORGRAPHPRUNINGPASS
namespace impl {

template <typename DerivedT>
class ExecutorGraphPruningPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ExecutorGraphPruningPassBase;

  ExecutorGraphPruningPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ExecutorGraphPruningPassBase(const ExecutorGraphPruningPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-executor-graph-pruning");
  }
  ::llvm::StringRef getArgument() const override { return "tf-executor-graph-pruning"; }

  ::llvm::StringRef getDescription() const override { return "Prunes unreachable ops in a tf_executor.graph"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ExecutorGraphPruningPass");
  }
  ::llvm::StringRef getName() const override { return "ExecutorGraphPruningPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ExecutorGraphPruningPassBase<DerivedT>)

  ExecutorGraphPruningPassBase(const ExecutorGraphPruningPassOptions &options) : ExecutorGraphPruningPassBase() {
    ops_to_preserve_ = options.ops_to_preserve_;
  }
protected:
  ::mlir::Pass::ListOption<std::string> ops_to_preserve_{*this, "ops-to-preserve", ::llvm::cl::desc("Comma separated list of ops that should not be pruned regardless of reachability")};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_EXECUTORGRAPHPRUNINGPASS
#endif // GEN_PASS_DEF_EXECUTORGRAPHPRUNINGPASS

//===----------------------------------------------------------------------===//
// ExecutorIslandCoarseningPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_EXECUTORISLANDCOARSENINGPASS
#undef GEN_PASS_DECL_EXECUTORISLANDCOARSENINGPASS
#endif // GEN_PASS_DECL_EXECUTORISLANDCOARSENINGPASS
#ifdef GEN_PASS_DEF_EXECUTORISLANDCOARSENINGPASS
namespace impl {

template <typename DerivedT>
class ExecutorIslandCoarseningPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ExecutorIslandCoarseningPassBase;

  ExecutorIslandCoarseningPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ExecutorIslandCoarseningPassBase(const ExecutorIslandCoarseningPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-executor-island-coarsening");
  }
  ::llvm::StringRef getArgument() const override { return "tf-executor-island-coarsening"; }

  ::llvm::StringRef getDescription() const override { return "Walks tf_executor::GraphOp and merges individual tf_executor::IslandOps."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ExecutorIslandCoarseningPass");
  }
  ::llvm::StringRef getName() const override { return "ExecutorIslandCoarseningPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ExecutorIslandCoarseningPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_EXECUTORISLANDCOARSENINGPASS
#endif // GEN_PASS_DEF_EXECUTORISLANDCOARSENINGPASS

//===----------------------------------------------------------------------===//
// ExecutorTPUV1IslandInliningPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_EXECUTORTPUV1ISLANDINLININGPASS
#undef GEN_PASS_DECL_EXECUTORTPUV1ISLANDINLININGPASS
#endif // GEN_PASS_DECL_EXECUTORTPUV1ISLANDINLININGPASS
#ifdef GEN_PASS_DEF_EXECUTORTPUV1ISLANDINLININGPASS
namespace impl {

template <typename DerivedT>
class ExecutorTPUV1IslandInliningPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ExecutorTPUV1IslandInliningPassBase;

  ExecutorTPUV1IslandInliningPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ExecutorTPUV1IslandInliningPassBase(const ExecutorTPUV1IslandInliningPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-executor-tpu-v1-island-inlining");
  }
  ::llvm::StringRef getArgument() const override { return "tf-executor-tpu-v1-island-inlining"; }

  ::llvm::StringRef getDescription() const override { return "Inline calls to the nested TPU module."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ExecutorTPUV1IslandInliningPass");
  }
  ::llvm::StringRef getName() const override { return "ExecutorTPUV1IslandInliningPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ExecutorTPUV1IslandInliningPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_EXECUTORTPUV1ISLANDINLININGPASS
#endif // GEN_PASS_DEF_EXECUTORTPUV1ISLANDINLININGPASS

//===----------------------------------------------------------------------===//
// ExecutorUpdateControlDependenciesPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_EXECUTORUPDATECONTROLDEPENDENCIESPASS
#undef GEN_PASS_DECL_EXECUTORUPDATECONTROLDEPENDENCIESPASS
#endif // GEN_PASS_DECL_EXECUTORUPDATECONTROLDEPENDENCIESPASS
#ifdef GEN_PASS_DEF_EXECUTORUPDATECONTROLDEPENDENCIESPASS
namespace impl {

template <typename DerivedT>
class ExecutorUpdateControlDependenciesPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ExecutorUpdateControlDependenciesPassBase;

  ExecutorUpdateControlDependenciesPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ExecutorUpdateControlDependenciesPassBase(const ExecutorUpdateControlDependenciesPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-executor-update-control-dependencies");
  }
  ::llvm::StringRef getArgument() const override { return "tf-executor-update-control-dependencies"; }

  ::llvm::StringRef getDescription() const override { return "Computes and applies all necessary control dependencies based on side effect analysis."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ExecutorUpdateControlDependenciesPass");
  }
  ::llvm::StringRef getName() const override { return "ExecutorUpdateControlDependenciesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ExecutorUpdateControlDependenciesPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_EXECUTORUPDATECONTROLDEPENDENCIESPASS
#endif // GEN_PASS_DEF_EXECUTORUPDATECONTROLDEPENDENCIESPASS

//===----------------------------------------------------------------------===//
// FunctionalControlFlowToCFGPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_FUNCTIONALCONTROLFLOWTOCFGPASS
#undef GEN_PASS_DECL_FUNCTIONALCONTROLFLOWTOCFGPASS
#endif // GEN_PASS_DECL_FUNCTIONALCONTROLFLOWTOCFGPASS
#ifdef GEN_PASS_DEF_FUNCTIONALCONTROLFLOWTOCFGPASS
namespace impl {

template <typename DerivedT>
class FunctionalControlFlowToCFGPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = FunctionalControlFlowToCFGPassBase;

  FunctionalControlFlowToCFGPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  FunctionalControlFlowToCFGPassBase(const FunctionalControlFlowToCFGPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-functional-control-flow-to-cfg");
  }
  ::llvm::StringRef getArgument() const override { return "tf-functional-control-flow-to-cfg"; }

  ::llvm::StringRef getDescription() const override { return "Transform functional control flow Ops to MLIR Control Form Graph (CFG) form"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("FunctionalControlFlowToCFGPass");
  }
  ::llvm::StringRef getName() const override { return "FunctionalControlFlowToCFGPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<tensor::TensorDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(FunctionalControlFlowToCFGPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_FUNCTIONALCONTROLFLOWTOCFGPASS
#endif // GEN_PASS_DEF_FUNCTIONALCONTROLFLOWTOCFGPASS

//===----------------------------------------------------------------------===//
// FunctionalControlFlowToRegionsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_FUNCTIONALCONTROLFLOWTOREGIONSPASS
#undef GEN_PASS_DECL_FUNCTIONALCONTROLFLOWTOREGIONSPASS
#endif // GEN_PASS_DECL_FUNCTIONALCONTROLFLOWTOREGIONSPASS
#ifdef GEN_PASS_DEF_FUNCTIONALCONTROLFLOWTOREGIONSPASS
namespace impl {

template <typename DerivedT>
class FunctionalControlFlowToRegionsPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = FunctionalControlFlowToRegionsPassBase;

  FunctionalControlFlowToRegionsPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  FunctionalControlFlowToRegionsPassBase(const FunctionalControlFlowToRegionsPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-functional-control-flow-to-regions");
  }
  ::llvm::StringRef getArgument() const override { return "tf-functional-control-flow-to-regions"; }

  ::llvm::StringRef getDescription() const override { return "Transforms functional control flow operations to their region-based counterparts"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("FunctionalControlFlowToRegionsPass");
  }
  ::llvm::StringRef getName() const override { return "FunctionalControlFlowToRegionsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(FunctionalControlFlowToRegionsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_FUNCTIONALCONTROLFLOWTOREGIONSPASS
#endif // GEN_PASS_DEF_FUNCTIONALCONTROLFLOWTOREGIONSPASS

//===----------------------------------------------------------------------===//
// FunctionalToExecutorDialectConversionPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_FUNCTIONALTOEXECUTORDIALECTCONVERSIONPASS
#undef GEN_PASS_DECL_FUNCTIONALTOEXECUTORDIALECTCONVERSIONPASS
#endif // GEN_PASS_DECL_FUNCTIONALTOEXECUTORDIALECTCONVERSIONPASS
#ifdef GEN_PASS_DEF_FUNCTIONALTOEXECUTORDIALECTCONVERSIONPASS
namespace impl {

template <typename DerivedT>
class FunctionalToExecutorDialectConversionPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = FunctionalToExecutorDialectConversionPassBase;

  FunctionalToExecutorDialectConversionPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  FunctionalToExecutorDialectConversionPassBase(const FunctionalToExecutorDialectConversionPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-functional-to-executor-conversion");
  }
  ::llvm::StringRef getArgument() const override { return "tf-functional-to-executor-conversion"; }

  ::llvm::StringRef getDescription() const override { return "Transform from func op to TF executor dialect."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("FunctionalToExecutorDialectConversionPass");
  }
  ::llvm::StringRef getName() const override { return "FunctionalToExecutorDialectConversionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<mlir::tf_executor::TensorFlowExecutorDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(FunctionalToExecutorDialectConversionPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_FUNCTIONALTOEXECUTORDIALECTCONVERSIONPASS
#endif // GEN_PASS_DEF_FUNCTIONALTOEXECUTORDIALECTCONVERSIONPASS

//===----------------------------------------------------------------------===//
// FusedKernelMatcherPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_FUSEDKERNELMATCHERPASS
#undef GEN_PASS_DECL_FUSEDKERNELMATCHERPASS
#endif // GEN_PASS_DECL_FUSEDKERNELMATCHERPASS
#ifdef GEN_PASS_DEF_FUSEDKERNELMATCHERPASS
namespace impl {

template <typename DerivedT>
class FusedKernelMatcherPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = FusedKernelMatcherPassBase;

  FusedKernelMatcherPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  FusedKernelMatcherPassBase(const FusedKernelMatcherPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-fused-kernel-matcher");
  }
  ::llvm::StringRef getArgument() const override { return "tf-fused-kernel-matcher"; }

  ::llvm::StringRef getDescription() const override { return "Matches computations corresponding to optimized fused kernels"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("FusedKernelMatcherPass");
  }
  ::llvm::StringRef getName() const override { return "FusedKernelMatcherPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(FusedKernelMatcherPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_FUSEDKERNELMATCHERPASS
#endif // GEN_PASS_DEF_FUSEDKERNELMATCHERPASS

//===----------------------------------------------------------------------===//
// GroupByDialectPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_GROUPBYDIALECTPASS
#undef GEN_PASS_DECL_GROUPBYDIALECTPASS
#endif // GEN_PASS_DECL_GROUPBYDIALECTPASS
#ifdef GEN_PASS_DEF_GROUPBYDIALECTPASS
namespace impl {

template <typename DerivedT>
class GroupByDialectPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = GroupByDialectPassBase;

  GroupByDialectPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  GroupByDialectPassBase(const GroupByDialectPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-group-by-dialect");
  }
  ::llvm::StringRef getArgument() const override { return "tf-group-by-dialect"; }

  ::llvm::StringRef getDescription() const override { return "Groups ops into functions that only contain one dialect."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("GroupByDialectPass");
  }
  ::llvm::StringRef getName() const override { return "GroupByDialectPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(GroupByDialectPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_GROUPBYDIALECTPASS
#endif // GEN_PASS_DEF_GROUPBYDIALECTPASS

//===----------------------------------------------------------------------===//
// GuaranteeAllFuncsOneUsePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_GUARANTEEALLFUNCSONEUSEPASS
#undef GEN_PASS_DECL_GUARANTEEALLFUNCSONEUSEPASS
#endif // GEN_PASS_DECL_GUARANTEEALLFUNCSONEUSEPASS
#ifdef GEN_PASS_DEF_GUARANTEEALLFUNCSONEUSEPASS
namespace impl {

template <typename DerivedT>
class GuaranteeAllFuncsOneUsePassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = GuaranteeAllFuncsOneUsePassBase;

  GuaranteeAllFuncsOneUsePassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  GuaranteeAllFuncsOneUsePassBase(const GuaranteeAllFuncsOneUsePassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-guarantee-all-funcs-one-use");
  }
  ::llvm::StringRef getArgument() const override { return "tf-guarantee-all-funcs-one-use"; }

  ::llvm::StringRef getDescription() const override { return "Guarantee all FuncOp's have only a single use."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("GuaranteeAllFuncsOneUsePass");
  }
  ::llvm::StringRef getName() const override { return "GuaranteeAllFuncsOneUsePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(GuaranteeAllFuncsOneUsePassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_GUARANTEEALLFUNCSONEUSEPASS
#endif // GEN_PASS_DEF_GUARANTEEALLFUNCSONEUSEPASS

//===----------------------------------------------------------------------===//
// HoistReplicateInvariantResourceWritesPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_HOISTREPLICATEINVARIANTRESOURCEWRITESPASS
#undef GEN_PASS_DECL_HOISTREPLICATEINVARIANTRESOURCEWRITESPASS
#endif // GEN_PASS_DECL_HOISTREPLICATEINVARIANTRESOURCEWRITESPASS
#ifdef GEN_PASS_DEF_HOISTREPLICATEINVARIANTRESOURCEWRITESPASS
namespace impl {

template <typename DerivedT>
class HoistReplicateInvariantResourceWritesPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = HoistReplicateInvariantResourceWritesPassBase;

  HoistReplicateInvariantResourceWritesPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  HoistReplicateInvariantResourceWritesPassBase(const HoistReplicateInvariantResourceWritesPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-hoist-replicate-invariant-resource-writes");
  }
  ::llvm::StringRef getArgument() const override { return "tf-hoist-replicate-invariant-resource-writes"; }

  ::llvm::StringRef getDescription() const override { return "Hoists writes to replicate invariant resource variables."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("HoistReplicateInvariantResourceWritesPass");
  }
  ::llvm::StringRef getName() const override { return "HoistReplicateInvariantResourceWritesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(HoistReplicateInvariantResourceWritesPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_HOISTREPLICATEINVARIANTRESOURCEWRITESPASS
#endif // GEN_PASS_DEF_HOISTREPLICATEINVARIANTRESOURCEWRITESPASS

//===----------------------------------------------------------------------===//
// InitTextFileToImportPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_INITTEXTFILETOIMPORTPASS
struct InitTextFileToImportPassOptions {
  std::string saved_model_dir_;
};
#undef GEN_PASS_DECL_INITTEXTFILETOIMPORTPASS
#endif // GEN_PASS_DECL_INITTEXTFILETOIMPORTPASS
#ifdef GEN_PASS_DEF_INITTEXTFILETOIMPORTPASS
namespace impl {

template <typename DerivedT>
class InitTextFileToImportPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = InitTextFileToImportPassBase;

  InitTextFileToImportPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  InitTextFileToImportPassBase(const InitTextFileToImportPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-init-text-file-to-import");
  }
  ::llvm::StringRef getArgument() const override { return "tf-init-text-file-to-import"; }

  ::llvm::StringRef getDescription() const override { return "convert InitializeTableFromTextFileV2 ops to LookupTableImportV2Op to remove the dependency on asset files"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("InitTextFileToImportPass");
  }
  ::llvm::StringRef getName() const override { return "InitTextFileToImportPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(InitTextFileToImportPassBase<DerivedT>)

  InitTextFileToImportPassBase(const InitTextFileToImportPassOptions &options) : InitTextFileToImportPassBase() {
    saved_model_dir_ = options.saved_model_dir_;
  }
protected:
  ::mlir::Pass::Option<std::string> saved_model_dir_{*this, "tf-saved-model-dir", ::llvm::cl::desc("Directory containing the model exported as a TensorFlow SavedModel. If your model is not based on the TensorFlow SavedModel, use an empty value.")};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_INITTEXTFILETOIMPORTPASS
#endif // GEN_PASS_DEF_INITTEXTFILETOIMPORTPASS

//===----------------------------------------------------------------------===//
// LaunchOutliningPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LAUNCHOUTLININGPASS
#undef GEN_PASS_DECL_LAUNCHOUTLININGPASS
#endif // GEN_PASS_DECL_LAUNCHOUTLININGPASS
#ifdef GEN_PASS_DEF_LAUNCHOUTLININGPASS
namespace impl {

template <typename DerivedT>
class LaunchOutliningPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = LaunchOutliningPassBase;

  LaunchOutliningPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  LaunchOutliningPassBase(const LaunchOutliningPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-device-launch-outlining");
  }
  ::llvm::StringRef getArgument() const override { return "tf-device-launch-outlining"; }

  ::llvm::StringRef getDescription() const override { return "Outlines regions of tf_device.launch operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LaunchOutliningPass");
  }
  ::llvm::StringRef getName() const override { return "LaunchOutliningPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LaunchOutliningPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LAUNCHOUTLININGPASS
#endif // GEN_PASS_DEF_LAUNCHOUTLININGPASS

//===----------------------------------------------------------------------===//
// LayoutAssignmentPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LAYOUTASSIGNMENTPASS
struct LayoutAssignmentPassOptions {
  std::string force_data_format_;
};
#undef GEN_PASS_DECL_LAYOUTASSIGNMENTPASS
#endif // GEN_PASS_DECL_LAYOUTASSIGNMENTPASS
#ifdef GEN_PASS_DEF_LAYOUTASSIGNMENTPASS
namespace impl {

template <typename DerivedT>
class LayoutAssignmentPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = LayoutAssignmentPassBase;

  LayoutAssignmentPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LayoutAssignmentPassBase(const LayoutAssignmentPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-layout-assignment");
  }
  ::llvm::StringRef getArgument() const override { return "tf-layout-assignment"; }

  ::llvm::StringRef getDescription() const override { return "Layout assignment pass."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LayoutAssignmentPass");
  }
  ::llvm::StringRef getName() const override { return "LayoutAssignmentPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LayoutAssignmentPassBase<DerivedT>)

  LayoutAssignmentPassBase(const LayoutAssignmentPassOptions &options) : LayoutAssignmentPassBase() {
    force_data_format_ = options.force_data_format_;
  }
protected:
  ::mlir::Pass::Option<std::string> force_data_format_{*this, "force-data-format", ::llvm::cl::desc("Force data format for all layout sensitive ops.")};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LAYOUTASSIGNMENTPASS
#endif // GEN_PASS_DEF_LAYOUTASSIGNMENTPASS

//===----------------------------------------------------------------------===//
// LegalizeHloToTfPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LEGALIZEHLOTOTFPASS
#undef GEN_PASS_DECL_LEGALIZEHLOTOTFPASS
#endif // GEN_PASS_DECL_LEGALIZEHLOTOTFPASS
#ifdef GEN_PASS_DEF_LEGALIZEHLOTOTFPASS
namespace impl {

template <typename DerivedT>
class LegalizeHloToTfPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = LegalizeHloToTfPassBase;

  LegalizeHloToTfPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LegalizeHloToTfPassBase(const LegalizeHloToTfPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-legalize-hlo");
  }
  ::llvm::StringRef getArgument() const override { return "tf-legalize-hlo"; }

  ::llvm::StringRef getDescription() const override { return "Legalize from HLO to the TF dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LegalizeHloToTfPass");
  }
  ::llvm::StringRef getName() const override { return "LegalizeHloToTfPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<TF::TensorFlowDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LegalizeHloToTfPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LEGALIZEHLOTOTFPASS
#endif // GEN_PASS_DEF_LEGALIZEHLOTOTFPASS

//===----------------------------------------------------------------------===//
// LegalizeTFGToTFPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LEGALIZETFGTOTFPASS
#undef GEN_PASS_DECL_LEGALIZETFGTOTFPASS
#endif // GEN_PASS_DECL_LEGALIZETFGTOTFPASS
#ifdef GEN_PASS_DEF_LEGALIZETFGTOTFPASS
namespace impl {

template <typename DerivedT>
class LegalizeTFGToTFPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = LegalizeTFGToTFPassBase;

  LegalizeTFGToTFPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  LegalizeTFGToTFPassBase(const LegalizeTFGToTFPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tfe-legalize-tfg");
  }
  ::llvm::StringRef getArgument() const override { return "tfe-legalize-tfg"; }

  ::llvm::StringRef getDescription() const override { return "Legalize from TFG to the TFE dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LegalizeTFGToTFPass");
  }
  ::llvm::StringRef getName() const override { return "LegalizeTFGToTFPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LegalizeTFGToTFPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LEGALIZETFGTOTFPASS
#endif // GEN_PASS_DEF_LEGALIZETFGTOTFPASS

//===----------------------------------------------------------------------===//
// LocalizeVarHandlesPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LOCALIZEVARHANDLESPASS
#undef GEN_PASS_DECL_LOCALIZEVARHANDLESPASS
#endif // GEN_PASS_DECL_LOCALIZEVARHANDLESPASS
#ifdef GEN_PASS_DEF_LOCALIZEVARHANDLESPASS
namespace impl {

template <typename DerivedT>
class LocalizeVarHandlesPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = LocalizeVarHandlesPassBase;

  LocalizeVarHandlesPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  LocalizeVarHandlesPassBase(const LocalizeVarHandlesPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-localize-var-handles");
  }
  ::llvm::StringRef getArgument() const override { return "tf-localize-var-handles"; }

  ::llvm::StringRef getDescription() const override { return "Creates VarHandleOps next to the operations that use them."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LocalizeVarHandlesPass");
  }
  ::llvm::StringRef getName() const override { return "LocalizeVarHandlesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LocalizeVarHandlesPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LOCALIZEVARHANDLESPASS
#endif // GEN_PASS_DEF_LOCALIZEVARHANDLESPASS

//===----------------------------------------------------------------------===//
// LowerQuantizedPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LOWERQUANTIZEDPASS
#undef GEN_PASS_DECL_LOWERQUANTIZEDPASS
#endif // GEN_PASS_DECL_LOWERQUANTIZEDPASS
#ifdef GEN_PASS_DEF_LOWERQUANTIZEDPASS
namespace impl {

template <typename DerivedT>
class LowerQuantizedPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = LowerQuantizedPassBase;

  LowerQuantizedPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LowerQuantizedPassBase(const LowerQuantizedPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-lower-quantized");
  }
  ::llvm::StringRef getArgument() const override { return "tf-lower-quantized"; }

  ::llvm::StringRef getDescription() const override { return "Lowers ops that require quantized input or output."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LowerQuantizedPass");
  }
  ::llvm::StringRef getName() const override { return "LowerQuantizedPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LowerQuantizedPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LOWERQUANTIZEDPASS
#endif // GEN_PASS_DEF_LOWERQUANTIZEDPASS

//===----------------------------------------------------------------------===//
// MarkInputOutputAliasesPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_MARKINPUTOUTPUTALIASESPASS
#undef GEN_PASS_DECL_MARKINPUTOUTPUTALIASESPASS
#endif // GEN_PASS_DECL_MARKINPUTOUTPUTALIASESPASS
#ifdef GEN_PASS_DEF_MARKINPUTOUTPUTALIASESPASS
namespace impl {

template <typename DerivedT>
class MarkInputOutputAliasesPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = MarkInputOutputAliasesPassBase;

  MarkInputOutputAliasesPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  MarkInputOutputAliasesPassBase(const MarkInputOutputAliasesPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-device-mark-input-output-aliases");
  }
  ::llvm::StringRef getArgument() const override { return "tf-device-mark-input-output-aliases"; }

  ::llvm::StringRef getDescription() const override { return "Marks device cluster inputs-output pairs that read/write to the same variable as aliases"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("MarkInputOutputAliasesPass");
  }
  ::llvm::StringRef getName() const override { return "MarkInputOutputAliasesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MarkInputOutputAliasesPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_MARKINPUTOUTPUTALIASESPASS
#endif // GEN_PASS_DEF_MARKINPUTOUTPUTALIASESPASS

//===----------------------------------------------------------------------===//
// MarkOpsForOutsideCompilationPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_MARKOPSFOROUTSIDECOMPILATIONPASS
#undef GEN_PASS_DECL_MARKOPSFOROUTSIDECOMPILATIONPASS
#endif // GEN_PASS_DECL_MARKOPSFOROUTSIDECOMPILATIONPASS
#ifdef GEN_PASS_DEF_MARKOPSFOROUTSIDECOMPILATIONPASS
namespace impl {

template <typename DerivedT>
class MarkOpsForOutsideCompilationPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = MarkOpsForOutsideCompilationPassBase;

  MarkOpsForOutsideCompilationPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  MarkOpsForOutsideCompilationPassBase(const MarkOpsForOutsideCompilationPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-mark-ops-for-outside-compilation");
  }
  ::llvm::StringRef getArgument() const override { return "tf-mark-ops-for-outside-compilation"; }

  ::llvm::StringRef getDescription() const override { return "Marks ops in device cluster for outside compilation if they are unsupported on device."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("MarkOpsForOutsideCompilationPass");
  }
  ::llvm::StringRef getName() const override { return "MarkOpsForOutsideCompilationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MarkOpsForOutsideCompilationPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_MARKOPSFOROUTSIDECOMPILATIONPASS
#endif // GEN_PASS_DEF_MARKOPSFOROUTSIDECOMPILATIONPASS

//===----------------------------------------------------------------------===//
// MaterializePassthroughOp
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_MATERIALIZEPASSTHROUGHOP
#undef GEN_PASS_DECL_MATERIALIZEPASSTHROUGHOP
#endif // GEN_PASS_DECL_MATERIALIZEPASSTHROUGHOP
#ifdef GEN_PASS_DEF_MATERIALIZEPASSTHROUGHOP
namespace impl {

template <typename DerivedT>
class MaterializePassthroughOpBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = MaterializePassthroughOpBase;

  MaterializePassthroughOpBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  MaterializePassthroughOpBase(const MaterializePassthroughOpBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-materialize-passthrough-op");
  }
  ::llvm::StringRef getArgument() const override { return "tf-materialize-passthrough-op"; }

  ::llvm::StringRef getDescription() const override { return "Materialize the MlirPassthroughOp by replacing it with the MLIR module attached as an attribute"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("MaterializePassthroughOp");
  }
  ::llvm::StringRef getName() const override { return "MaterializePassthroughOp"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MaterializePassthroughOpBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_MATERIALIZEPASSTHROUGHOP
#endif // GEN_PASS_DEF_MATERIALIZEPASSTHROUGHOP

//===----------------------------------------------------------------------===//
// MergeControlFlowPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_MERGECONTROLFLOWPASS
#undef GEN_PASS_DECL_MERGECONTROLFLOWPASS
#endif // GEN_PASS_DECL_MERGECONTROLFLOWPASS
#ifdef GEN_PASS_DEF_MERGECONTROLFLOWPASS
namespace impl {

template <typename DerivedT>
class MergeControlFlowPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = MergeControlFlowPassBase;

  MergeControlFlowPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  MergeControlFlowPassBase(const MergeControlFlowPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-merge-control-flow");
  }
  ::llvm::StringRef getArgument() const override { return "tf-merge-control-flow"; }

  ::llvm::StringRef getDescription() const override { return "Merges IfRegion ops together with a common predicate."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("MergeControlFlowPass");
  }
  ::llvm::StringRef getName() const override { return "MergeControlFlowPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MergeControlFlowPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_MERGECONTROLFLOWPASS
#endif // GEN_PASS_DEF_MERGECONTROLFLOWPASS

//===----------------------------------------------------------------------===//
// MoveTransposesPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_MOVETRANSPOSESPASS
struct MoveTransposesPassOptions {
  bool fold_transpose_in_ops_ = true;
  enum MoveTransposeDirection direction_ = MoveTransposeDirection::kBegin;
};
#undef GEN_PASS_DECL_MOVETRANSPOSESPASS
#endif // GEN_PASS_DECL_MOVETRANSPOSESPASS
#ifdef GEN_PASS_DEF_MOVETRANSPOSESPASS
namespace impl {

template <typename DerivedT>
class MoveTransposesPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = MoveTransposesPassBase;

  MoveTransposesPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  MoveTransposesPassBase(const MoveTransposesPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-move-transposes");
  }
  ::llvm::StringRef getArgument() const override { return "tf-move-transposes"; }

  ::llvm::StringRef getDescription() const override { return "Move transposes pass."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("MoveTransposesPass");
  }
  ::llvm::StringRef getName() const override { return "MoveTransposesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MoveTransposesPassBase<DerivedT>)

  MoveTransposesPassBase(const MoveTransposesPassOptions &options) : MoveTransposesPassBase() {
    fold_transpose_in_ops_ = options.fold_transpose_in_ops_;
    direction_ = options.direction_;
  }
protected:
  ::mlir::Pass::Option<bool> fold_transpose_in_ops_{*this, "fold-transpose-in-ops", ::llvm::cl::desc("Whether to fold transposes in ops which can support folding."), ::llvm::cl::init(true)};
  ::mlir::Pass::Option<enum MoveTransposeDirection> direction_{*this, "direction", ::llvm::cl::desc("Move transposes to the beginning or the end of the block where they are defined."), ::llvm::cl::init(MoveTransposeDirection::kBegin), llvm::cl::values(clEnumValN(MoveTransposeDirection::kBegin, "begin", "beginning of the block"),clEnumValN(MoveTransposeDirection::kEnd, "end", "end of the block"))};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_MOVETRANSPOSESPASS
#endif // GEN_PASS_DEF_MOVETRANSPOSESPASS

//===----------------------------------------------------------------------===//
// NameAnonymousIteratorsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_NAMEANONYMOUSITERATORSPASS
#undef GEN_PASS_DECL_NAMEANONYMOUSITERATORSPASS
#endif // GEN_PASS_DECL_NAMEANONYMOUSITERATORSPASS
#ifdef GEN_PASS_DEF_NAMEANONYMOUSITERATORSPASS
namespace impl {

template <typename DerivedT>
class NameAnonymousIteratorsPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = NameAnonymousIteratorsPassBase;

  NameAnonymousIteratorsPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  NameAnonymousIteratorsPassBase(const NameAnonymousIteratorsPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-name-anonymous-iterators");
  }
  ::llvm::StringRef getArgument() const override { return "tf-name-anonymous-iterators"; }

  ::llvm::StringRef getDescription() const override { return "Converts anonymous iterators to named iterators"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("NameAnonymousIteratorsPass");
  }
  ::llvm::StringRef getName() const override { return "NameAnonymousIteratorsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(NameAnonymousIteratorsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_NAMEANONYMOUSITERATORSPASS
#endif // GEN_PASS_DEF_NAMEANONYMOUSITERATORSPASS

//===----------------------------------------------------------------------===//
// OrderByDialectPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_ORDERBYDIALECTPASS
#undef GEN_PASS_DECL_ORDERBYDIALECTPASS
#endif // GEN_PASS_DECL_ORDERBYDIALECTPASS
#ifdef GEN_PASS_DEF_ORDERBYDIALECTPASS
namespace impl {

template <typename DerivedT>
class OrderByDialectPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = OrderByDialectPassBase;

  OrderByDialectPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  OrderByDialectPassBase(const OrderByDialectPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-order-by-dialect");
  }
  ::llvm::StringRef getArgument() const override { return "tf-order-by-dialect"; }

  ::llvm::StringRef getDescription() const override { return "Reorders ops so ops of the same dialect are next to each other."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("OrderByDialectPass");
  }
  ::llvm::StringRef getName() const override { return "OrderByDialectPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(OrderByDialectPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_ORDERBYDIALECTPASS
#endif // GEN_PASS_DEF_ORDERBYDIALECTPASS

//===----------------------------------------------------------------------===//
// OutsideCompiledToHostLaunchPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_OUTSIDECOMPILEDTOHOSTLAUNCHPASS
#undef GEN_PASS_DECL_OUTSIDECOMPILEDTOHOSTLAUNCHPASS
#endif // GEN_PASS_DECL_OUTSIDECOMPILEDTOHOSTLAUNCHPASS
#ifdef GEN_PASS_DEF_OUTSIDECOMPILEDTOHOSTLAUNCHPASS
namespace impl {

template <typename DerivedT>
class OutsideCompiledToHostLaunchPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = OutsideCompiledToHostLaunchPassBase;

  OutsideCompiledToHostLaunchPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  OutsideCompiledToHostLaunchPassBase(const OutsideCompiledToHostLaunchPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-outside-compiled-to-host-launch");
  }
  ::llvm::StringRef getArgument() const override { return "tf-outside-compiled-to-host-launch"; }

  ::llvm::StringRef getDescription() const override { return "Wraps each op with the _xla_outside_compiled attribute in a separate tf_device.launch on replicated host device."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("OutsideCompiledToHostLaunchPass");
  }
  ::llvm::StringRef getName() const override { return "OutsideCompiledToHostLaunchPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(OutsideCompiledToHostLaunchPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_OUTSIDECOMPILEDTOHOSTLAUNCHPASS
#endif // GEN_PASS_DEF_OUTSIDECOMPILEDTOHOSTLAUNCHPASS

//===----------------------------------------------------------------------===//
// ParallelExecuteToIslandsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_PARALLELEXECUTETOISLANDSPASS
#undef GEN_PASS_DECL_PARALLELEXECUTETOISLANDSPASS
#endif // GEN_PASS_DECL_PARALLELEXECUTETOISLANDSPASS
#ifdef GEN_PASS_DEF_PARALLELEXECUTETOISLANDSPASS
namespace impl {

template <typename DerivedT>
class ParallelExecuteToIslandsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ParallelExecuteToIslandsPassBase;

  ParallelExecuteToIslandsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ParallelExecuteToIslandsPassBase(const ParallelExecuteToIslandsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-parallel-execute-to-islands");
  }
  ::llvm::StringRef getArgument() const override { return "tf-parallel-execute-to-islands"; }

  ::llvm::StringRef getDescription() const override { return "Lowers device parallel_execute to executor islands"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ParallelExecuteToIslandsPass");
  }
  ::llvm::StringRef getName() const override { return "ParallelExecuteToIslandsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ParallelExecuteToIslandsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_PARALLELEXECUTETOISLANDSPASS
#endif // GEN_PASS_DEF_PARALLELEXECUTETOISLANDSPASS

//===----------------------------------------------------------------------===//
// PrepareTpuComputationForTfExportPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_PREPARETPUCOMPUTATIONFORTFEXPORTPASS
#undef GEN_PASS_DECL_PREPARETPUCOMPUTATIONFORTFEXPORTPASS
#endif // GEN_PASS_DECL_PREPARETPUCOMPUTATIONFORTFEXPORTPASS
#ifdef GEN_PASS_DEF_PREPARETPUCOMPUTATIONFORTFEXPORTPASS
namespace impl {

template <typename DerivedT>
class PrepareTpuComputationForTfExportPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = PrepareTpuComputationForTfExportPassBase;

  PrepareTpuComputationForTfExportPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  PrepareTpuComputationForTfExportPassBase(const PrepareTpuComputationForTfExportPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("prepare-tpu-computation-for-tf-export");
  }
  ::llvm::StringRef getArgument() const override { return "prepare-tpu-computation-for-tf-export"; }

  ::llvm::StringRef getDescription() const override { return "Prepare TPU computation to be legal for export to TensorFlow"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("PrepareTpuComputationForTfExportPass");
  }
  ::llvm::StringRef getName() const override { return "PrepareTpuComputationForTfExportPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(PrepareTpuComputationForTfExportPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_PREPARETPUCOMPUTATIONFORTFEXPORTPASS
#endif // GEN_PASS_DEF_PREPARETPUCOMPUTATIONFORTFEXPORTPASS

//===----------------------------------------------------------------------===//
// PromoteResourcesToArgsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_PROMOTERESOURCESTOARGSPASS
struct PromoteResourcesToArgsPassOptions {
  ::llvm::ArrayRef<std::string> functions_;
};
#undef GEN_PASS_DECL_PROMOTERESOURCESTOARGSPASS
#endif // GEN_PASS_DECL_PROMOTERESOURCESTOARGSPASS
#ifdef GEN_PASS_DEF_PROMOTERESOURCESTOARGSPASS
namespace impl {

template <typename DerivedT>
class PromoteResourcesToArgsPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = PromoteResourcesToArgsPassBase;

  PromoteResourcesToArgsPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  PromoteResourcesToArgsPassBase(const PromoteResourcesToArgsPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-promote-resources-to-args");
  }
  ::llvm::StringRef getArgument() const override { return "tf-promote-resources-to-args"; }

  ::llvm::StringRef getDescription() const override { return "Promote resources reads/writes to function inputs/outputs."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("PromoteResourcesToArgsPass");
  }
  ::llvm::StringRef getName() const override { return "PromoteResourcesToArgsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(PromoteResourcesToArgsPassBase<DerivedT>)

  PromoteResourcesToArgsPassBase(const PromoteResourcesToArgsPassOptions &options) : PromoteResourcesToArgsPassBase() {
    functions_ = options.functions_;
  }
protected:
  ::mlir::Pass::ListOption<std::string> functions_{*this, "functions", ::llvm::cl::desc("Comma separated list of functions whose resources read/writes should be promoted to function inputs/outputs.")};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_PROMOTERESOURCESTOARGSPASS
#endif // GEN_PASS_DEF_PROMOTERESOURCESTOARGSPASS

//===----------------------------------------------------------------------===//
// PromoteVarHandlesToArgsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_PROMOTEVARHANDLESTOARGSPASS
#undef GEN_PASS_DECL_PROMOTEVARHANDLESTOARGSPASS
#endif // GEN_PASS_DECL_PROMOTEVARHANDLESTOARGSPASS
#ifdef GEN_PASS_DEF_PROMOTEVARHANDLESTOARGSPASS
namespace impl {

template <typename DerivedT>
class PromoteVarHandlesToArgsPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = PromoteVarHandlesToArgsPassBase;

  PromoteVarHandlesToArgsPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  PromoteVarHandlesToArgsPassBase(const PromoteVarHandlesToArgsPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-promote-var-handles-to-args");
  }
  ::llvm::StringRef getArgument() const override { return "tf-promote-var-handles-to-args"; }

  ::llvm::StringRef getDescription() const override { return "Promote tf.VarHandleOps to function arguments."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("PromoteVarHandlesToArgsPass");
  }
  ::llvm::StringRef getName() const override { return "PromoteVarHandlesToArgsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(PromoteVarHandlesToArgsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_PROMOTEVARHANDLESTOARGSPASS
#endif // GEN_PASS_DEF_PROMOTEVARHANDLESTOARGSPASS

//===----------------------------------------------------------------------===//
// RegionControlFlowToFunctionalPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_REGIONCONTROLFLOWTOFUNCTIONALPASS
#undef GEN_PASS_DECL_REGIONCONTROLFLOWTOFUNCTIONALPASS
#endif // GEN_PASS_DECL_REGIONCONTROLFLOWTOFUNCTIONALPASS
#ifdef GEN_PASS_DEF_REGIONCONTROLFLOWTOFUNCTIONALPASS
namespace impl {

template <typename DerivedT>
class RegionControlFlowToFunctionalPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = RegionControlFlowToFunctionalPassBase;

  RegionControlFlowToFunctionalPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  RegionControlFlowToFunctionalPassBase(const RegionControlFlowToFunctionalPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-region-control-flow-to-functional");
  }
  ::llvm::StringRef getArgument() const override { return "tf-region-control-flow-to-functional"; }

  ::llvm::StringRef getDescription() const override { return "Transforms region-based control flow operations to their functional counterparts"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("RegionControlFlowToFunctionalPass");
  }
  ::llvm::StringRef getName() const override { return "RegionControlFlowToFunctionalPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(RegionControlFlowToFunctionalPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_REGIONCONTROLFLOWTOFUNCTIONALPASS
#endif // GEN_PASS_DEF_REGIONCONTROLFLOWTOFUNCTIONALPASS

//===----------------------------------------------------------------------===//
// RemoveUnusedArgumentsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_REMOVEUNUSEDARGUMENTSPASS
#undef GEN_PASS_DECL_REMOVEUNUSEDARGUMENTSPASS
#endif // GEN_PASS_DECL_REMOVEUNUSEDARGUMENTSPASS
#ifdef GEN_PASS_DEF_REMOVEUNUSEDARGUMENTSPASS
namespace impl {

template <typename DerivedT>
class RemoveUnusedArgumentsPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = RemoveUnusedArgumentsPassBase;

  RemoveUnusedArgumentsPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  RemoveUnusedArgumentsPassBase(const RemoveUnusedArgumentsPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-remove-unused-arguments");
  }
  ::llvm::StringRef getArgument() const override { return "tf-remove-unused-arguments"; }

  ::llvm::StringRef getDescription() const override { return "Removes unused args from private functions & their callers."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("RemoveUnusedArgumentsPass");
  }
  ::llvm::StringRef getName() const override { return "RemoveUnusedArgumentsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(RemoveUnusedArgumentsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_REMOVEUNUSEDARGUMENTSPASS
#endif // GEN_PASS_DEF_REMOVEUNUSEDARGUMENTSPASS

//===----------------------------------------------------------------------===//
// RemoveUnusedWhileResultsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_REMOVEUNUSEDWHILERESULTSPASS
#undef GEN_PASS_DECL_REMOVEUNUSEDWHILERESULTSPASS
#endif // GEN_PASS_DECL_REMOVEUNUSEDWHILERESULTSPASS
#ifdef GEN_PASS_DEF_REMOVEUNUSEDWHILERESULTSPASS
namespace impl {

template <typename DerivedT>
class RemoveUnusedWhileResultsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = RemoveUnusedWhileResultsPassBase;

  RemoveUnusedWhileResultsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  RemoveUnusedWhileResultsPassBase(const RemoveUnusedWhileResultsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-remove-unused-while-results");
  }
  ::llvm::StringRef getArgument() const override { return "tf-remove-unused-while-results"; }

  ::llvm::StringRef getDescription() const override { return "Removes unused results from tf.WhileRegion ops"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("RemoveUnusedWhileResultsPass");
  }
  ::llvm::StringRef getName() const override { return "RemoveUnusedWhileResultsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(RemoveUnusedWhileResultsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_REMOVEUNUSEDWHILERESULTSPASS
#endif // GEN_PASS_DEF_REMOVEUNUSEDWHILERESULTSPASS

//===----------------------------------------------------------------------===//
// ReplicaIDToDeviceOrdinalPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_REPLICAIDTODEVICEORDINALPASS
#undef GEN_PASS_DECL_REPLICAIDTODEVICEORDINALPASS
#endif // GEN_PASS_DECL_REPLICAIDTODEVICEORDINALPASS
#ifdef GEN_PASS_DEF_REPLICAIDTODEVICEORDINALPASS
namespace impl {

template <typename DerivedT>
class ReplicaIDToDeviceOrdinalPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ReplicaIDToDeviceOrdinalPassBase;

  ReplicaIDToDeviceOrdinalPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ReplicaIDToDeviceOrdinalPassBase(const ReplicaIDToDeviceOrdinalPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-replica-id-to-device-ordinal");
  }
  ::llvm::StringRef getArgument() const override { return "tf-replica-id-to-device-ordinal"; }

  ::llvm::StringRef getDescription() const override { return "Set device ordinal with replica id"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ReplicaIDToDeviceOrdinalPass");
  }
  ::llvm::StringRef getName() const override { return "ReplicaIDToDeviceOrdinalPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ReplicaIDToDeviceOrdinalPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_REPLICAIDTODEVICEORDINALPASS
#endif // GEN_PASS_DEF_REPLICAIDTODEVICEORDINALPASS

//===----------------------------------------------------------------------===//
// ReplicateInvariantOpHoistingPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_REPLICATEINVARIANTOPHOISTINGPASS
#undef GEN_PASS_DECL_REPLICATEINVARIANTOPHOISTINGPASS
#endif // GEN_PASS_DECL_REPLICATEINVARIANTOPHOISTINGPASS
#ifdef GEN_PASS_DEF_REPLICATEINVARIANTOPHOISTINGPASS
namespace impl {

template <typename DerivedT>
class ReplicateInvariantOpHoistingPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ReplicateInvariantOpHoistingPassBase;

  ReplicateInvariantOpHoistingPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ReplicateInvariantOpHoistingPassBase(const ReplicateInvariantOpHoistingPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-replicate-invariant-op-hoisting");
  }
  ::llvm::StringRef getArgument() const override { return "tf-replicate-invariant-op-hoisting"; }

  ::llvm::StringRef getDescription() const override { return "Hoists replicate invariant operations out of replicate"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ReplicateInvariantOpHoistingPass");
  }
  ::llvm::StringRef getName() const override { return "ReplicateInvariantOpHoistingPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ReplicateInvariantOpHoistingPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_REPLICATEINVARIANTOPHOISTINGPASS
#endif // GEN_PASS_DEF_REPLICATEINVARIANTOPHOISTINGPASS

//===----------------------------------------------------------------------===//
// ReplicateToIslandPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_REPLICATETOISLANDPASS
#undef GEN_PASS_DECL_REPLICATETOISLANDPASS
#endif // GEN_PASS_DECL_REPLICATETOISLANDPASS
#ifdef GEN_PASS_DEF_REPLICATETOISLANDPASS
namespace impl {

template <typename DerivedT>
class ReplicateToIslandPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ReplicateToIslandPassBase;

  ReplicateToIslandPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ReplicateToIslandPassBase(const ReplicateToIslandPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-replicate-to-island");
  }
  ::llvm::StringRef getArgument() const override { return "tf-replicate-to-island"; }

  ::llvm::StringRef getDescription() const override { return "Lowers device replicate to executor islands"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ReplicateToIslandPass");
  }
  ::llvm::StringRef getName() const override { return "ReplicateToIslandPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ReplicateToIslandPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_REPLICATETOISLANDPASS
#endif // GEN_PASS_DEF_REPLICATETOISLANDPASS

//===----------------------------------------------------------------------===//
// ResourceDeviceInferencePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_RESOURCEDEVICEINFERENCEPASS
#undef GEN_PASS_DECL_RESOURCEDEVICEINFERENCEPASS
#endif // GEN_PASS_DECL_RESOURCEDEVICEINFERENCEPASS
#ifdef GEN_PASS_DEF_RESOURCEDEVICEINFERENCEPASS
namespace impl {

template <typename DerivedT>
class ResourceDeviceInferencePassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ResourceDeviceInferencePassBase;

  ResourceDeviceInferencePassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ResourceDeviceInferencePassBase(const ResourceDeviceInferencePassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-resource-device-inference");
  }
  ::llvm::StringRef getArgument() const override { return "tf-resource-device-inference"; }

  ::llvm::StringRef getDescription() const override { return "Propagates the device attribute on resources from callers to callees."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ResourceDeviceInferencePass");
  }
  ::llvm::StringRef getName() const override { return "ResourceDeviceInferencePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ResourceDeviceInferencePassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_RESOURCEDEVICEINFERENCEPASS
#endif // GEN_PASS_DEF_RESOURCEDEVICEINFERENCEPASS

//===----------------------------------------------------------------------===//
// RewriteTPUEmbeddingOpsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_REWRITETPUEMBEDDINGOPSPASS
#undef GEN_PASS_DECL_REWRITETPUEMBEDDINGOPSPASS
#endif // GEN_PASS_DECL_REWRITETPUEMBEDDINGOPSPASS
#ifdef GEN_PASS_DEF_REWRITETPUEMBEDDINGOPSPASS
namespace impl {

template <typename DerivedT>
class RewriteTPUEmbeddingOpsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = RewriteTPUEmbeddingOpsPassBase;

  RewriteTPUEmbeddingOpsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  RewriteTPUEmbeddingOpsPassBase(const RewriteTPUEmbeddingOpsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-rewrite-tpu-embedding-ops");
  }
  ::llvm::StringRef getArgument() const override { return "tf-rewrite-tpu-embedding-ops"; }

  ::llvm::StringRef getDescription() const override { return "Rewrites TPU embedding send/recv ops by adding TPU embedding deduplication data"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("RewriteTPUEmbeddingOpsPass");
  }
  ::llvm::StringRef getName() const override { return "RewriteTPUEmbeddingOpsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(RewriteTPUEmbeddingOpsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_REWRITETPUEMBEDDINGOPSPASS
#endif // GEN_PASS_DEF_REWRITETPUEMBEDDINGOPSPASS

//===----------------------------------------------------------------------===//
// SimpleTFDeviceAssignmentPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_SIMPLETFDEVICEASSIGNMENTPASS
struct SimpleTFDeviceAssignmentPassOptions {
  std::string default_device_ = "cpu";
};
#undef GEN_PASS_DECL_SIMPLETFDEVICEASSIGNMENTPASS
#endif // GEN_PASS_DECL_SIMPLETFDEVICEASSIGNMENTPASS
#ifdef GEN_PASS_DEF_SIMPLETFDEVICEASSIGNMENTPASS
namespace impl {

template <typename DerivedT>
class SimpleTFDeviceAssignmentPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = SimpleTFDeviceAssignmentPassBase;

  SimpleTFDeviceAssignmentPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  SimpleTFDeviceAssignmentPassBase(const SimpleTFDeviceAssignmentPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-simple-device-assignment");
  }
  ::llvm::StringRef getArgument() const override { return "tf-simple-device-assignment"; }

  ::llvm::StringRef getDescription() const override { return "Simple device assignment in TF dialect."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SimpleTFDeviceAssignmentPass");
  }
  ::llvm::StringRef getName() const override { return "SimpleTFDeviceAssignmentPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SimpleTFDeviceAssignmentPassBase<DerivedT>)

  SimpleTFDeviceAssignmentPassBase(const SimpleTFDeviceAssignmentPassOptions &options) : SimpleTFDeviceAssignmentPassBase() {
    default_device_ = options.default_device_;
  }
protected:
  ::mlir::Pass::Option<std::string> default_device_{*this, "default-device", ::llvm::cl::desc("The default device to assign."), ::llvm::cl::init("cpu")};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_SIMPLETFDEVICEASSIGNMENTPASS
#endif // GEN_PASS_DEF_SIMPLETFDEVICEASSIGNMENTPASS

//===----------------------------------------------------------------------===//
// SplitIntoIslandPerOpPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_SPLITINTOISLANDPEROPPASS
#undef GEN_PASS_DECL_SPLITINTOISLANDPEROPPASS
#endif // GEN_PASS_DECL_SPLITINTOISLANDPEROPPASS
#ifdef GEN_PASS_DEF_SPLITINTOISLANDPEROPPASS
namespace impl {

template <typename DerivedT>
class SplitIntoIslandPerOpPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = SplitIntoIslandPerOpPassBase;

  SplitIntoIslandPerOpPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  SplitIntoIslandPerOpPassBase(const SplitIntoIslandPerOpPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-executor-split-into-island-per-op");
  }
  ::llvm::StringRef getArgument() const override { return "tf-executor-split-into-island-per-op"; }

  ::llvm::StringRef getDescription() const override { return "Transform from TF control dialect to TF executor dialect."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SplitIntoIslandPerOpPass");
  }
  ::llvm::StringRef getName() const override { return "SplitIntoIslandPerOpPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<mlir::tf_executor::TensorFlowExecutorDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SplitIntoIslandPerOpPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_SPLITINTOISLANDPEROPPASS
#endif // GEN_PASS_DEF_SPLITINTOISLANDPEROPPASS

//===----------------------------------------------------------------------===//
// StackOpsDecompositionPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_STACKOPSDECOMPOSITIONPASS
#undef GEN_PASS_DECL_STACKOPSDECOMPOSITIONPASS
#endif // GEN_PASS_DECL_STACKOPSDECOMPOSITIONPASS
#ifdef GEN_PASS_DEF_STACKOPSDECOMPOSITIONPASS
namespace impl {

template <typename DerivedT>
class StackOpsDecompositionPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = StackOpsDecompositionPassBase;

  StackOpsDecompositionPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  StackOpsDecompositionPassBase(const StackOpsDecompositionPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-stack-ops-decomposition");
  }
  ::llvm::StringRef getArgument() const override { return "tf-stack-ops-decomposition"; }

  ::llvm::StringRef getDescription() const override { return "Decompose stack operations into local variable operations. Needs static shapes."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("StackOpsDecompositionPass");
  }
  ::llvm::StringRef getName() const override { return "StackOpsDecompositionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(StackOpsDecompositionPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_STACKOPSDECOMPOSITIONPASS
#endif // GEN_PASS_DEF_STACKOPSDECOMPOSITIONPASS

//===----------------------------------------------------------------------===//
// StripNoinlineAttributePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_STRIPNOINLINEATTRIBUTEPASS
#undef GEN_PASS_DECL_STRIPNOINLINEATTRIBUTEPASS
#endif // GEN_PASS_DECL_STRIPNOINLINEATTRIBUTEPASS
#ifdef GEN_PASS_DEF_STRIPNOINLINEATTRIBUTEPASS
namespace impl {

template <typename DerivedT>
class StripNoinlineAttributePassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = StripNoinlineAttributePassBase;

  StripNoinlineAttributePassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  StripNoinlineAttributePassBase(const StripNoinlineAttributePassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-strip-noinline-attribute");
  }
  ::llvm::StringRef getArgument() const override { return "tf-strip-noinline-attribute"; }

  ::llvm::StringRef getDescription() const override { return "Strip the tf._noinline attribute from top-level functions."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("StripNoinlineAttributePass");
  }
  ::llvm::StringRef getName() const override { return "StripNoinlineAttributePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(StripNoinlineAttributePassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_STRIPNOINLINEATTRIBUTEPASS
#endif // GEN_PASS_DEF_STRIPNOINLINEATTRIBUTEPASS

//===----------------------------------------------------------------------===//
// StripTfAttributesPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_STRIPTFATTRIBUTESPASS
#undef GEN_PASS_DECL_STRIPTFATTRIBUTESPASS
#endif // GEN_PASS_DECL_STRIPTFATTRIBUTESPASS
#ifdef GEN_PASS_DEF_STRIPTFATTRIBUTESPASS
namespace impl {

template <typename DerivedT>
class StripTfAttributesPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = StripTfAttributesPassBase;

  StripTfAttributesPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  StripTfAttributesPassBase(const StripTfAttributesPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-strip-tf-attributes");
  }
  ::llvm::StringRef getArgument() const override { return "tf-strip-tf-attributes"; }

  ::llvm::StringRef getDescription() const override { return "Removes TF specific attributes"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("StripTfAttributesPass");
  }
  ::llvm::StringRef getName() const override { return "StripTfAttributesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(StripTfAttributesPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_STRIPTFATTRIBUTESPASS
#endif // GEN_PASS_DEF_STRIPTFATTRIBUTESPASS

//===----------------------------------------------------------------------===//
// TFDataOptimizationPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TFDATAOPTIMIZATIONPASS
#undef GEN_PASS_DECL_TFDATAOPTIMIZATIONPASS
#endif // GEN_PASS_DECL_TFDATAOPTIMIZATIONPASS
#ifdef GEN_PASS_DEF_TFDATAOPTIMIZATIONPASS
namespace impl {

template <typename DerivedT>
class TFDataOptimizationPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TFDataOptimizationPassBase;

  TFDataOptimizationPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TFDataOptimizationPassBase(const TFDataOptimizationPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-data-optimization");
  }
  ::llvm::StringRef getArgument() const override { return "tf-data-optimization"; }

  ::llvm::StringRef getDescription() const override { return "Performs tf.data optimizations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TFDataOptimizationPass");
  }
  ::llvm::StringRef getName() const override { return "TFDataOptimizationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TFDataOptimizationPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TFDATAOPTIMIZATIONPASS
#endif // GEN_PASS_DEF_TFDATAOPTIMIZATIONPASS

//===----------------------------------------------------------------------===//
// TFDeviceAssignmentByFuncAttrPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TFDEVICEASSIGNMENTBYFUNCATTRPASS
#undef GEN_PASS_DECL_TFDEVICEASSIGNMENTBYFUNCATTRPASS
#endif // GEN_PASS_DECL_TFDEVICEASSIGNMENTBYFUNCATTRPASS
#ifdef GEN_PASS_DEF_TFDEVICEASSIGNMENTBYFUNCATTRPASS
namespace impl {

template <typename DerivedT>
class TFDeviceAssignmentByFuncAttrPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TFDeviceAssignmentByFuncAttrPassBase;

  TFDeviceAssignmentByFuncAttrPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TFDeviceAssignmentByFuncAttrPassBase(const TFDeviceAssignmentByFuncAttrPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-device-assignment-by-func-attr");
  }
  ::llvm::StringRef getArgument() const override { return "tf-device-assignment-by-func-attr"; }

  ::llvm::StringRef getDescription() const override { return "Device assignment in TF dialect using the device specified in the function attribute."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TFDeviceAssignmentByFuncAttrPass");
  }
  ::llvm::StringRef getName() const override { return "TFDeviceAssignmentByFuncAttrPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TFDeviceAssignmentByFuncAttrPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TFDEVICEASSIGNMENTBYFUNCATTRPASS
#endif // GEN_PASS_DEF_TFDEVICEASSIGNMENTBYFUNCATTRPASS

//===----------------------------------------------------------------------===//
// TPUBridgeExecutorIslandOutliningPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TPUBRIDGEEXECUTORISLANDOUTLININGPASS
#undef GEN_PASS_DECL_TPUBRIDGEEXECUTORISLANDOUTLININGPASS
#endif // GEN_PASS_DECL_TPUBRIDGEEXECUTORISLANDOUTLININGPASS
#ifdef GEN_PASS_DEF_TPUBRIDGEEXECUTORISLANDOUTLININGPASS
namespace impl {

template <typename DerivedT>
class TPUBridgeExecutorIslandOutliningPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TPUBridgeExecutorIslandOutliningPassBase;

  TPUBridgeExecutorIslandOutliningPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUBridgeExecutorIslandOutliningPassBase(const TPUBridgeExecutorIslandOutliningPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-executor-tpu-v1-island-outlining");
  }
  ::llvm::StringRef getArgument() const override { return "tf-executor-tpu-v1-island-outlining"; }

  ::llvm::StringRef getDescription() const override { return "Outline TPU clusters from island into a nested module, so it can be processed like a V2 module, intended for V1 compatibility mode"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUBridgeExecutorIslandOutliningPass");
  }
  ::llvm::StringRef getName() const override { return "TPUBridgeExecutorIslandOutliningPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUBridgeExecutorIslandOutliningPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TPUBRIDGEEXECUTORISLANDOUTLININGPASS
#endif // GEN_PASS_DEF_TPUBRIDGEEXECUTORISLANDOUTLININGPASS

//===----------------------------------------------------------------------===//
// TPUCleanupClusterAttributesPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TPUCLEANUPCLUSTERATTRIBUTESPASS
#undef GEN_PASS_DECL_TPUCLEANUPCLUSTERATTRIBUTESPASS
#endif // GEN_PASS_DECL_TPUCLEANUPCLUSTERATTRIBUTESPASS
#ifdef GEN_PASS_DEF_TPUCLEANUPCLUSTERATTRIBUTESPASS
namespace impl {

template <typename DerivedT>
class TPUCleanupClusterAttributesPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TPUCleanupClusterAttributesPassBase;

  TPUCleanupClusterAttributesPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUCleanupClusterAttributesPassBase(const TPUCleanupClusterAttributesPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-cleanup-cluster-attributes");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-cleanup-cluster-attributes"; }

  ::llvm::StringRef getDescription() const override { return "Eliminate _replication_info and other attributes from ops in a cluster"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUCleanupClusterAttributesPass");
  }
  ::llvm::StringRef getName() const override { return "TPUCleanupClusterAttributesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUCleanupClusterAttributesPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TPUCLEANUPCLUSTERATTRIBUTESPASS
#endif // GEN_PASS_DEF_TPUCLEANUPCLUSTERATTRIBUTESPASS

//===----------------------------------------------------------------------===//
// TPUClusterFormationPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TPUCLUSTERFORMATIONPASS
#undef GEN_PASS_DECL_TPUCLUSTERFORMATIONPASS
#endif // GEN_PASS_DECL_TPUCLUSTERFORMATIONPASS
#ifdef GEN_PASS_DEF_TPUCLUSTERFORMATIONPASS
namespace impl {

template <typename DerivedT>
class TPUClusterFormationPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TPUClusterFormationPassBase;

  TPUClusterFormationPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUClusterFormationPassBase(const TPUClusterFormationPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-cluster-formation");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-cluster-formation"; }

  ::llvm::StringRef getDescription() const override { return "Forms clusters from operations assigned to the same TPU computation"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUClusterFormationPass");
  }
  ::llvm::StringRef getName() const override { return "TPUClusterFormationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUClusterFormationPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TPUCLUSTERFORMATIONPASS
#endif // GEN_PASS_DEF_TPUCLUSTERFORMATIONPASS

//===----------------------------------------------------------------------===//
// TPUColocateCompositeResourceOpsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TPUCOLOCATECOMPOSITERESOURCEOPSPASS
#undef GEN_PASS_DECL_TPUCOLOCATECOMPOSITERESOURCEOPSPASS
#endif // GEN_PASS_DECL_TPUCOLOCATECOMPOSITERESOURCEOPSPASS
#ifdef GEN_PASS_DEF_TPUCOLOCATECOMPOSITERESOURCEOPSPASS
namespace impl {

template <typename DerivedT>
class TPUColocateCompositeResourceOpsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TPUColocateCompositeResourceOpsPassBase;

  TPUColocateCompositeResourceOpsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUColocateCompositeResourceOpsPassBase(const TPUColocateCompositeResourceOpsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-colocate-composite-resource-ops");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-colocate-composite-resource-ops"; }

  ::llvm::StringRef getDescription() const override { return "Colocate resource with composite device assignment to TPU device."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUColocateCompositeResourceOpsPass");
  }
  ::llvm::StringRef getName() const override { return "TPUColocateCompositeResourceOpsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUColocateCompositeResourceOpsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TPUCOLOCATECOMPOSITERESOURCEOPSPASS
#endif // GEN_PASS_DEF_TPUCOLOCATECOMPOSITERESOURCEOPSPASS

//===----------------------------------------------------------------------===//
// TPUDevicePropagationPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TPUDEVICEPROPAGATIONPASS
#undef GEN_PASS_DECL_TPUDEVICEPROPAGATIONPASS
#endif // GEN_PASS_DECL_TPUDEVICEPROPAGATIONPASS
#ifdef GEN_PASS_DEF_TPUDEVICEPROPAGATIONPASS
namespace impl {

template <typename DerivedT>
class TPUDevicePropagationPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TPUDevicePropagationPassBase;

  TPUDevicePropagationPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUDevicePropagationPassBase(const TPUDevicePropagationPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-device-propagation");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-device-propagation"; }

  ::llvm::StringRef getDescription() const override { return "Propagates TPU devices from ops to users"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUDevicePropagationPass");
  }
  ::llvm::StringRef getName() const override { return "TPUDevicePropagationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUDevicePropagationPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TPUDEVICEPROPAGATIONPASS
#endif // GEN_PASS_DEF_TPUDEVICEPROPAGATIONPASS

//===----------------------------------------------------------------------===//
// TPUDynamicLayoutPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TPUDYNAMICLAYOUTPASS
#undef GEN_PASS_DECL_TPUDYNAMICLAYOUTPASS
#endif // GEN_PASS_DECL_TPUDYNAMICLAYOUTPASS
#ifdef GEN_PASS_DEF_TPUDYNAMICLAYOUTPASS
namespace impl {

template <typename DerivedT>
class TPUDynamicLayoutPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TPUDynamicLayoutPassBase;

  TPUDynamicLayoutPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUDynamicLayoutPassBase(const TPUDynamicLayoutPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-dynamic-layout-pass");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-dynamic-layout-pass"; }

  ::llvm::StringRef getDescription() const override { return "Inserts TPU layout ops to determine layout at run time."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUDynamicLayoutPass");
  }
  ::llvm::StringRef getName() const override { return "TPUDynamicLayoutPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUDynamicLayoutPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TPUDYNAMICLAYOUTPASS
#endif // GEN_PASS_DEF_TPUDYNAMICLAYOUTPASS

//===----------------------------------------------------------------------===//
// TPUExtractHeadTailOutsideCompilationPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TPUEXTRACTHEADTAILOUTSIDECOMPILATIONPASS
#undef GEN_PASS_DECL_TPUEXTRACTHEADTAILOUTSIDECOMPILATIONPASS
#endif // GEN_PASS_DECL_TPUEXTRACTHEADTAILOUTSIDECOMPILATIONPASS
#ifdef GEN_PASS_DEF_TPUEXTRACTHEADTAILOUTSIDECOMPILATIONPASS
namespace impl {

template <typename DerivedT>
class TPUExtractHeadTailOutsideCompilationPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TPUExtractHeadTailOutsideCompilationPassBase;

  TPUExtractHeadTailOutsideCompilationPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUExtractHeadTailOutsideCompilationPassBase(const TPUExtractHeadTailOutsideCompilationPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-extract-head-tail-outside-compilation");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-extract-head-tail-outside-compilation"; }

  ::llvm::StringRef getDescription() const override { return "Extracts TPU head or tail outside compilation to separate host launches before/after device cluster."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUExtractHeadTailOutsideCompilationPass");
  }
  ::llvm::StringRef getName() const override { return "TPUExtractHeadTailOutsideCompilationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUExtractHeadTailOutsideCompilationPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TPUEXTRACTHEADTAILOUTSIDECOMPILATIONPASS
#endif // GEN_PASS_DEF_TPUEXTRACTHEADTAILOUTSIDECOMPILATIONPASS

//===----------------------------------------------------------------------===//
// TPUExtractOutsideCompilationPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TPUEXTRACTOUTSIDECOMPILATIONPASS
#undef GEN_PASS_DECL_TPUEXTRACTOUTSIDECOMPILATIONPASS
#endif // GEN_PASS_DECL_TPUEXTRACTOUTSIDECOMPILATIONPASS
#ifdef GEN_PASS_DEF_TPUEXTRACTOUTSIDECOMPILATIONPASS
namespace impl {

template <typename DerivedT>
class TPUExtractOutsideCompilationPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TPUExtractOutsideCompilationPassBase;

  TPUExtractOutsideCompilationPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUExtractOutsideCompilationPassBase(const TPUExtractOutsideCompilationPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-extract-outside-compilation");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-extract-outside-compilation"; }

  ::llvm::StringRef getDescription() const override { return "Extracts TPU outside compilation computation to a separate tf_device.parallel_execute region."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUExtractOutsideCompilationPass");
  }
  ::llvm::StringRef getName() const override { return "TPUExtractOutsideCompilationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUExtractOutsideCompilationPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TPUEXTRACTOUTSIDECOMPILATIONPASS
#endif // GEN_PASS_DEF_TPUEXTRACTOUTSIDECOMPILATIONPASS

//===----------------------------------------------------------------------===//
// TPUHostComputationExpansionPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TPUHOSTCOMPUTATIONEXPANSIONPASS
#undef GEN_PASS_DECL_TPUHOSTCOMPUTATIONEXPANSIONPASS
#endif // GEN_PASS_DECL_TPUHOSTCOMPUTATIONEXPANSIONPASS
#ifdef GEN_PASS_DEF_TPUHOSTCOMPUTATIONEXPANSIONPASS
namespace impl {

template <typename DerivedT>
class TPUHostComputationExpansionPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TPUHostComputationExpansionPassBase;

  TPUHostComputationExpansionPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUHostComputationExpansionPassBase(const TPUHostComputationExpansionPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-host-computation-expansion");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-host-computation-expansion"; }

  ::llvm::StringRef getDescription() const override { return "Expands host computation before and after TPU computation."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUHostComputationExpansionPass");
  }
  ::llvm::StringRef getName() const override { return "TPUHostComputationExpansionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUHostComputationExpansionPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TPUHOSTCOMPUTATIONEXPANSIONPASS
#endif // GEN_PASS_DEF_TPUHOSTCOMPUTATIONEXPANSIONPASS

//===----------------------------------------------------------------------===//
// TPUIdentityPruningPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TPUIDENTITYPRUNINGPASS
#undef GEN_PASS_DECL_TPUIDENTITYPRUNINGPASS
#endif // GEN_PASS_DECL_TPUIDENTITYPRUNINGPASS
#ifdef GEN_PASS_DEF_TPUIDENTITYPRUNINGPASS
namespace impl {

template <typename DerivedT>
class TPUIdentityPruningPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TPUIdentityPruningPassBase;

  TPUIdentityPruningPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUIdentityPruningPassBase(const TPUIdentityPruningPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-identity-pruning");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-identity-pruning"; }

  ::llvm::StringRef getDescription() const override { return "Removes Identity/IdentityN ops from the TPU computation"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUIdentityPruningPass");
  }
  ::llvm::StringRef getName() const override { return "TPUIdentityPruningPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUIdentityPruningPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TPUIDENTITYPRUNINGPASS
#endif // GEN_PASS_DEF_TPUIDENTITYPRUNINGPASS

//===----------------------------------------------------------------------===//
// TPUMergeVariablesWithExecutePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TPUMERGEVARIABLESWITHEXECUTEPASS
#undef GEN_PASS_DECL_TPUMERGEVARIABLESWITHEXECUTEPASS
#endif // GEN_PASS_DECL_TPUMERGEVARIABLESWITHEXECUTEPASS
#ifdef GEN_PASS_DEF_TPUMERGEVARIABLESWITHEXECUTEPASS
namespace impl {

template <typename DerivedT>
class TPUMergeVariablesWithExecutePassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TPUMergeVariablesWithExecutePassBase;

  TPUMergeVariablesWithExecutePassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUMergeVariablesWithExecutePassBase(const TPUMergeVariablesWithExecutePassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-merge-variables-with-execute");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-merge-variables-with-execute"; }

  ::llvm::StringRef getDescription() const override { return "Merges device variable reads and updates into TPU execute ops"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUMergeVariablesWithExecutePass");
  }
  ::llvm::StringRef getName() const override { return "TPUMergeVariablesWithExecutePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUMergeVariablesWithExecutePassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TPUMERGEVARIABLESWITHEXECUTEPASS
#endif // GEN_PASS_DEF_TPUMERGEVARIABLESWITHEXECUTEPASS

//===----------------------------------------------------------------------===//
// TPUParallelExecuteSinkResourceWritePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TPUPARALLELEXECUTESINKRESOURCEWRITEPASS
#undef GEN_PASS_DECL_TPUPARALLELEXECUTESINKRESOURCEWRITEPASS
#endif // GEN_PASS_DECL_TPUPARALLELEXECUTESINKRESOURCEWRITEPASS
#ifdef GEN_PASS_DEF_TPUPARALLELEXECUTESINKRESOURCEWRITEPASS
namespace impl {

template <typename DerivedT>
class TPUParallelExecuteSinkResourceWritePassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TPUParallelExecuteSinkResourceWritePassBase;

  TPUParallelExecuteSinkResourceWritePassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUParallelExecuteSinkResourceWritePassBase(const TPUParallelExecuteSinkResourceWritePassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-parallel-execute-sink-resource-write");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-parallel-execute-sink-resource-write"; }

  ::llvm::StringRef getDescription() const override { return "Moves tf.AssignVariableOp consumers of tf_device.parallel_execute into tf_device.parallel_execute regions"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUParallelExecuteSinkResourceWritePass");
  }
  ::llvm::StringRef getName() const override { return "TPUParallelExecuteSinkResourceWritePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUParallelExecuteSinkResourceWritePassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TPUPARALLELEXECUTESINKRESOURCEWRITEPASS
#endif // GEN_PASS_DEF_TPUPARALLELEXECUTESINKRESOURCEWRITEPASS

//===----------------------------------------------------------------------===//
// TPUReorderReplicateAndPartitionedInputsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TPUREORDERREPLICATEANDPARTITIONEDINPUTSPASS
#undef GEN_PASS_DECL_TPUREORDERREPLICATEANDPARTITIONEDINPUTSPASS
#endif // GEN_PASS_DECL_TPUREORDERREPLICATEANDPARTITIONEDINPUTSPASS
#ifdef GEN_PASS_DEF_TPUREORDERREPLICATEANDPARTITIONEDINPUTSPASS
namespace impl {

template <typename DerivedT>
class TPUReorderReplicateAndPartitionedInputsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TPUReorderReplicateAndPartitionedInputsPassBase;

  TPUReorderReplicateAndPartitionedInputsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUReorderReplicateAndPartitionedInputsPassBase(const TPUReorderReplicateAndPartitionedInputsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-reorder-replicate-partitioned-inputs");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-reorder-replicate-partitioned-inputs"; }

  ::llvm::StringRef getDescription() const override { return "Reorder replicated and partitioned input ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUReorderReplicateAndPartitionedInputsPass");
  }
  ::llvm::StringRef getName() const override { return "TPUReorderReplicateAndPartitionedInputsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUReorderReplicateAndPartitionedInputsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TPUREORDERREPLICATEANDPARTITIONEDINPUTSPASS
#endif // GEN_PASS_DEF_TPUREORDERREPLICATEANDPARTITIONEDINPUTSPASS

//===----------------------------------------------------------------------===//
// TPUResourceReadForWritePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TPURESOURCEREADFORWRITEPASS
#undef GEN_PASS_DECL_TPURESOURCEREADFORWRITEPASS
#endif // GEN_PASS_DECL_TPURESOURCEREADFORWRITEPASS
#ifdef GEN_PASS_DEF_TPURESOURCEREADFORWRITEPASS
namespace impl {

template <typename DerivedT>
class TPUResourceReadForWritePassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TPUResourceReadForWritePassBase;

  TPUResourceReadForWritePassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUResourceReadForWritePassBase(const TPUResourceReadForWritePassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-resource-read-for-write");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-resource-read-for-write"; }

  ::llvm::StringRef getDescription() const override { return "Inserts tf.ReadVariableOp inputs to a TPU cluster for resource writes with no reads"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUResourceReadForWritePass");
  }
  ::llvm::StringRef getName() const override { return "TPUResourceReadForWritePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUResourceReadForWritePassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TPURESOURCEREADFORWRITEPASS
#endif // GEN_PASS_DEF_TPURESOURCEREADFORWRITEPASS

//===----------------------------------------------------------------------===//
// TPUResourceReadsWritesPartitioningPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TPURESOURCEREADSWRITESPARTITIONINGPASS
#undef GEN_PASS_DECL_TPURESOURCEREADSWRITESPARTITIONINGPASS
#endif // GEN_PASS_DECL_TPURESOURCEREADSWRITESPARTITIONINGPASS
#ifdef GEN_PASS_DEF_TPURESOURCEREADSWRITESPARTITIONINGPASS
namespace impl {

template <typename DerivedT>
class TPUResourceReadsWritesPartitioningPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TPUResourceReadsWritesPartitioningPassBase;

  TPUResourceReadsWritesPartitioningPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUResourceReadsWritesPartitioningPassBase(const TPUResourceReadsWritesPartitioningPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-resource-partition");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-resource-partition"; }

  ::llvm::StringRef getDescription() const override { return "Partitions unpartitioned resource read/write to partitioned resource variables."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUResourceReadsWritesPartitioningPass");
  }
  ::llvm::StringRef getName() const override { return "TPUResourceReadsWritesPartitioningPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUResourceReadsWritesPartitioningPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TPURESOURCEREADSWRITESPARTITIONINGPASS
#endif // GEN_PASS_DEF_TPURESOURCEREADSWRITESPARTITIONINGPASS

//===----------------------------------------------------------------------===//
// TPURewritePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TPUREWRITEPASS
struct TPURewritePassOptions {
  bool tpu_compile_metadata_debug_ = false;
};
#undef GEN_PASS_DECL_TPUREWRITEPASS
#endif // GEN_PASS_DECL_TPUREWRITEPASS
#ifdef GEN_PASS_DEF_TPUREWRITEPASS
namespace impl {

template <typename DerivedT>
class TPURewritePassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TPURewritePassBase;

  TPURewritePassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPURewritePassBase(const TPURewritePassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-rewrite");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-rewrite"; }

  ::llvm::StringRef getDescription() const override { return "Rewrites a `tf_device.cluster_func` on TPUs into TPU runtime operations."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPURewritePass");
  }
  ::llvm::StringRef getName() const override { return "TPURewritePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPURewritePassBase<DerivedT>)

  TPURewritePassBase(const TPURewritePassOptions &options) : TPURewritePassBase() {
    tpu_compile_metadata_debug_ = options.tpu_compile_metadata_debug_;
  }
protected:
  ::mlir::Pass::Option<bool> tpu_compile_metadata_debug_{*this, "tpu-compile-metadata-debug", ::llvm::cl::desc("Whether to serialize TPUCompileMetadataProto metadata in 'tf._TPUCompileMlir' op as a proto debug string"), ::llvm::cl::init(false)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TPUREWRITEPASS
#endif // GEN_PASS_DEF_TPUREWRITEPASS

//===----------------------------------------------------------------------===//
// TPUShardingIdentificationPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TPUSHARDINGIDENTIFICATIONPASS
#undef GEN_PASS_DECL_TPUSHARDINGIDENTIFICATIONPASS
#endif // GEN_PASS_DECL_TPUSHARDINGIDENTIFICATIONPASS
#ifdef GEN_PASS_DEF_TPUSHARDINGIDENTIFICATIONPASS
namespace impl {

template <typename DerivedT>
class TPUShardingIdentificationPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TPUShardingIdentificationPassBase;

  TPUShardingIdentificationPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUShardingIdentificationPassBase(const TPUShardingIdentificationPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-sharding-identification");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-sharding-identification"; }

  ::llvm::StringRef getDescription() const override { return "Identifies and handles inputs/outputs of TPU computation that is sharded across logical cores."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUShardingIdentificationPass");
  }
  ::llvm::StringRef getName() const override { return "TPUShardingIdentificationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUShardingIdentificationPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TPUSHARDINGIDENTIFICATIONPASS
#endif // GEN_PASS_DEF_TPUSHARDINGIDENTIFICATIONPASS

//===----------------------------------------------------------------------===//
// TPUSpaceToDepthPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TPUSPACETODEPTHPASS
#undef GEN_PASS_DECL_TPUSPACETODEPTHPASS
#endif // GEN_PASS_DECL_TPUSPACETODEPTHPASS
#ifdef GEN_PASS_DEF_TPUSPACETODEPTHPASS
namespace impl {

template <typename DerivedT>
class TPUSpaceToDepthPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TPUSpaceToDepthPassBase;

  TPUSpaceToDepthPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUSpaceToDepthPassBase(const TPUSpaceToDepthPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-space-to-depth-pass");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-space-to-depth-pass"; }

  ::llvm::StringRef getDescription() const override { return "Applies automatic space to depth transform for the first or frontier convolutions consume host inputs on TPU."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUSpaceToDepthPass");
  }
  ::llvm::StringRef getName() const override { return "TPUSpaceToDepthPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUSpaceToDepthPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TPUSPACETODEPTHPASS
#endif // GEN_PASS_DEF_TPUSPACETODEPTHPASS

//===----------------------------------------------------------------------===//
// TPUUpdateEmbeddingEnqueueOpInputsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TPUUPDATEEMBEDDINGENQUEUEOPINPUTSPASS
#undef GEN_PASS_DECL_TPUUPDATEEMBEDDINGENQUEUEOPINPUTSPASS
#endif // GEN_PASS_DECL_TPUUPDATEEMBEDDINGENQUEUEOPINPUTSPASS
#ifdef GEN_PASS_DEF_TPUUPDATEEMBEDDINGENQUEUEOPINPUTSPASS
namespace impl {

template <typename DerivedT>
class TPUUpdateEmbeddingEnqueueOpInputsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TPUUpdateEmbeddingEnqueueOpInputsPassBase;

  TPUUpdateEmbeddingEnqueueOpInputsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUUpdateEmbeddingEnqueueOpInputsPassBase(const TPUUpdateEmbeddingEnqueueOpInputsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-update-embedding-enqueue-op-inputs");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-update-embedding-enqueue-op-inputs"; }

  ::llvm::StringRef getDescription() const override { return "Updates inputs to TPU embedding enqueue ops depending on whether graph is in training mode or in evaluation mode."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUUpdateEmbeddingEnqueueOpInputsPass");
  }
  ::llvm::StringRef getName() const override { return "TPUUpdateEmbeddingEnqueueOpInputsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUUpdateEmbeddingEnqueueOpInputsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TPUUPDATEEMBEDDINGENQUEUEOPINPUTSPASS
#endif // GEN_PASS_DEF_TPUUPDATEEMBEDDINGENQUEUEOPINPUTSPASS

//===----------------------------------------------------------------------===//
// TPUVariableRuntimeReformattingPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TPUVARIABLERUNTIMEREFORMATTINGPASS
#undef GEN_PASS_DECL_TPUVARIABLERUNTIMEREFORMATTINGPASS
#endif // GEN_PASS_DECL_TPUVARIABLERUNTIMEREFORMATTINGPASS
#ifdef GEN_PASS_DEF_TPUVARIABLERUNTIMEREFORMATTINGPASS
namespace impl {

template <typename DerivedT>
class TPUVariableRuntimeReformattingPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TPUVariableRuntimeReformattingPassBase;

  TPUVariableRuntimeReformattingPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUVariableRuntimeReformattingPassBase(const TPUVariableRuntimeReformattingPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-variable-runtime-reformatting");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-variable-runtime-reformatting"; }

  ::llvm::StringRef getDescription() const override { return "Adds device variable formatting op to allow compilation-guided variable formatting."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUVariableRuntimeReformattingPass");
  }
  ::llvm::StringRef getName() const override { return "TPUVariableRuntimeReformattingPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUVariableRuntimeReformattingPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TPUVARIABLERUNTIMEREFORMATTINGPASS
#endif // GEN_PASS_DEF_TPUVARIABLERUNTIMEREFORMATTINGPASS

//===----------------------------------------------------------------------===//
// TensorArrayOpsDecompositionPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TENSORARRAYOPSDECOMPOSITIONPASS
#undef GEN_PASS_DECL_TENSORARRAYOPSDECOMPOSITIONPASS
#endif // GEN_PASS_DECL_TENSORARRAYOPSDECOMPOSITIONPASS
#ifdef GEN_PASS_DEF_TENSORARRAYOPSDECOMPOSITIONPASS
namespace impl {

template <typename DerivedT>
class TensorArrayOpsDecompositionPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TensorArrayOpsDecompositionPassBase;

  TensorArrayOpsDecompositionPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TensorArrayOpsDecompositionPassBase(const TensorArrayOpsDecompositionPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tensor-array-ops-decomposition");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tensor-array-ops-decomposition"; }

  ::llvm::StringRef getDescription() const override { return "Decompose tensor array operations into local variable operations."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TensorArrayOpsDecompositionPass");
  }
  ::llvm::StringRef getName() const override { return "TensorArrayOpsDecompositionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<tensor::TensorDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TensorArrayOpsDecompositionPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TENSORARRAYOPSDECOMPOSITIONPASS
#endif // GEN_PASS_DEF_TENSORARRAYOPSDECOMPOSITIONPASS

//===----------------------------------------------------------------------===//
// TensorDeviceCopyConversionPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TENSORDEVICECOPYCONVERSIONPASS
#undef GEN_PASS_DECL_TENSORDEVICECOPYCONVERSIONPASS
#endif // GEN_PASS_DECL_TENSORDEVICECOPYCONVERSIONPASS
#ifdef GEN_PASS_DEF_TENSORDEVICECOPYCONVERSIONPASS
namespace impl {

template <typename DerivedT>
class TensorDeviceCopyConversionPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TensorDeviceCopyConversionPassBase;

  TensorDeviceCopyConversionPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TensorDeviceCopyConversionPassBase(const TensorDeviceCopyConversionPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tensor-device-copy");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tensor-device-copy"; }

  ::llvm::StringRef getDescription() const override { return "Fold the tf.Identity op and the tf.IdentityN op if the op has the same device as its operand"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TensorDeviceCopyConversionPass");
  }
  ::llvm::StringRef getName() const override { return "TensorDeviceCopyConversionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TensorDeviceCopyConversionPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TENSORDEVICECOPYCONVERSIONPASS
#endif // GEN_PASS_DEF_TENSORDEVICECOPYCONVERSIONPASS

//===----------------------------------------------------------------------===//
// TensorFlowOptimizePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TENSORFLOWOPTIMIZEPASS
#undef GEN_PASS_DECL_TENSORFLOWOPTIMIZEPASS
#endif // GEN_PASS_DECL_TENSORFLOWOPTIMIZEPASS
#ifdef GEN_PASS_DEF_TENSORFLOWOPTIMIZEPASS
namespace impl {

template <typename DerivedT>
class TensorFlowOptimizePassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TensorFlowOptimizePassBase;

  TensorFlowOptimizePassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TensorFlowOptimizePassBase(const TensorFlowOptimizePassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-optimize");
  }
  ::llvm::StringRef getArgument() const override { return "tf-optimize"; }

  ::llvm::StringRef getDescription() const override { return "Optimize TensorFlow module"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TensorFlowOptimizePass");
  }
  ::llvm::StringRef getName() const override { return "TensorFlowOptimizePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TensorFlowOptimizePassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TENSORFLOWOPTIMIZEPASS
#endif // GEN_PASS_DEF_TENSORFLOWOPTIMIZEPASS

//===----------------------------------------------------------------------===//
// TensorFlowShapeInferencePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TENSORFLOWSHAPEINFERENCEPASS
struct TensorFlowShapeInferencePassOptions {
  int64_t max_iterations_ = 10;
};
#undef GEN_PASS_DECL_TENSORFLOWSHAPEINFERENCEPASS
#endif // GEN_PASS_DECL_TENSORFLOWSHAPEINFERENCEPASS
#ifdef GEN_PASS_DEF_TENSORFLOWSHAPEINFERENCEPASS
namespace impl {

template <typename DerivedT>
class TensorFlowShapeInferencePassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TensorFlowShapeInferencePassBase;

  TensorFlowShapeInferencePassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TensorFlowShapeInferencePassBase(const TensorFlowShapeInferencePassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-shape-inference");
  }
  ::llvm::StringRef getArgument() const override { return "tf-shape-inference"; }

  ::llvm::StringRef getDescription() const override { return "Shape inference on TF dialect and ops implementing InferTypeOpInterface"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TensorFlowShapeInferencePass");
  }
  ::llvm::StringRef getName() const override { return "TensorFlowShapeInferencePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TensorFlowShapeInferencePassBase<DerivedT>)

  TensorFlowShapeInferencePassBase(const TensorFlowShapeInferencePassOptions &options) : TensorFlowShapeInferencePassBase() {
    max_iterations_ = options.max_iterations_;
  }
protected:
  ::mlir::Pass::Option<int64_t> max_iterations_{*this, "max-iterations", ::llvm::cl::desc("Maximum shape inference iterations"), ::llvm::cl::init(10)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TENSORFLOWSHAPEINFERENCEPASS
#endif // GEN_PASS_DEF_TENSORFLOWSHAPEINFERENCEPASS

//===----------------------------------------------------------------------===//
// TensorListOpsDecompositionPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TENSORLISTOPSDECOMPOSITIONPASS
#undef GEN_PASS_DECL_TENSORLISTOPSDECOMPOSITIONPASS
#endif // GEN_PASS_DECL_TENSORLISTOPSDECOMPOSITIONPASS
#ifdef GEN_PASS_DEF_TENSORLISTOPSDECOMPOSITIONPASS
namespace impl {

template <typename DerivedT>
class TensorListOpsDecompositionPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TensorListOpsDecompositionPassBase;

  TensorListOpsDecompositionPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TensorListOpsDecompositionPassBase(const TensorListOpsDecompositionPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tensor-list-ops-decomposition");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tensor-list-ops-decomposition"; }

  ::llvm::StringRef getDescription() const override { return "Decomposes TensorList operations into generic operations on tensors."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TensorListOpsDecompositionPass");
  }
  ::llvm::StringRef getName() const override { return "TensorListOpsDecompositionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TensorListOpsDecompositionPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TENSORLISTOPSDECOMPOSITIONPASS
#endif // GEN_PASS_DEF_TENSORLISTOPSDECOMPOSITIONPASS

//===----------------------------------------------------------------------===//
// TensorflowGPUFusion
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TENSORFLOWGPUFUSION
#undef GEN_PASS_DECL_TENSORFLOWGPUFUSION
#endif // GEN_PASS_DECL_TENSORFLOWGPUFUSION
#ifdef GEN_PASS_DEF_TENSORFLOWGPUFUSION
namespace impl {

template <typename DerivedT>
class TensorflowGPUFusionBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TensorflowGPUFusionBase;

  TensorflowGPUFusionBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TensorflowGPUFusionBase(const TensorflowGPUFusionBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-gpu-op-fusion");
  }
  ::llvm::StringRef getArgument() const override { return "tf-gpu-op-fusion"; }

  ::llvm::StringRef getDescription() const override { return "Fusion optimization for GPU targets"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TensorflowGPUFusion");
  }
  ::llvm::StringRef getName() const override { return "TensorflowGPUFusion"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TensorflowGPUFusionBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TENSORFLOWGPUFUSION
#endif // GEN_PASS_DEF_TENSORFLOWGPUFUSION

//===----------------------------------------------------------------------===//
// TpuV1BridgeExecutorIslandCoarseningPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TPUV1BRIDGEEXECUTORISLANDCOARSENINGPASS
#undef GEN_PASS_DECL_TPUV1BRIDGEEXECUTORISLANDCOARSENINGPASS
#endif // GEN_PASS_DECL_TPUV1BRIDGEEXECUTORISLANDCOARSENINGPASS
#ifdef GEN_PASS_DEF_TPUV1BRIDGEEXECUTORISLANDCOARSENINGPASS
namespace impl {

template <typename DerivedT>
class TpuV1BridgeExecutorIslandCoarseningPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TpuV1BridgeExecutorIslandCoarseningPassBase;

  TpuV1BridgeExecutorIslandCoarseningPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TpuV1BridgeExecutorIslandCoarseningPassBase(const TpuV1BridgeExecutorIslandCoarseningPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-executor-tpu-v1-island-coarsening");
  }
  ::llvm::StringRef getArgument() const override { return "tf-executor-tpu-v1-island-coarsening"; }

  ::llvm::StringRef getDescription() const override { return "Merges TPU clusters IslandOps, intended for V1 compatibility mode"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TpuV1BridgeExecutorIslandCoarseningPass");
  }
  ::llvm::StringRef getName() const override { return "TpuV1BridgeExecutorIslandCoarseningPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TpuV1BridgeExecutorIslandCoarseningPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TPUV1BRIDGEEXECUTORISLANDCOARSENINGPASS
#endif // GEN_PASS_DEF_TPUV1BRIDGEEXECUTORISLANDCOARSENINGPASS

//===----------------------------------------------------------------------===//
// TransformEinsumPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRANSFORMEINSUMPASS
#undef GEN_PASS_DECL_TRANSFORMEINSUMPASS
#endif // GEN_PASS_DECL_TRANSFORMEINSUMPASS
#ifdef GEN_PASS_DEF_TRANSFORMEINSUMPASS
namespace impl {

template <typename DerivedT>
class TransformEinsumPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TransformEinsumPassBase;

  TransformEinsumPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TransformEinsumPassBase(const TransformEinsumPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-einsum");
  }
  ::llvm::StringRef getArgument() const override { return "tf-einsum"; }

  ::llvm::StringRef getDescription() const override { return "Transform Einsum to other TF Ops for the supported variants"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TransformEinsumPass");
  }
  ::llvm::StringRef getName() const override { return "TransformEinsumPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TransformEinsumPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TRANSFORMEINSUMPASS
#endif // GEN_PASS_DEF_TRANSFORMEINSUMPASS

//===----------------------------------------------------------------------===//
// UnrollBatchMatMulPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_UNROLLBATCHMATMULPASS
#undef GEN_PASS_DECL_UNROLLBATCHMATMULPASS
#endif // GEN_PASS_DECL_UNROLLBATCHMATMULPASS
#ifdef GEN_PASS_DEF_UNROLLBATCHMATMULPASS
namespace impl {

template <typename DerivedT>
class UnrollBatchMatMulPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = UnrollBatchMatMulPassBase;

  UnrollBatchMatMulPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  UnrollBatchMatMulPassBase(const UnrollBatchMatMulPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-unroll-batch-matmul");
  }
  ::llvm::StringRef getArgument() const override { return "tf-unroll-batch-matmul"; }

  ::llvm::StringRef getDescription() const override { return "Unroll TF BatchMatMul op into Reshape, Slice, MatMul, Pack ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("UnrollBatchMatMulPass");
  }
  ::llvm::StringRef getName() const override { return "UnrollBatchMatMulPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(UnrollBatchMatMulPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_UNROLLBATCHMATMULPASS
#endif // GEN_PASS_DEF_UNROLLBATCHMATMULPASS

//===----------------------------------------------------------------------===//
// VerifySuitableForExportPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_VERIFYSUITABLEFOREXPORTPASS
#undef GEN_PASS_DECL_VERIFYSUITABLEFOREXPORTPASS
#endif // GEN_PASS_DECL_VERIFYSUITABLEFOREXPORTPASS
#ifdef GEN_PASS_DEF_VERIFYSUITABLEFOREXPORTPASS
namespace impl {

template <typename DerivedT>
class VerifySuitableForExportPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = VerifySuitableForExportPassBase;

  VerifySuitableForExportPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  VerifySuitableForExportPassBase(const VerifySuitableForExportPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-verify-for-export");
  }
  ::llvm::StringRef getArgument() const override { return "tf-verify-for-export"; }

  ::llvm::StringRef getDescription() const override { return "Verify module is suitable for export back to TF Graph"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("VerifySuitableForExportPass");
  }
  ::llvm::StringRef getName() const override { return "VerifySuitableForExportPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(VerifySuitableForExportPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_VERIFYSUITABLEFOREXPORTPASS
#endif // GEN_PASS_DEF_VERIFYSUITABLEFOREXPORTPASS
#ifdef GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// BatchMatMulToEinsumPass Registration
//===----------------------------------------------------------------------===//

inline void registerBatchMatMulToEinsumPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateBatchMatMulToEinsumPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerBatchMatMulToEinsumPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateBatchMatMulToEinsumPass();
  });
}

//===----------------------------------------------------------------------===//
// BreakUpIslandsPass Registration
//===----------------------------------------------------------------------===//

inline void registerBreakUpIslandsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateBreakUpIslandsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerBreakUpIslandsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateBreakUpIslandsPass();
  });
}

//===----------------------------------------------------------------------===//
// BroadcastFoldPass Registration
//===----------------------------------------------------------------------===//

inline void registerBroadcastFoldPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateBroadcastFoldPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerBroadcastFoldPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateBroadcastFoldPass();
  });
}

//===----------------------------------------------------------------------===//
// CanonicalizeCompileAndReplicateAttributesPass Registration
//===----------------------------------------------------------------------===//

inline void registerCanonicalizeCompileAndReplicateAttributesPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateCanonicalizeCompileAndReplicateAttributesPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerCanonicalizeCompileAndReplicateAttributesPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateCanonicalizeCompileAndReplicateAttributesPass();
  });
}

//===----------------------------------------------------------------------===//
// ClusterConstantSinkingPass Registration
//===----------------------------------------------------------------------===//

inline void registerClusterConstantSinkingPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFDevice::CreateClusterConstantSinkingPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerClusterConstantSinkingPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFDevice::CreateClusterConstantSinkingPass();
  });
}

//===----------------------------------------------------------------------===//
// ClusterFormationPass Registration
//===----------------------------------------------------------------------===//

inline void registerClusterFormationPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFDevice::CreateClusterFormationPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerClusterFormationPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFDevice::CreateClusterFormationPass();
  });
}

//===----------------------------------------------------------------------===//
// ClusterOutliningPass Registration
//===----------------------------------------------------------------------===//

inline void registerClusterOutliningPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFDevice::CreateClusterOutliningPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerClusterOutliningPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFDevice::CreateClusterOutliningPass();
  });
}

//===----------------------------------------------------------------------===//
// ClusterTFOpsByHostPass Registration
//===----------------------------------------------------------------------===//

inline void registerClusterTFOpsByHostPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateClusterTFOpsByHostPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerClusterTFOpsByHostPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateClusterTFOpsByHostPass();
  });
}

//===----------------------------------------------------------------------===//
// ConstantOpDeviceAssignmentPass Registration
//===----------------------------------------------------------------------===//

inline void registerConstantOpDeviceAssignmentPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateConstantOpDeviceAssignmentPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConstantOpDeviceAssignmentPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateConstantOpDeviceAssignmentPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertLaunchFuncToTFCallPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertLaunchFuncToTFCallPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFDevice::CreateConvertLaunchFuncToTFCallPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertLaunchFuncToTFCallPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFDevice::CreateConvertLaunchFuncToTFCallPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertReadonlyReferenceVariablesToResourceVariablesPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertReadonlyReferenceVariablesToResourceVariablesPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateConvertReadonlyReferenceVariablesToResourceVariablesPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertReadonlyReferenceVariablesToResourceVariablesPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateConvertReadonlyReferenceVariablesToResourceVariablesPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertTfControlFlowToScfPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertTfControlFlowToScfPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::createConvertTfControlFlowToScfPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertTfControlFlowToScfPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::createConvertTfControlFlowToScfPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertToLegacyCompileAndReplicateAttributesPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertToLegacyCompileAndReplicateAttributesPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateConvertToLegacyCompileAndReplicateAttributesPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertToLegacyCompileAndReplicateAttributesPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateConvertToLegacyCompileAndReplicateAttributesPass();
  });
}

//===----------------------------------------------------------------------===//
// DecomposeReduceDatasetPass Registration
//===----------------------------------------------------------------------===//

inline void registerDecomposeReduceDatasetPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateDecomposeReduceDatasetPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerDecomposeReduceDatasetPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateDecomposeReduceDatasetPass();
  });
}

//===----------------------------------------------------------------------===//
// DeviceIndexSelectorPass Registration
//===----------------------------------------------------------------------===//

inline void registerDeviceIndexSelectorPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateDeviceIndexSelectorPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerDeviceIndexSelectorPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateDeviceIndexSelectorPass();
  });
}

//===----------------------------------------------------------------------===//
// DropWhileShapeInvariantInDeviceClusterPass Registration
//===----------------------------------------------------------------------===//

inline void registerDropWhileShapeInvariantInDeviceClusterPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateDropWhileShapeInvariantInDeviceClusterPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerDropWhileShapeInvariantInDeviceClusterPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateDropWhileShapeInvariantInDeviceClusterPass();
  });
}

//===----------------------------------------------------------------------===//
// DropWhileShapeInvariantPass Registration
//===----------------------------------------------------------------------===//

inline void registerDropWhileShapeInvariantPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateDropWhileShapeInvariantPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerDropWhileShapeInvariantPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateDropWhileShapeInvariantPass();
  });
}

//===----------------------------------------------------------------------===//
// ExecutorCheckControlDependenciesPass Registration
//===----------------------------------------------------------------------===//

inline void registerExecutorCheckControlDependenciesPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return tf_executor::CreateTFExecutorCheckControlDependenciesPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerExecutorCheckControlDependenciesPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return tf_executor::CreateTFExecutorCheckControlDependenciesPass();
  });
}

//===----------------------------------------------------------------------===//
// ExecutorConvertControlToDataOutputsPass Registration
//===----------------------------------------------------------------------===//

inline void registerExecutorConvertControlToDataOutputsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return tf_executor::CreateTFExecutorConvertControlToDataOutputsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerExecutorConvertControlToDataOutputsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return tf_executor::CreateTFExecutorConvertControlToDataOutputsPass();
  });
}

//===----------------------------------------------------------------------===//
// ExecutorDialectToFunctionalPass Registration
//===----------------------------------------------------------------------===//

inline void registerExecutorDialectToFunctionalPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateExecutorDialectToFunctionalConversionPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerExecutorDialectToFunctionalPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateExecutorDialectToFunctionalConversionPass();
  });
}

//===----------------------------------------------------------------------===//
// ExecutorGraphPruningPass Registration
//===----------------------------------------------------------------------===//

inline void registerExecutorGraphPruningPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return tf_executor::CreateTFExecutorGraphPruningPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerExecutorGraphPruningPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return tf_executor::CreateTFExecutorGraphPruningPass();
  });
}

//===----------------------------------------------------------------------===//
// ExecutorIslandCoarseningPass Registration
//===----------------------------------------------------------------------===//

inline void registerExecutorIslandCoarseningPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return tf_executor::CreateTFExecutorIslandCoarseningPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerExecutorIslandCoarseningPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return tf_executor::CreateTFExecutorIslandCoarseningPass();
  });
}

//===----------------------------------------------------------------------===//
// ExecutorTPUV1IslandInliningPass Registration
//===----------------------------------------------------------------------===//

inline void registerExecutorTPUV1IslandInliningPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return tf_executor::CreateTFExecutorTPUV1IslandInliningPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerExecutorTPUV1IslandInliningPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return tf_executor::CreateTFExecutorTPUV1IslandInliningPass();
  });
}

//===----------------------------------------------------------------------===//
// ExecutorUpdateControlDependenciesPass Registration
//===----------------------------------------------------------------------===//

inline void registerExecutorUpdateControlDependenciesPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return tf_executor::CreateTFExecutorUpdateControlDependenciesPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerExecutorUpdateControlDependenciesPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return tf_executor::CreateTFExecutorUpdateControlDependenciesPass();
  });
}

//===----------------------------------------------------------------------===//
// FunctionalControlFlowToCFGPass Registration
//===----------------------------------------------------------------------===//

inline void registerFunctionalControlFlowToCFGPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateTFFunctionalControlFlowToCFG();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerFunctionalControlFlowToCFGPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateTFFunctionalControlFlowToCFG();
  });
}

//===----------------------------------------------------------------------===//
// FunctionalControlFlowToRegionsPass Registration
//===----------------------------------------------------------------------===//

inline void registerFunctionalControlFlowToRegionsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateTFFunctionalControlFlowToRegions();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerFunctionalControlFlowToRegionsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateTFFunctionalControlFlowToRegions();
  });
}

//===----------------------------------------------------------------------===//
// FunctionalToExecutorDialectConversionPass Registration
//===----------------------------------------------------------------------===//

inline void registerFunctionalToExecutorDialectConversionPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateFunctionalToExecutorDialectConversionPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerFunctionalToExecutorDialectConversionPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateFunctionalToExecutorDialectConversionPass();
  });
}

//===----------------------------------------------------------------------===//
// FusedKernelMatcherPass Registration
//===----------------------------------------------------------------------===//

inline void registerFusedKernelMatcherPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateFusedKernelMatcherPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerFusedKernelMatcherPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateFusedKernelMatcherPass();
  });
}

//===----------------------------------------------------------------------===//
// GroupByDialectPass Registration
//===----------------------------------------------------------------------===//

inline void registerGroupByDialectPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateGroupByDialectPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerGroupByDialectPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateGroupByDialectPass();
  });
}

//===----------------------------------------------------------------------===//
// GuaranteeAllFuncsOneUsePass Registration
//===----------------------------------------------------------------------===//

inline void registerGuaranteeAllFuncsOneUsePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateGuaranteeAllFuncsOneUsePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerGuaranteeAllFuncsOneUsePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateGuaranteeAllFuncsOneUsePass();
  });
}

//===----------------------------------------------------------------------===//
// HoistReplicateInvariantResourceWritesPass Registration
//===----------------------------------------------------------------------===//

inline void registerHoistReplicateInvariantResourceWritesPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateHoistReplicateInvariantResourceWritesPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerHoistReplicateInvariantResourceWritesPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateHoistReplicateInvariantResourceWritesPass();
  });
}

//===----------------------------------------------------------------------===//
// InitTextFileToImportPass Registration
//===----------------------------------------------------------------------===//

inline void registerInitTextFileToImportPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateInitTextFileToImportPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerInitTextFileToImportPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateInitTextFileToImportPass();
  });
}

//===----------------------------------------------------------------------===//
// LaunchOutliningPass Registration
//===----------------------------------------------------------------------===//

inline void registerLaunchOutliningPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFDevice::CreateLaunchOutliningPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLaunchOutliningPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFDevice::CreateLaunchOutliningPass();
  });
}

//===----------------------------------------------------------------------===//
// LayoutAssignmentPass Registration
//===----------------------------------------------------------------------===//

inline void registerLayoutAssignmentPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateLayoutAssignmentPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLayoutAssignmentPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateLayoutAssignmentPass();
  });
}

//===----------------------------------------------------------------------===//
// LegalizeHloToTfPass Registration
//===----------------------------------------------------------------------===//

inline void registerLegalizeHloToTfPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateLegalizeHloToTfPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLegalizeHloToTfPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateLegalizeHloToTfPass();
  });
}

//===----------------------------------------------------------------------===//
// LegalizeTFGToTFPass Registration
//===----------------------------------------------------------------------===//

inline void registerLegalizeTFGToTFPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateLegalizeTFGToTFEPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLegalizeTFGToTFPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateLegalizeTFGToTFEPass();
  });
}

//===----------------------------------------------------------------------===//
// LocalizeVarHandlesPass Registration
//===----------------------------------------------------------------------===//

inline void registerLocalizeVarHandlesPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateLocalizeVarHandlesPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLocalizeVarHandlesPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateLocalizeVarHandlesPass();
  });
}

//===----------------------------------------------------------------------===//
// LowerQuantizedPass Registration
//===----------------------------------------------------------------------===//

inline void registerLowerQuantizedPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateLowerQuantizedPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLowerQuantizedPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateLowerQuantizedPass();
  });
}

//===----------------------------------------------------------------------===//
// MarkInputOutputAliasesPass Registration
//===----------------------------------------------------------------------===//

inline void registerMarkInputOutputAliasesPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFDevice::CreateMarkInputOutputAliasesPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerMarkInputOutputAliasesPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFDevice::CreateMarkInputOutputAliasesPass();
  });
}

//===----------------------------------------------------------------------===//
// MarkOpsForOutsideCompilationPass Registration
//===----------------------------------------------------------------------===//

inline void registerMarkOpsForOutsideCompilationPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFDevice::CreateMarkOpsForOutsideCompilationPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerMarkOpsForOutsideCompilationPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFDevice::CreateMarkOpsForOutsideCompilationPass();
  });
}

//===----------------------------------------------------------------------===//
// MaterializePassthroughOp Registration
//===----------------------------------------------------------------------===//

inline void registerMaterializePassthroughOp() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateMaterializePassthroughOpPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerMaterializePassthroughOpPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateMaterializePassthroughOpPass();
  });
}

//===----------------------------------------------------------------------===//
// MergeControlFlowPass Registration
//===----------------------------------------------------------------------===//

inline void registerMergeControlFlowPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFDevice::CreateMergeControlFlowPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerMergeControlFlowPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFDevice::CreateMergeControlFlowPass();
  });
}

//===----------------------------------------------------------------------===//
// MoveTransposesPass Registration
//===----------------------------------------------------------------------===//

inline void registerMoveTransposesPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateMoveTransposesPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerMoveTransposesPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateMoveTransposesPass();
  });
}

//===----------------------------------------------------------------------===//
// NameAnonymousIteratorsPass Registration
//===----------------------------------------------------------------------===//

inline void registerNameAnonymousIteratorsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateNameAnonymousIteratorsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerNameAnonymousIteratorsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateNameAnonymousIteratorsPass();
  });
}

//===----------------------------------------------------------------------===//
// OrderByDialectPass Registration
//===----------------------------------------------------------------------===//

inline void registerOrderByDialectPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateOrderByDialectPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerOrderByDialectPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateOrderByDialectPass();
  });
}

//===----------------------------------------------------------------------===//
// OutsideCompiledToHostLaunchPass Registration
//===----------------------------------------------------------------------===//

inline void registerOutsideCompiledToHostLaunchPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateOutsideCompiledToHostLaunchPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerOutsideCompiledToHostLaunchPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateOutsideCompiledToHostLaunchPass();
  });
}

//===----------------------------------------------------------------------===//
// ParallelExecuteToIslandsPass Registration
//===----------------------------------------------------------------------===//

inline void registerParallelExecuteToIslandsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFDevice::CreateParallelExecuteToIslandsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerParallelExecuteToIslandsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFDevice::CreateParallelExecuteToIslandsPass();
  });
}

//===----------------------------------------------------------------------===//
// PrepareTpuComputationForTfExportPass Registration
//===----------------------------------------------------------------------===//

inline void registerPrepareTpuComputationForTfExportPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreatePrepareTpuComputationForTfExportPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerPrepareTpuComputationForTfExportPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreatePrepareTpuComputationForTfExportPass();
  });
}

//===----------------------------------------------------------------------===//
// PromoteResourcesToArgsPass Registration
//===----------------------------------------------------------------------===//

inline void registerPromoteResourcesToArgsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreatePromoteResourcesToArgsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerPromoteResourcesToArgsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreatePromoteResourcesToArgsPass();
  });
}

//===----------------------------------------------------------------------===//
// PromoteVarHandlesToArgsPass Registration
//===----------------------------------------------------------------------===//

inline void registerPromoteVarHandlesToArgsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreatePromoteVarHandlesToArgsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerPromoteVarHandlesToArgsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreatePromoteVarHandlesToArgsPass();
  });
}

//===----------------------------------------------------------------------===//
// RegionControlFlowToFunctionalPass Registration
//===----------------------------------------------------------------------===//

inline void registerRegionControlFlowToFunctionalPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateTFRegionControlFlowToFunctional();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerRegionControlFlowToFunctionalPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateTFRegionControlFlowToFunctional();
  });
}

//===----------------------------------------------------------------------===//
// RemoveUnusedArgumentsPass Registration
//===----------------------------------------------------------------------===//

inline void registerRemoveUnusedArgumentsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateRemoveUnusedArgumentsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerRemoveUnusedArgumentsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateRemoveUnusedArgumentsPass();
  });
}

//===----------------------------------------------------------------------===//
// RemoveUnusedWhileResultsPass Registration
//===----------------------------------------------------------------------===//

inline void registerRemoveUnusedWhileResultsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateRemoveUnusedWhileResultsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerRemoveUnusedWhileResultsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateRemoveUnusedWhileResultsPass();
  });
}

//===----------------------------------------------------------------------===//
// ReplicaIDToDeviceOrdinalPass Registration
//===----------------------------------------------------------------------===//

inline void registerReplicaIDToDeviceOrdinalPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFDevice::CreateReplicaIDToDeviceOrdinalPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerReplicaIDToDeviceOrdinalPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFDevice::CreateReplicaIDToDeviceOrdinalPass();
  });
}

//===----------------------------------------------------------------------===//
// ReplicateInvariantOpHoistingPass Registration
//===----------------------------------------------------------------------===//

inline void registerReplicateInvariantOpHoistingPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFDevice::CreateReplicateInvariantOpHoistingPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerReplicateInvariantOpHoistingPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFDevice::CreateReplicateInvariantOpHoistingPass();
  });
}

//===----------------------------------------------------------------------===//
// ReplicateToIslandPass Registration
//===----------------------------------------------------------------------===//

inline void registerReplicateToIslandPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFDevice::CreateReplicateToIslandPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerReplicateToIslandPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFDevice::CreateReplicateToIslandPass();
  });
}

//===----------------------------------------------------------------------===//
// ResourceDeviceInferencePass Registration
//===----------------------------------------------------------------------===//

inline void registerResourceDeviceInferencePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateResourceDeviceInferencePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerResourceDeviceInferencePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateResourceDeviceInferencePass();
  });
}

//===----------------------------------------------------------------------===//
// RewriteTPUEmbeddingOpsPass Registration
//===----------------------------------------------------------------------===//

inline void registerRewriteTPUEmbeddingOpsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateRewriteTPUEmbeddingOpsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerRewriteTPUEmbeddingOpsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateRewriteTPUEmbeddingOpsPass();
  });
}

//===----------------------------------------------------------------------===//
// SimpleTFDeviceAssignmentPass Registration
//===----------------------------------------------------------------------===//

inline void registerSimpleTFDeviceAssignmentPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateSimpleTFDeviceAssignmentPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerSimpleTFDeviceAssignmentPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateSimpleTFDeviceAssignmentPass();
  });
}

//===----------------------------------------------------------------------===//
// SplitIntoIslandPerOpPass Registration
//===----------------------------------------------------------------------===//

inline void registerSplitIntoIslandPerOpPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::CreateSplitIntoIslandPerOpPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerSplitIntoIslandPerOpPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::CreateSplitIntoIslandPerOpPass();
  });
}

//===----------------------------------------------------------------------===//
// StackOpsDecompositionPass Registration
//===----------------------------------------------------------------------===//

inline void registerStackOpsDecompositionPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateStackOpsDecompositionPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerStackOpsDecompositionPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateStackOpsDecompositionPass();
  });
}

//===----------------------------------------------------------------------===//
// StripNoinlineAttributePass Registration
//===----------------------------------------------------------------------===//

inline void registerStripNoinlineAttributePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateStripNoinlineAttributePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerStripNoinlineAttributePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateStripNoinlineAttributePass();
  });
}

//===----------------------------------------------------------------------===//
// StripTfAttributesPass Registration
//===----------------------------------------------------------------------===//

inline void registerStripTfAttributesPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateStripTfAttributesPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerStripTfAttributesPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateStripTfAttributesPass();
  });
}

//===----------------------------------------------------------------------===//
// TFDataOptimizationPass Registration
//===----------------------------------------------------------------------===//

inline void registerTFDataOptimizationPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateTFDataOptimizationPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTFDataOptimizationPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateTFDataOptimizationPass();
  });
}

//===----------------------------------------------------------------------===//
// TFDeviceAssignmentByFuncAttrPass Registration
//===----------------------------------------------------------------------===//

inline void registerTFDeviceAssignmentByFuncAttrPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateTFDeviceAssignmentByFuncAttrPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTFDeviceAssignmentByFuncAttrPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateTFDeviceAssignmentByFuncAttrPass();
  });
}

//===----------------------------------------------------------------------===//
// TPUBridgeExecutorIslandOutliningPass Registration
//===----------------------------------------------------------------------===//

inline void registerTPUBridgeExecutorIslandOutliningPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return tf_executor::CreateTFExecutorTPUV1IslandOutliningPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTPUBridgeExecutorIslandOutliningPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return tf_executor::CreateTFExecutorTPUV1IslandOutliningPass();
  });
}

//===----------------------------------------------------------------------===//
// TPUCleanupClusterAttributesPass Registration
//===----------------------------------------------------------------------===//

inline void registerTPUCleanupClusterAttributesPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUClusterCleanupAttributesPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTPUCleanupClusterAttributesPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUClusterCleanupAttributesPass();
  });
}

//===----------------------------------------------------------------------===//
// TPUClusterFormationPass Registration
//===----------------------------------------------------------------------===//

inline void registerTPUClusterFormationPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUClusterFormationPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTPUClusterFormationPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUClusterFormationPass();
  });
}

//===----------------------------------------------------------------------===//
// TPUColocateCompositeResourceOpsPass Registration
//===----------------------------------------------------------------------===//

inline void registerTPUColocateCompositeResourceOpsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUColocateCompositeResourceOps();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTPUColocateCompositeResourceOpsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUColocateCompositeResourceOps();
  });
}

//===----------------------------------------------------------------------===//
// TPUDevicePropagationPass Registration
//===----------------------------------------------------------------------===//

inline void registerTPUDevicePropagationPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUDevicePropagationPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTPUDevicePropagationPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUDevicePropagationPass();
  });
}

//===----------------------------------------------------------------------===//
// TPUDynamicLayoutPass Registration
//===----------------------------------------------------------------------===//

inline void registerTPUDynamicLayoutPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUDynamicLayoutPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTPUDynamicLayoutPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUDynamicLayoutPass();
  });
}

//===----------------------------------------------------------------------===//
// TPUExtractHeadTailOutsideCompilationPass Registration
//===----------------------------------------------------------------------===//

inline void registerTPUExtractHeadTailOutsideCompilationPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUExtractHeadTailOutsideCompilationPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTPUExtractHeadTailOutsideCompilationPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUExtractHeadTailOutsideCompilationPass();
  });
}

//===----------------------------------------------------------------------===//
// TPUExtractOutsideCompilationPass Registration
//===----------------------------------------------------------------------===//

inline void registerTPUExtractOutsideCompilationPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUExtractOutsideCompilationPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTPUExtractOutsideCompilationPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUExtractOutsideCompilationPass();
  });
}

//===----------------------------------------------------------------------===//
// TPUHostComputationExpansionPass Registration
//===----------------------------------------------------------------------===//

inline void registerTPUHostComputationExpansionPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUHostComputationExpansionPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTPUHostComputationExpansionPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUHostComputationExpansionPass();
  });
}

//===----------------------------------------------------------------------===//
// TPUIdentityPruningPass Registration
//===----------------------------------------------------------------------===//

inline void registerTPUIdentityPruningPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUIdentityPruningPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTPUIdentityPruningPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUIdentityPruningPass();
  });
}

//===----------------------------------------------------------------------===//
// TPUMergeVariablesWithExecutePass Registration
//===----------------------------------------------------------------------===//

inline void registerTPUMergeVariablesWithExecutePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUMergeVariablesWithExecutePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTPUMergeVariablesWithExecutePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUMergeVariablesWithExecutePass();
  });
}

//===----------------------------------------------------------------------===//
// TPUParallelExecuteSinkResourceWritePass Registration
//===----------------------------------------------------------------------===//

inline void registerTPUParallelExecuteSinkResourceWritePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUParallelExecuteSinkResourceWritePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTPUParallelExecuteSinkResourceWritePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUParallelExecuteSinkResourceWritePass();
  });
}

//===----------------------------------------------------------------------===//
// TPUReorderReplicateAndPartitionedInputsPass Registration
//===----------------------------------------------------------------------===//

inline void registerTPUReorderReplicateAndPartitionedInputsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUReorderReplicateAndPartitionedInputsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTPUReorderReplicateAndPartitionedInputsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUReorderReplicateAndPartitionedInputsPass();
  });
}

//===----------------------------------------------------------------------===//
// TPUResourceReadForWritePass Registration
//===----------------------------------------------------------------------===//

inline void registerTPUResourceReadForWritePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUResourceReadForWritePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTPUResourceReadForWritePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUResourceReadForWritePass();
  });
}

//===----------------------------------------------------------------------===//
// TPUResourceReadsWritesPartitioningPass Registration
//===----------------------------------------------------------------------===//

inline void registerTPUResourceReadsWritesPartitioningPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUResourceReadsWritesPartitioningPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTPUResourceReadsWritesPartitioningPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUResourceReadsWritesPartitioningPass();
  });
}

//===----------------------------------------------------------------------===//
// TPURewritePass Registration
//===----------------------------------------------------------------------===//

inline void registerTPURewritePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPURewritePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTPURewritePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPURewritePass();
  });
}

//===----------------------------------------------------------------------===//
// TPUShardingIdentificationPass Registration
//===----------------------------------------------------------------------===//

inline void registerTPUShardingIdentificationPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUShardingIdentificationPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTPUShardingIdentificationPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUShardingIdentificationPass();
  });
}

//===----------------------------------------------------------------------===//
// TPUSpaceToDepthPass Registration
//===----------------------------------------------------------------------===//

inline void registerTPUSpaceToDepthPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUSpaceToDepthPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTPUSpaceToDepthPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUSpaceToDepthPass();
  });
}

//===----------------------------------------------------------------------===//
// TPUUpdateEmbeddingEnqueueOpInputsPass Registration
//===----------------------------------------------------------------------===//

inline void registerTPUUpdateEmbeddingEnqueueOpInputsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUUpdateEmbeddingEnqueueOpInputsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTPUUpdateEmbeddingEnqueueOpInputsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUUpdateEmbeddingEnqueueOpInputsPass();
  });
}

//===----------------------------------------------------------------------===//
// TPUVariableRuntimeReformattingPass Registration
//===----------------------------------------------------------------------===//

inline void registerTPUVariableRuntimeReformattingPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUVariableRuntimeReformattingPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTPUVariableRuntimeReformattingPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TFTPU::CreateTPUVariableRuntimeReformattingPass();
  });
}

//===----------------------------------------------------------------------===//
// TensorArrayOpsDecompositionPass Registration
//===----------------------------------------------------------------------===//

inline void registerTensorArrayOpsDecompositionPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateTensorArrayOpsDecompositionPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTensorArrayOpsDecompositionPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateTensorArrayOpsDecompositionPass();
  });
}

//===----------------------------------------------------------------------===//
// TensorDeviceCopyConversionPass Registration
//===----------------------------------------------------------------------===//

inline void registerTensorDeviceCopyConversionPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateTensorDeviceCopyConversionPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTensorDeviceCopyConversionPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateTensorDeviceCopyConversionPass();
  });
}

//===----------------------------------------------------------------------===//
// TensorFlowOptimizePass Registration
//===----------------------------------------------------------------------===//

inline void registerTensorFlowOptimizePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateTFOptimizePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTensorFlowOptimizePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateTFOptimizePass();
  });
}

//===----------------------------------------------------------------------===//
// TensorFlowShapeInferencePass Registration
//===----------------------------------------------------------------------===//

inline void registerTensorFlowShapeInferencePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateTFShapeInferencePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTensorFlowShapeInferencePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateTFShapeInferencePass();
  });
}

//===----------------------------------------------------------------------===//
// TensorListOpsDecompositionPass Registration
//===----------------------------------------------------------------------===//

inline void registerTensorListOpsDecompositionPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateTensorListOpsDecompositionPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTensorListOpsDecompositionPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateTensorListOpsDecompositionPass();
  });
}

//===----------------------------------------------------------------------===//
// TensorflowGPUFusion Registration
//===----------------------------------------------------------------------===//

inline void registerTensorflowGPUFusion() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateGpuOpFusionPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTensorflowGPUFusionPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateGpuOpFusionPass();
  });
}

//===----------------------------------------------------------------------===//
// TpuV1BridgeExecutorIslandCoarseningPass Registration
//===----------------------------------------------------------------------===//

inline void registerTpuV1BridgeExecutorIslandCoarseningPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return tf_executor::CreateTFExecutorTPUV1IslandCoarseningPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTpuV1BridgeExecutorIslandCoarseningPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return tf_executor::CreateTFExecutorTPUV1IslandCoarseningPass();
  });
}

//===----------------------------------------------------------------------===//
// TransformEinsumPass Registration
//===----------------------------------------------------------------------===//

inline void registerTransformEinsumPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateTransformEinsumPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTransformEinsumPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateTransformEinsumPass();
  });
}

//===----------------------------------------------------------------------===//
// UnrollBatchMatMulPass Registration
//===----------------------------------------------------------------------===//

inline void registerUnrollBatchMatMulPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateUnrollBatchMatMulPassPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerUnrollBatchMatMulPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateUnrollBatchMatMulPassPass();
  });
}

//===----------------------------------------------------------------------===//
// VerifySuitableForExportPass Registration
//===----------------------------------------------------------------------===//

inline void registerVerifySuitableForExportPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateVerifySuitableForExportPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerVerifySuitableForExportPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return TF::CreateVerifySuitableForExportPass();
  });
}

//===----------------------------------------------------------------------===//
// TensorFlow Registration
//===----------------------------------------------------------------------===//

inline void registerTensorFlowPasses() {
  registerBatchMatMulToEinsumPass();
  registerBreakUpIslandsPass();
  registerBroadcastFoldPass();
  registerCanonicalizeCompileAndReplicateAttributesPass();
  registerClusterConstantSinkingPass();
  registerClusterFormationPass();
  registerClusterOutliningPass();
  registerClusterTFOpsByHostPass();
  registerConstantOpDeviceAssignmentPass();
  registerConvertLaunchFuncToTFCallPass();
  registerConvertReadonlyReferenceVariablesToResourceVariablesPass();
  registerConvertTfControlFlowToScfPass();
  registerConvertToLegacyCompileAndReplicateAttributesPass();
  registerDecomposeReduceDatasetPass();
  registerDeviceIndexSelectorPass();
  registerDropWhileShapeInvariantInDeviceClusterPass();
  registerDropWhileShapeInvariantPass();
  registerExecutorCheckControlDependenciesPass();
  registerExecutorConvertControlToDataOutputsPass();
  registerExecutorDialectToFunctionalPass();
  registerExecutorGraphPruningPass();
  registerExecutorIslandCoarseningPass();
  registerExecutorTPUV1IslandInliningPass();
  registerExecutorUpdateControlDependenciesPass();
  registerFunctionalControlFlowToCFGPass();
  registerFunctionalControlFlowToRegionsPass();
  registerFunctionalToExecutorDialectConversionPass();
  registerFusedKernelMatcherPass();
  registerGroupByDialectPass();
  registerGuaranteeAllFuncsOneUsePass();
  registerHoistReplicateInvariantResourceWritesPass();
  registerInitTextFileToImportPass();
  registerLaunchOutliningPass();
  registerLayoutAssignmentPass();
  registerLegalizeHloToTfPass();
  registerLegalizeTFGToTFPass();
  registerLocalizeVarHandlesPass();
  registerLowerQuantizedPass();
  registerMarkInputOutputAliasesPass();
  registerMarkOpsForOutsideCompilationPass();
  registerMaterializePassthroughOp();
  registerMergeControlFlowPass();
  registerMoveTransposesPass();
  registerNameAnonymousIteratorsPass();
  registerOrderByDialectPass();
  registerOutsideCompiledToHostLaunchPass();
  registerParallelExecuteToIslandsPass();
  registerPrepareTpuComputationForTfExportPass();
  registerPromoteResourcesToArgsPass();
  registerPromoteVarHandlesToArgsPass();
  registerRegionControlFlowToFunctionalPass();
  registerRemoveUnusedArgumentsPass();
  registerRemoveUnusedWhileResultsPass();
  registerReplicaIDToDeviceOrdinalPass();
  registerReplicateInvariantOpHoistingPass();
  registerReplicateToIslandPass();
  registerResourceDeviceInferencePass();
  registerRewriteTPUEmbeddingOpsPass();
  registerSimpleTFDeviceAssignmentPass();
  registerSplitIntoIslandPerOpPass();
  registerStackOpsDecompositionPass();
  registerStripNoinlineAttributePass();
  registerStripTfAttributesPass();
  registerTFDataOptimizationPass();
  registerTFDeviceAssignmentByFuncAttrPass();
  registerTPUBridgeExecutorIslandOutliningPass();
  registerTPUCleanupClusterAttributesPass();
  registerTPUClusterFormationPass();
  registerTPUColocateCompositeResourceOpsPass();
  registerTPUDevicePropagationPass();
  registerTPUDynamicLayoutPass();
  registerTPUExtractHeadTailOutsideCompilationPass();
  registerTPUExtractOutsideCompilationPass();
  registerTPUHostComputationExpansionPass();
  registerTPUIdentityPruningPass();
  registerTPUMergeVariablesWithExecutePass();
  registerTPUParallelExecuteSinkResourceWritePass();
  registerTPUReorderReplicateAndPartitionedInputsPass();
  registerTPUResourceReadForWritePass();
  registerTPUResourceReadsWritesPartitioningPass();
  registerTPURewritePass();
  registerTPUShardingIdentificationPass();
  registerTPUSpaceToDepthPass();
  registerTPUUpdateEmbeddingEnqueueOpInputsPass();
  registerTPUVariableRuntimeReformattingPass();
  registerTensorArrayOpsDecompositionPass();
  registerTensorDeviceCopyConversionPass();
  registerTensorFlowOptimizePass();
  registerTensorFlowShapeInferencePass();
  registerTensorListOpsDecompositionPass();
  registerTensorflowGPUFusion();
  registerTpuV1BridgeExecutorIslandCoarseningPass();
  registerTransformEinsumPass();
  registerUnrollBatchMatMulPass();
  registerVerifySuitableForExportPass();
}
#undef GEN_PASS_REGISTRATION
#endif // GEN_PASS_REGISTRATION
// Deprecated. Please use the new per-pass macros.
#ifdef GEN_PASS_CLASSES

template <typename DerivedT>
class BatchMatMulToEinsumPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = BatchMatMulToEinsumPassBase;

  BatchMatMulToEinsumPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  BatchMatMulToEinsumPassBase(const BatchMatMulToEinsumPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-batch-matmul-to-tf-einsum");
  }
  ::llvm::StringRef getArgument() const override { return "tf-batch-matmul-to-tf-einsum"; }

  ::llvm::StringRef getDescription() const override { return "Replace TF BatchMatMul op by TF Einsum op."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("BatchMatMulToEinsumPass");
  }
  ::llvm::StringRef getName() const override { return "BatchMatMulToEinsumPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(BatchMatMulToEinsumPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class BreakUpIslandsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = BreakUpIslandsPassBase;

  BreakUpIslandsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  BreakUpIslandsPassBase(const BreakUpIslandsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-executor-break-up-islands");
  }
  ::llvm::StringRef getArgument() const override { return "tf-executor-break-up-islands"; }

  ::llvm::StringRef getDescription() const override { return "Transform from TF control dialect to TF executor dialect."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("BreakUpIslandsPass");
  }
  ::llvm::StringRef getName() const override { return "BreakUpIslandsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<mlir::tf_executor::TensorFlowExecutorDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(BreakUpIslandsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class BroadcastFoldPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = BroadcastFoldPassBase;

  BroadcastFoldPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  BroadcastFoldPassBase(const BroadcastFoldPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-broadcast-fold");
  }
  ::llvm::StringRef getArgument() const override { return "tf-broadcast-fold"; }

  ::llvm::StringRef getDescription() const override { return "Fold explicit broadcasts into the following operations if they support implicit broadcasting on their operand."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("BroadcastFoldPass");
  }
  ::llvm::StringRef getName() const override { return "BroadcastFoldPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(BroadcastFoldPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class CanonicalizeCompileAndReplicateAttributesPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = CanonicalizeCompileAndReplicateAttributesPassBase;

  CanonicalizeCompileAndReplicateAttributesPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  CanonicalizeCompileAndReplicateAttributesPassBase(const CanonicalizeCompileAndReplicateAttributesPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-canonicalize-compile-and-replicate-attributes");
  }
  ::llvm::StringRef getArgument() const override { return "tf-canonicalize-compile-and-replicate-attributes"; }

  ::llvm::StringRef getDescription() const override { return "Canonicalize compilation and replication attributes."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("CanonicalizeCompileAndReplicateAttributesPass");
  }
  ::llvm::StringRef getName() const override { return "CanonicalizeCompileAndReplicateAttributesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(CanonicalizeCompileAndReplicateAttributesPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ClusterConstantSinkingPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ClusterConstantSinkingPassBase;

  ClusterConstantSinkingPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ClusterConstantSinkingPassBase(const ClusterConstantSinkingPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-device-constant-sinking");
  }
  ::llvm::StringRef getArgument() const override { return "tf-device-constant-sinking"; }

  ::llvm::StringRef getDescription() const override { return "Sinks constants implicitly captured in a tf_device.cluster region."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ClusterConstantSinkingPass");
  }
  ::llvm::StringRef getName() const override { return "ClusterConstantSinkingPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ClusterConstantSinkingPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ClusterFormationPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ClusterFormationPassBase;

  ClusterFormationPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ClusterFormationPassBase(const ClusterFormationPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-device-cluster-formation");
  }
  ::llvm::StringRef getArgument() const override { return "tf-device-cluster-formation"; }

  ::llvm::StringRef getDescription() const override { return "Form clusters from instructions assigned to same device"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ClusterFormationPass");
  }
  ::llvm::StringRef getName() const override { return "ClusterFormationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<tf_device::TensorFlowDeviceDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ClusterFormationPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ClusterOutliningPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ClusterOutliningPassBase;

  ClusterOutliningPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ClusterOutliningPassBase(const ClusterOutliningPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-device-cluster-outlining");
  }
  ::llvm::StringRef getArgument() const override { return "tf-device-cluster-outlining"; }

  ::llvm::StringRef getDescription() const override { return "Outlines regions of tf_device.cluster operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ClusterOutliningPass");
  }
  ::llvm::StringRef getName() const override { return "ClusterOutliningPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ClusterOutliningPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ClusterTFOpsByHostPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ClusterTFOpsByHostPassBase;

  ClusterTFOpsByHostPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ClusterTFOpsByHostPassBase(const ClusterTFOpsByHostPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("cluster-tf-ops-by-host");
  }
  ::llvm::StringRef getArgument() const override { return "cluster-tf-ops-by-host"; }

  ::llvm::StringRef getDescription() const override { return "Cluster the TensorFlow ops by host so that each function only contains ops placed on the same host"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ClusterTFOpsByHostPass");
  }
  ::llvm::StringRef getName() const override { return "ClusterTFOpsByHostPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ClusterTFOpsByHostPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ConstantOpDeviceAssignmentPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ConstantOpDeviceAssignmentPassBase;

  ConstantOpDeviceAssignmentPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConstantOpDeviceAssignmentPassBase(const ConstantOpDeviceAssignmentPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("constant-op-device-assignment");
  }
  ::llvm::StringRef getArgument() const override { return "constant-op-device-assignment"; }

  ::llvm::StringRef getDescription() const override { return "Assign device for tf.Const ops"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConstantOpDeviceAssignmentPass");
  }
  ::llvm::StringRef getName() const override { return "ConstantOpDeviceAssignmentPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConstantOpDeviceAssignmentPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ConvertLaunchFuncToTFCallPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ConvertLaunchFuncToTFCallPassBase;

  ConvertLaunchFuncToTFCallPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertLaunchFuncToTFCallPassBase(const ConvertLaunchFuncToTFCallPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-device-convert-launch-func-to-tf-call");
  }
  ::llvm::StringRef getArgument() const override { return "tf-device-convert-launch-func-to-tf-call"; }

  ::llvm::StringRef getDescription() const override { return "Rewrites tf_device::LaunchFuncOp to TF::PartitionedCallOp"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertLaunchFuncToTFCallPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertLaunchFuncToTFCallPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertLaunchFuncToTFCallPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ConvertReadonlyReferenceVariablesToResourceVariablesPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ConvertReadonlyReferenceVariablesToResourceVariablesPassBase;

  ConvertReadonlyReferenceVariablesToResourceVariablesPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertReadonlyReferenceVariablesToResourceVariablesPassBase(const ConvertReadonlyReferenceVariablesToResourceVariablesPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-readonly-references-to-resources");
  }
  ::llvm::StringRef getArgument() const override { return "tf-readonly-references-to-resources"; }

  ::llvm::StringRef getDescription() const override { return "Convert readonly reference variables to resource variables."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertReadonlyReferenceVariablesToResourceVariablesPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertReadonlyReferenceVariablesToResourceVariablesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertReadonlyReferenceVariablesToResourceVariablesPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ConvertTfControlFlowToScfPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ConvertTfControlFlowToScfPassBase;

  ConvertTfControlFlowToScfPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertTfControlFlowToScfPassBase(const ConvertTfControlFlowToScfPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-tf-control-flow-to-scf");
  }
  ::llvm::StringRef getArgument() const override { return "convert-tf-control-flow-to-scf"; }

  ::llvm::StringRef getDescription() const override { return "Convert TensorFlow control flow to SCF."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertTfControlFlowToScfPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertTfControlFlowToScfPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<scf::SCFDialect>();

  registry.insert<tensor::TensorDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertTfControlFlowToScfPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ConvertToLegacyCompileAndReplicateAttributesPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ConvertToLegacyCompileAndReplicateAttributesPassBase;

  ConvertToLegacyCompileAndReplicateAttributesPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertToLegacyCompileAndReplicateAttributesPassBase(const ConvertToLegacyCompileAndReplicateAttributesPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-convert-to-legacy-compile-and-replicate-attributes");
  }
  ::llvm::StringRef getArgument() const override { return "tf-convert-to-legacy-compile-and-replicate-attributes"; }

  ::llvm::StringRef getDescription() const override { return "Convert unified compilation and replication attributes back to legacy attributes."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertToLegacyCompileAndReplicateAttributesPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertToLegacyCompileAndReplicateAttributesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertToLegacyCompileAndReplicateAttributesPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class DecomposeReduceDatasetPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = DecomposeReduceDatasetPassBase;

  DecomposeReduceDatasetPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  DecomposeReduceDatasetPassBase(const DecomposeReduceDatasetPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-decompose-reduce-dataset");
  }
  ::llvm::StringRef getArgument() const override { return "tf-decompose-reduce-dataset"; }

  ::llvm::StringRef getDescription() const override { return "Decomposes ReduceDataset op into dataset operations."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("DecomposeReduceDatasetPass");
  }
  ::llvm::StringRef getName() const override { return "DecomposeReduceDatasetPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(DecomposeReduceDatasetPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class DeviceIndexSelectorPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = DeviceIndexSelectorPassBase;

  DeviceIndexSelectorPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  DeviceIndexSelectorPassBase(const DeviceIndexSelectorPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-device-index-selector");
  }
  ::llvm::StringRef getArgument() const override { return "tf-device-index-selector"; }

  ::llvm::StringRef getDescription() const override { return "Fold tf.DeviceIndex to constant."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("DeviceIndexSelectorPass");
  }
  ::llvm::StringRef getName() const override { return "DeviceIndexSelectorPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(DeviceIndexSelectorPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class DropWhileShapeInvariantInDeviceClusterPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = DropWhileShapeInvariantInDeviceClusterPassBase;

  DropWhileShapeInvariantInDeviceClusterPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  DropWhileShapeInvariantInDeviceClusterPassBase(const DropWhileShapeInvariantInDeviceClusterPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-drop-while-shape-invariant-in-device-cluster");
  }
  ::llvm::StringRef getArgument() const override { return "tf-drop-while-shape-invariant-in-device-cluster"; }

  ::llvm::StringRef getDescription() const override { return "Drop `shape_invariant` attribute from While/WhileRegion ops inside device cluster."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("DropWhileShapeInvariantInDeviceClusterPass");
  }
  ::llvm::StringRef getName() const override { return "DropWhileShapeInvariantInDeviceClusterPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(DropWhileShapeInvariantInDeviceClusterPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class DropWhileShapeInvariantPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = DropWhileShapeInvariantPassBase;

  DropWhileShapeInvariantPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  DropWhileShapeInvariantPassBase(const DropWhileShapeInvariantPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-drop-while-shape-invariant");
  }
  ::llvm::StringRef getArgument() const override { return "tf-drop-while-shape-invariant"; }

  ::llvm::StringRef getDescription() const override { return "Drop `shape_invariant` attribute from While/WhileRegion ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("DropWhileShapeInvariantPass");
  }
  ::llvm::StringRef getName() const override { return "DropWhileShapeInvariantPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(DropWhileShapeInvariantPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ExecutorCheckControlDependenciesPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ExecutorCheckControlDependenciesPassBase;

  ExecutorCheckControlDependenciesPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ExecutorCheckControlDependenciesPassBase(const ExecutorCheckControlDependenciesPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-executor-check-control-dependencies");
  }
  ::llvm::StringRef getArgument() const override { return "tf-executor-check-control-dependencies"; }

  ::llvm::StringRef getDescription() const override { return "Checks control dependencies"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ExecutorCheckControlDependenciesPass");
  }
  ::llvm::StringRef getName() const override { return "ExecutorCheckControlDependenciesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ExecutorCheckControlDependenciesPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ExecutorConvertControlToDataOutputsPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ExecutorConvertControlToDataOutputsPassBase;

  ExecutorConvertControlToDataOutputsPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ExecutorConvertControlToDataOutputsPassBase(const ExecutorConvertControlToDataOutputsPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-executor-convert-control-to-data-outputs");
  }
  ::llvm::StringRef getArgument() const override { return "tf-executor-convert-control-to-data-outputs"; }

  ::llvm::StringRef getDescription() const override { return "Chain control outputs of while loop body"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ExecutorConvertControlToDataOutputsPass");
  }
  ::llvm::StringRef getName() const override { return "ExecutorConvertControlToDataOutputsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ExecutorConvertControlToDataOutputsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ExecutorDialectToFunctionalPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ExecutorDialectToFunctionalPassBase;

  ExecutorDialectToFunctionalPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ExecutorDialectToFunctionalPassBase(const ExecutorDialectToFunctionalPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-executor-to-functional-conversion");
  }
  ::llvm::StringRef getArgument() const override { return "tf-executor-to-functional-conversion"; }

  ::llvm::StringRef getDescription() const override { return "Lifts tf_executor.island inner ops from a tf_executor.graph"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ExecutorDialectToFunctionalPass");
  }
  ::llvm::StringRef getName() const override { return "ExecutorDialectToFunctionalPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ExecutorDialectToFunctionalPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ExecutorGraphPruningPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ExecutorGraphPruningPassBase;

  ExecutorGraphPruningPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ExecutorGraphPruningPassBase(const ExecutorGraphPruningPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-executor-graph-pruning");
  }
  ::llvm::StringRef getArgument() const override { return "tf-executor-graph-pruning"; }

  ::llvm::StringRef getDescription() const override { return "Prunes unreachable ops in a tf_executor.graph"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ExecutorGraphPruningPass");
  }
  ::llvm::StringRef getName() const override { return "ExecutorGraphPruningPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ExecutorGraphPruningPassBase<DerivedT>)

protected:
  ::mlir::Pass::ListOption<std::string> ops_to_preserve_{*this, "ops-to-preserve", ::llvm::cl::desc("Comma separated list of ops that should not be pruned regardless of reachability")};
};

template <typename DerivedT>
class ExecutorIslandCoarseningPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ExecutorIslandCoarseningPassBase;

  ExecutorIslandCoarseningPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ExecutorIslandCoarseningPassBase(const ExecutorIslandCoarseningPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-executor-island-coarsening");
  }
  ::llvm::StringRef getArgument() const override { return "tf-executor-island-coarsening"; }

  ::llvm::StringRef getDescription() const override { return "Walks tf_executor::GraphOp and merges individual tf_executor::IslandOps."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ExecutorIslandCoarseningPass");
  }
  ::llvm::StringRef getName() const override { return "ExecutorIslandCoarseningPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ExecutorIslandCoarseningPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ExecutorTPUV1IslandInliningPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ExecutorTPUV1IslandInliningPassBase;

  ExecutorTPUV1IslandInliningPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ExecutorTPUV1IslandInliningPassBase(const ExecutorTPUV1IslandInliningPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-executor-tpu-v1-island-inlining");
  }
  ::llvm::StringRef getArgument() const override { return "tf-executor-tpu-v1-island-inlining"; }

  ::llvm::StringRef getDescription() const override { return "Inline calls to the nested TPU module."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ExecutorTPUV1IslandInliningPass");
  }
  ::llvm::StringRef getName() const override { return "ExecutorTPUV1IslandInliningPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ExecutorTPUV1IslandInliningPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ExecutorUpdateControlDependenciesPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ExecutorUpdateControlDependenciesPassBase;

  ExecutorUpdateControlDependenciesPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ExecutorUpdateControlDependenciesPassBase(const ExecutorUpdateControlDependenciesPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-executor-update-control-dependencies");
  }
  ::llvm::StringRef getArgument() const override { return "tf-executor-update-control-dependencies"; }

  ::llvm::StringRef getDescription() const override { return "Computes and applies all necessary control dependencies based on side effect analysis."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ExecutorUpdateControlDependenciesPass");
  }
  ::llvm::StringRef getName() const override { return "ExecutorUpdateControlDependenciesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ExecutorUpdateControlDependenciesPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class FunctionalControlFlowToCFGPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = FunctionalControlFlowToCFGPassBase;

  FunctionalControlFlowToCFGPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  FunctionalControlFlowToCFGPassBase(const FunctionalControlFlowToCFGPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-functional-control-flow-to-cfg");
  }
  ::llvm::StringRef getArgument() const override { return "tf-functional-control-flow-to-cfg"; }

  ::llvm::StringRef getDescription() const override { return "Transform functional control flow Ops to MLIR Control Form Graph (CFG) form"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("FunctionalControlFlowToCFGPass");
  }
  ::llvm::StringRef getName() const override { return "FunctionalControlFlowToCFGPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<tensor::TensorDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(FunctionalControlFlowToCFGPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class FunctionalControlFlowToRegionsPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = FunctionalControlFlowToRegionsPassBase;

  FunctionalControlFlowToRegionsPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  FunctionalControlFlowToRegionsPassBase(const FunctionalControlFlowToRegionsPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-functional-control-flow-to-regions");
  }
  ::llvm::StringRef getArgument() const override { return "tf-functional-control-flow-to-regions"; }

  ::llvm::StringRef getDescription() const override { return "Transforms functional control flow operations to their region-based counterparts"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("FunctionalControlFlowToRegionsPass");
  }
  ::llvm::StringRef getName() const override { return "FunctionalControlFlowToRegionsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(FunctionalControlFlowToRegionsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class FunctionalToExecutorDialectConversionPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = FunctionalToExecutorDialectConversionPassBase;

  FunctionalToExecutorDialectConversionPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  FunctionalToExecutorDialectConversionPassBase(const FunctionalToExecutorDialectConversionPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-functional-to-executor-conversion");
  }
  ::llvm::StringRef getArgument() const override { return "tf-functional-to-executor-conversion"; }

  ::llvm::StringRef getDescription() const override { return "Transform from func op to TF executor dialect."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("FunctionalToExecutorDialectConversionPass");
  }
  ::llvm::StringRef getName() const override { return "FunctionalToExecutorDialectConversionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<mlir::tf_executor::TensorFlowExecutorDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(FunctionalToExecutorDialectConversionPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class FusedKernelMatcherPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = FusedKernelMatcherPassBase;

  FusedKernelMatcherPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  FusedKernelMatcherPassBase(const FusedKernelMatcherPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-fused-kernel-matcher");
  }
  ::llvm::StringRef getArgument() const override { return "tf-fused-kernel-matcher"; }

  ::llvm::StringRef getDescription() const override { return "Matches computations corresponding to optimized fused kernels"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("FusedKernelMatcherPass");
  }
  ::llvm::StringRef getName() const override { return "FusedKernelMatcherPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(FusedKernelMatcherPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class GroupByDialectPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = GroupByDialectPassBase;

  GroupByDialectPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  GroupByDialectPassBase(const GroupByDialectPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-group-by-dialect");
  }
  ::llvm::StringRef getArgument() const override { return "tf-group-by-dialect"; }

  ::llvm::StringRef getDescription() const override { return "Groups ops into functions that only contain one dialect."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("GroupByDialectPass");
  }
  ::llvm::StringRef getName() const override { return "GroupByDialectPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(GroupByDialectPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class GuaranteeAllFuncsOneUsePassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = GuaranteeAllFuncsOneUsePassBase;

  GuaranteeAllFuncsOneUsePassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  GuaranteeAllFuncsOneUsePassBase(const GuaranteeAllFuncsOneUsePassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-guarantee-all-funcs-one-use");
  }
  ::llvm::StringRef getArgument() const override { return "tf-guarantee-all-funcs-one-use"; }

  ::llvm::StringRef getDescription() const override { return "Guarantee all FuncOp's have only a single use."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("GuaranteeAllFuncsOneUsePass");
  }
  ::llvm::StringRef getName() const override { return "GuaranteeAllFuncsOneUsePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(GuaranteeAllFuncsOneUsePassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class HoistReplicateInvariantResourceWritesPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = HoistReplicateInvariantResourceWritesPassBase;

  HoistReplicateInvariantResourceWritesPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  HoistReplicateInvariantResourceWritesPassBase(const HoistReplicateInvariantResourceWritesPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-hoist-replicate-invariant-resource-writes");
  }
  ::llvm::StringRef getArgument() const override { return "tf-hoist-replicate-invariant-resource-writes"; }

  ::llvm::StringRef getDescription() const override { return "Hoists writes to replicate invariant resource variables."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("HoistReplicateInvariantResourceWritesPass");
  }
  ::llvm::StringRef getName() const override { return "HoistReplicateInvariantResourceWritesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(HoistReplicateInvariantResourceWritesPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class InitTextFileToImportPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = InitTextFileToImportPassBase;

  InitTextFileToImportPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  InitTextFileToImportPassBase(const InitTextFileToImportPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-init-text-file-to-import");
  }
  ::llvm::StringRef getArgument() const override { return "tf-init-text-file-to-import"; }

  ::llvm::StringRef getDescription() const override { return "convert InitializeTableFromTextFileV2 ops to LookupTableImportV2Op to remove the dependency on asset files"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("InitTextFileToImportPass");
  }
  ::llvm::StringRef getName() const override { return "InitTextFileToImportPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(InitTextFileToImportPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<std::string> saved_model_dir_{*this, "tf-saved-model-dir", ::llvm::cl::desc("Directory containing the model exported as a TensorFlow SavedModel. If your model is not based on the TensorFlow SavedModel, use an empty value.")};
};

template <typename DerivedT>
class LaunchOutliningPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = LaunchOutliningPassBase;

  LaunchOutliningPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  LaunchOutliningPassBase(const LaunchOutliningPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-device-launch-outlining");
  }
  ::llvm::StringRef getArgument() const override { return "tf-device-launch-outlining"; }

  ::llvm::StringRef getDescription() const override { return "Outlines regions of tf_device.launch operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LaunchOutliningPass");
  }
  ::llvm::StringRef getName() const override { return "LaunchOutliningPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LaunchOutliningPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class LayoutAssignmentPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = LayoutAssignmentPassBase;

  LayoutAssignmentPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LayoutAssignmentPassBase(const LayoutAssignmentPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-layout-assignment");
  }
  ::llvm::StringRef getArgument() const override { return "tf-layout-assignment"; }

  ::llvm::StringRef getDescription() const override { return "Layout assignment pass."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LayoutAssignmentPass");
  }
  ::llvm::StringRef getName() const override { return "LayoutAssignmentPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LayoutAssignmentPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<std::string> force_data_format_{*this, "force-data-format", ::llvm::cl::desc("Force data format for all layout sensitive ops.")};
};

template <typename DerivedT>
class LegalizeHloToTfPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = LegalizeHloToTfPassBase;

  LegalizeHloToTfPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LegalizeHloToTfPassBase(const LegalizeHloToTfPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-legalize-hlo");
  }
  ::llvm::StringRef getArgument() const override { return "tf-legalize-hlo"; }

  ::llvm::StringRef getDescription() const override { return "Legalize from HLO to the TF dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LegalizeHloToTfPass");
  }
  ::llvm::StringRef getName() const override { return "LegalizeHloToTfPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<TF::TensorFlowDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LegalizeHloToTfPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class LegalizeTFGToTFPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = LegalizeTFGToTFPassBase;

  LegalizeTFGToTFPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  LegalizeTFGToTFPassBase(const LegalizeTFGToTFPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tfe-legalize-tfg");
  }
  ::llvm::StringRef getArgument() const override { return "tfe-legalize-tfg"; }

  ::llvm::StringRef getDescription() const override { return "Legalize from TFG to the TFE dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LegalizeTFGToTFPass");
  }
  ::llvm::StringRef getName() const override { return "LegalizeTFGToTFPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LegalizeTFGToTFPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class LocalizeVarHandlesPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = LocalizeVarHandlesPassBase;

  LocalizeVarHandlesPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  LocalizeVarHandlesPassBase(const LocalizeVarHandlesPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-localize-var-handles");
  }
  ::llvm::StringRef getArgument() const override { return "tf-localize-var-handles"; }

  ::llvm::StringRef getDescription() const override { return "Creates VarHandleOps next to the operations that use them."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LocalizeVarHandlesPass");
  }
  ::llvm::StringRef getName() const override { return "LocalizeVarHandlesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LocalizeVarHandlesPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class LowerQuantizedPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = LowerQuantizedPassBase;

  LowerQuantizedPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LowerQuantizedPassBase(const LowerQuantizedPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-lower-quantized");
  }
  ::llvm::StringRef getArgument() const override { return "tf-lower-quantized"; }

  ::llvm::StringRef getDescription() const override { return "Lowers ops that require quantized input or output."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LowerQuantizedPass");
  }
  ::llvm::StringRef getName() const override { return "LowerQuantizedPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LowerQuantizedPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class MarkInputOutputAliasesPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = MarkInputOutputAliasesPassBase;

  MarkInputOutputAliasesPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  MarkInputOutputAliasesPassBase(const MarkInputOutputAliasesPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-device-mark-input-output-aliases");
  }
  ::llvm::StringRef getArgument() const override { return "tf-device-mark-input-output-aliases"; }

  ::llvm::StringRef getDescription() const override { return "Marks device cluster inputs-output pairs that read/write to the same variable as aliases"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("MarkInputOutputAliasesPass");
  }
  ::llvm::StringRef getName() const override { return "MarkInputOutputAliasesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MarkInputOutputAliasesPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class MarkOpsForOutsideCompilationPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = MarkOpsForOutsideCompilationPassBase;

  MarkOpsForOutsideCompilationPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  MarkOpsForOutsideCompilationPassBase(const MarkOpsForOutsideCompilationPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-mark-ops-for-outside-compilation");
  }
  ::llvm::StringRef getArgument() const override { return "tf-mark-ops-for-outside-compilation"; }

  ::llvm::StringRef getDescription() const override { return "Marks ops in device cluster for outside compilation if they are unsupported on device."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("MarkOpsForOutsideCompilationPass");
  }
  ::llvm::StringRef getName() const override { return "MarkOpsForOutsideCompilationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MarkOpsForOutsideCompilationPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class MaterializePassthroughOpBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = MaterializePassthroughOpBase;

  MaterializePassthroughOpBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  MaterializePassthroughOpBase(const MaterializePassthroughOpBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-materialize-passthrough-op");
  }
  ::llvm::StringRef getArgument() const override { return "tf-materialize-passthrough-op"; }

  ::llvm::StringRef getDescription() const override { return "Materialize the MlirPassthroughOp by replacing it with the MLIR module attached as an attribute"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("MaterializePassthroughOp");
  }
  ::llvm::StringRef getName() const override { return "MaterializePassthroughOp"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MaterializePassthroughOpBase<DerivedT>)

protected:
};

template <typename DerivedT>
class MergeControlFlowPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = MergeControlFlowPassBase;

  MergeControlFlowPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  MergeControlFlowPassBase(const MergeControlFlowPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-merge-control-flow");
  }
  ::llvm::StringRef getArgument() const override { return "tf-merge-control-flow"; }

  ::llvm::StringRef getDescription() const override { return "Merges IfRegion ops together with a common predicate."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("MergeControlFlowPass");
  }
  ::llvm::StringRef getName() const override { return "MergeControlFlowPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MergeControlFlowPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class MoveTransposesPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = MoveTransposesPassBase;

  MoveTransposesPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  MoveTransposesPassBase(const MoveTransposesPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-move-transposes");
  }
  ::llvm::StringRef getArgument() const override { return "tf-move-transposes"; }

  ::llvm::StringRef getDescription() const override { return "Move transposes pass."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("MoveTransposesPass");
  }
  ::llvm::StringRef getName() const override { return "MoveTransposesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MoveTransposesPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> fold_transpose_in_ops_{*this, "fold-transpose-in-ops", ::llvm::cl::desc("Whether to fold transposes in ops which can support folding."), ::llvm::cl::init(true)};
  ::mlir::Pass::Option<enum MoveTransposeDirection> direction_{*this, "direction", ::llvm::cl::desc("Move transposes to the beginning or the end of the block where they are defined."), ::llvm::cl::init(MoveTransposeDirection::kBegin), llvm::cl::values(clEnumValN(MoveTransposeDirection::kBegin, "begin", "beginning of the block"),clEnumValN(MoveTransposeDirection::kEnd, "end", "end of the block"))};
};

template <typename DerivedT>
class NameAnonymousIteratorsPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = NameAnonymousIteratorsPassBase;

  NameAnonymousIteratorsPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  NameAnonymousIteratorsPassBase(const NameAnonymousIteratorsPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-name-anonymous-iterators");
  }
  ::llvm::StringRef getArgument() const override { return "tf-name-anonymous-iterators"; }

  ::llvm::StringRef getDescription() const override { return "Converts anonymous iterators to named iterators"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("NameAnonymousIteratorsPass");
  }
  ::llvm::StringRef getName() const override { return "NameAnonymousIteratorsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(NameAnonymousIteratorsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class OrderByDialectPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = OrderByDialectPassBase;

  OrderByDialectPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  OrderByDialectPassBase(const OrderByDialectPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-order-by-dialect");
  }
  ::llvm::StringRef getArgument() const override { return "tf-order-by-dialect"; }

  ::llvm::StringRef getDescription() const override { return "Reorders ops so ops of the same dialect are next to each other."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("OrderByDialectPass");
  }
  ::llvm::StringRef getName() const override { return "OrderByDialectPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(OrderByDialectPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class OutsideCompiledToHostLaunchPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = OutsideCompiledToHostLaunchPassBase;

  OutsideCompiledToHostLaunchPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  OutsideCompiledToHostLaunchPassBase(const OutsideCompiledToHostLaunchPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-outside-compiled-to-host-launch");
  }
  ::llvm::StringRef getArgument() const override { return "tf-outside-compiled-to-host-launch"; }

  ::llvm::StringRef getDescription() const override { return "Wraps each op with the _xla_outside_compiled attribute in a separate tf_device.launch on replicated host device."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("OutsideCompiledToHostLaunchPass");
  }
  ::llvm::StringRef getName() const override { return "OutsideCompiledToHostLaunchPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(OutsideCompiledToHostLaunchPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ParallelExecuteToIslandsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ParallelExecuteToIslandsPassBase;

  ParallelExecuteToIslandsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ParallelExecuteToIslandsPassBase(const ParallelExecuteToIslandsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-parallel-execute-to-islands");
  }
  ::llvm::StringRef getArgument() const override { return "tf-parallel-execute-to-islands"; }

  ::llvm::StringRef getDescription() const override { return "Lowers device parallel_execute to executor islands"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ParallelExecuteToIslandsPass");
  }
  ::llvm::StringRef getName() const override { return "ParallelExecuteToIslandsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ParallelExecuteToIslandsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class PrepareTpuComputationForTfExportPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = PrepareTpuComputationForTfExportPassBase;

  PrepareTpuComputationForTfExportPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  PrepareTpuComputationForTfExportPassBase(const PrepareTpuComputationForTfExportPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("prepare-tpu-computation-for-tf-export");
  }
  ::llvm::StringRef getArgument() const override { return "prepare-tpu-computation-for-tf-export"; }

  ::llvm::StringRef getDescription() const override { return "Prepare TPU computation to be legal for export to TensorFlow"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("PrepareTpuComputationForTfExportPass");
  }
  ::llvm::StringRef getName() const override { return "PrepareTpuComputationForTfExportPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(PrepareTpuComputationForTfExportPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class PromoteResourcesToArgsPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = PromoteResourcesToArgsPassBase;

  PromoteResourcesToArgsPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  PromoteResourcesToArgsPassBase(const PromoteResourcesToArgsPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-promote-resources-to-args");
  }
  ::llvm::StringRef getArgument() const override { return "tf-promote-resources-to-args"; }

  ::llvm::StringRef getDescription() const override { return "Promote resources reads/writes to function inputs/outputs."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("PromoteResourcesToArgsPass");
  }
  ::llvm::StringRef getName() const override { return "PromoteResourcesToArgsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(PromoteResourcesToArgsPassBase<DerivedT>)

protected:
  ::mlir::Pass::ListOption<std::string> functions_{*this, "functions", ::llvm::cl::desc("Comma separated list of functions whose resources read/writes should be promoted to function inputs/outputs.")};
};

template <typename DerivedT>
class PromoteVarHandlesToArgsPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = PromoteVarHandlesToArgsPassBase;

  PromoteVarHandlesToArgsPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  PromoteVarHandlesToArgsPassBase(const PromoteVarHandlesToArgsPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-promote-var-handles-to-args");
  }
  ::llvm::StringRef getArgument() const override { return "tf-promote-var-handles-to-args"; }

  ::llvm::StringRef getDescription() const override { return "Promote tf.VarHandleOps to function arguments."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("PromoteVarHandlesToArgsPass");
  }
  ::llvm::StringRef getName() const override { return "PromoteVarHandlesToArgsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(PromoteVarHandlesToArgsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class RegionControlFlowToFunctionalPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = RegionControlFlowToFunctionalPassBase;

  RegionControlFlowToFunctionalPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  RegionControlFlowToFunctionalPassBase(const RegionControlFlowToFunctionalPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-region-control-flow-to-functional");
  }
  ::llvm::StringRef getArgument() const override { return "tf-region-control-flow-to-functional"; }

  ::llvm::StringRef getDescription() const override { return "Transforms region-based control flow operations to their functional counterparts"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("RegionControlFlowToFunctionalPass");
  }
  ::llvm::StringRef getName() const override { return "RegionControlFlowToFunctionalPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(RegionControlFlowToFunctionalPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class RemoveUnusedArgumentsPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = RemoveUnusedArgumentsPassBase;

  RemoveUnusedArgumentsPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  RemoveUnusedArgumentsPassBase(const RemoveUnusedArgumentsPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-remove-unused-arguments");
  }
  ::llvm::StringRef getArgument() const override { return "tf-remove-unused-arguments"; }

  ::llvm::StringRef getDescription() const override { return "Removes unused args from private functions & their callers."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("RemoveUnusedArgumentsPass");
  }
  ::llvm::StringRef getName() const override { return "RemoveUnusedArgumentsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(RemoveUnusedArgumentsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class RemoveUnusedWhileResultsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = RemoveUnusedWhileResultsPassBase;

  RemoveUnusedWhileResultsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  RemoveUnusedWhileResultsPassBase(const RemoveUnusedWhileResultsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-remove-unused-while-results");
  }
  ::llvm::StringRef getArgument() const override { return "tf-remove-unused-while-results"; }

  ::llvm::StringRef getDescription() const override { return "Removes unused results from tf.WhileRegion ops"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("RemoveUnusedWhileResultsPass");
  }
  ::llvm::StringRef getName() const override { return "RemoveUnusedWhileResultsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(RemoveUnusedWhileResultsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ReplicaIDToDeviceOrdinalPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ReplicaIDToDeviceOrdinalPassBase;

  ReplicaIDToDeviceOrdinalPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ReplicaIDToDeviceOrdinalPassBase(const ReplicaIDToDeviceOrdinalPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-replica-id-to-device-ordinal");
  }
  ::llvm::StringRef getArgument() const override { return "tf-replica-id-to-device-ordinal"; }

  ::llvm::StringRef getDescription() const override { return "Set device ordinal with replica id"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ReplicaIDToDeviceOrdinalPass");
  }
  ::llvm::StringRef getName() const override { return "ReplicaIDToDeviceOrdinalPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ReplicaIDToDeviceOrdinalPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ReplicateInvariantOpHoistingPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ReplicateInvariantOpHoistingPassBase;

  ReplicateInvariantOpHoistingPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ReplicateInvariantOpHoistingPassBase(const ReplicateInvariantOpHoistingPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-replicate-invariant-op-hoisting");
  }
  ::llvm::StringRef getArgument() const override { return "tf-replicate-invariant-op-hoisting"; }

  ::llvm::StringRef getDescription() const override { return "Hoists replicate invariant operations out of replicate"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ReplicateInvariantOpHoistingPass");
  }
  ::llvm::StringRef getName() const override { return "ReplicateInvariantOpHoistingPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ReplicateInvariantOpHoistingPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ReplicateToIslandPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ReplicateToIslandPassBase;

  ReplicateToIslandPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ReplicateToIslandPassBase(const ReplicateToIslandPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-replicate-to-island");
  }
  ::llvm::StringRef getArgument() const override { return "tf-replicate-to-island"; }

  ::llvm::StringRef getDescription() const override { return "Lowers device replicate to executor islands"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ReplicateToIslandPass");
  }
  ::llvm::StringRef getName() const override { return "ReplicateToIslandPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ReplicateToIslandPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ResourceDeviceInferencePassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ResourceDeviceInferencePassBase;

  ResourceDeviceInferencePassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ResourceDeviceInferencePassBase(const ResourceDeviceInferencePassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-resource-device-inference");
  }
  ::llvm::StringRef getArgument() const override { return "tf-resource-device-inference"; }

  ::llvm::StringRef getDescription() const override { return "Propagates the device attribute on resources from callers to callees."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ResourceDeviceInferencePass");
  }
  ::llvm::StringRef getName() const override { return "ResourceDeviceInferencePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ResourceDeviceInferencePassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class RewriteTPUEmbeddingOpsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = RewriteTPUEmbeddingOpsPassBase;

  RewriteTPUEmbeddingOpsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  RewriteTPUEmbeddingOpsPassBase(const RewriteTPUEmbeddingOpsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-rewrite-tpu-embedding-ops");
  }
  ::llvm::StringRef getArgument() const override { return "tf-rewrite-tpu-embedding-ops"; }

  ::llvm::StringRef getDescription() const override { return "Rewrites TPU embedding send/recv ops by adding TPU embedding deduplication data"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("RewriteTPUEmbeddingOpsPass");
  }
  ::llvm::StringRef getName() const override { return "RewriteTPUEmbeddingOpsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(RewriteTPUEmbeddingOpsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class SimpleTFDeviceAssignmentPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = SimpleTFDeviceAssignmentPassBase;

  SimpleTFDeviceAssignmentPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  SimpleTFDeviceAssignmentPassBase(const SimpleTFDeviceAssignmentPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-simple-device-assignment");
  }
  ::llvm::StringRef getArgument() const override { return "tf-simple-device-assignment"; }

  ::llvm::StringRef getDescription() const override { return "Simple device assignment in TF dialect."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SimpleTFDeviceAssignmentPass");
  }
  ::llvm::StringRef getName() const override { return "SimpleTFDeviceAssignmentPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SimpleTFDeviceAssignmentPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<std::string> default_device_{*this, "default-device", ::llvm::cl::desc("The default device to assign."), ::llvm::cl::init("cpu")};
};

template <typename DerivedT>
class SplitIntoIslandPerOpPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = SplitIntoIslandPerOpPassBase;

  SplitIntoIslandPerOpPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  SplitIntoIslandPerOpPassBase(const SplitIntoIslandPerOpPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-executor-split-into-island-per-op");
  }
  ::llvm::StringRef getArgument() const override { return "tf-executor-split-into-island-per-op"; }

  ::llvm::StringRef getDescription() const override { return "Transform from TF control dialect to TF executor dialect."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SplitIntoIslandPerOpPass");
  }
  ::llvm::StringRef getName() const override { return "SplitIntoIslandPerOpPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<mlir::tf_executor::TensorFlowExecutorDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SplitIntoIslandPerOpPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class StackOpsDecompositionPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = StackOpsDecompositionPassBase;

  StackOpsDecompositionPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  StackOpsDecompositionPassBase(const StackOpsDecompositionPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-stack-ops-decomposition");
  }
  ::llvm::StringRef getArgument() const override { return "tf-stack-ops-decomposition"; }

  ::llvm::StringRef getDescription() const override { return "Decompose stack operations into local variable operations. Needs static shapes."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("StackOpsDecompositionPass");
  }
  ::llvm::StringRef getName() const override { return "StackOpsDecompositionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(StackOpsDecompositionPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class StripNoinlineAttributePassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = StripNoinlineAttributePassBase;

  StripNoinlineAttributePassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  StripNoinlineAttributePassBase(const StripNoinlineAttributePassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-strip-noinline-attribute");
  }
  ::llvm::StringRef getArgument() const override { return "tf-strip-noinline-attribute"; }

  ::llvm::StringRef getDescription() const override { return "Strip the tf._noinline attribute from top-level functions."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("StripNoinlineAttributePass");
  }
  ::llvm::StringRef getName() const override { return "StripNoinlineAttributePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(StripNoinlineAttributePassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class StripTfAttributesPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = StripTfAttributesPassBase;

  StripTfAttributesPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  StripTfAttributesPassBase(const StripTfAttributesPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-strip-tf-attributes");
  }
  ::llvm::StringRef getArgument() const override { return "tf-strip-tf-attributes"; }

  ::llvm::StringRef getDescription() const override { return "Removes TF specific attributes"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("StripTfAttributesPass");
  }
  ::llvm::StringRef getName() const override { return "StripTfAttributesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(StripTfAttributesPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TFDataOptimizationPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TFDataOptimizationPassBase;

  TFDataOptimizationPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TFDataOptimizationPassBase(const TFDataOptimizationPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-data-optimization");
  }
  ::llvm::StringRef getArgument() const override { return "tf-data-optimization"; }

  ::llvm::StringRef getDescription() const override { return "Performs tf.data optimizations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TFDataOptimizationPass");
  }
  ::llvm::StringRef getName() const override { return "TFDataOptimizationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TFDataOptimizationPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TFDeviceAssignmentByFuncAttrPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TFDeviceAssignmentByFuncAttrPassBase;

  TFDeviceAssignmentByFuncAttrPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TFDeviceAssignmentByFuncAttrPassBase(const TFDeviceAssignmentByFuncAttrPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-device-assignment-by-func-attr");
  }
  ::llvm::StringRef getArgument() const override { return "tf-device-assignment-by-func-attr"; }

  ::llvm::StringRef getDescription() const override { return "Device assignment in TF dialect using the device specified in the function attribute."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TFDeviceAssignmentByFuncAttrPass");
  }
  ::llvm::StringRef getName() const override { return "TFDeviceAssignmentByFuncAttrPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TFDeviceAssignmentByFuncAttrPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TPUBridgeExecutorIslandOutliningPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TPUBridgeExecutorIslandOutliningPassBase;

  TPUBridgeExecutorIslandOutliningPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUBridgeExecutorIslandOutliningPassBase(const TPUBridgeExecutorIslandOutliningPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-executor-tpu-v1-island-outlining");
  }
  ::llvm::StringRef getArgument() const override { return "tf-executor-tpu-v1-island-outlining"; }

  ::llvm::StringRef getDescription() const override { return "Outline TPU clusters from island into a nested module, so it can be processed like a V2 module, intended for V1 compatibility mode"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUBridgeExecutorIslandOutliningPass");
  }
  ::llvm::StringRef getName() const override { return "TPUBridgeExecutorIslandOutliningPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUBridgeExecutorIslandOutliningPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TPUCleanupClusterAttributesPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TPUCleanupClusterAttributesPassBase;

  TPUCleanupClusterAttributesPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUCleanupClusterAttributesPassBase(const TPUCleanupClusterAttributesPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-cleanup-cluster-attributes");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-cleanup-cluster-attributes"; }

  ::llvm::StringRef getDescription() const override { return "Eliminate _replication_info and other attributes from ops in a cluster"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUCleanupClusterAttributesPass");
  }
  ::llvm::StringRef getName() const override { return "TPUCleanupClusterAttributesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUCleanupClusterAttributesPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TPUClusterFormationPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TPUClusterFormationPassBase;

  TPUClusterFormationPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUClusterFormationPassBase(const TPUClusterFormationPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-cluster-formation");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-cluster-formation"; }

  ::llvm::StringRef getDescription() const override { return "Forms clusters from operations assigned to the same TPU computation"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUClusterFormationPass");
  }
  ::llvm::StringRef getName() const override { return "TPUClusterFormationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUClusterFormationPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TPUColocateCompositeResourceOpsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TPUColocateCompositeResourceOpsPassBase;

  TPUColocateCompositeResourceOpsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUColocateCompositeResourceOpsPassBase(const TPUColocateCompositeResourceOpsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-colocate-composite-resource-ops");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-colocate-composite-resource-ops"; }

  ::llvm::StringRef getDescription() const override { return "Colocate resource with composite device assignment to TPU device."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUColocateCompositeResourceOpsPass");
  }
  ::llvm::StringRef getName() const override { return "TPUColocateCompositeResourceOpsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUColocateCompositeResourceOpsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TPUDevicePropagationPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TPUDevicePropagationPassBase;

  TPUDevicePropagationPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUDevicePropagationPassBase(const TPUDevicePropagationPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-device-propagation");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-device-propagation"; }

  ::llvm::StringRef getDescription() const override { return "Propagates TPU devices from ops to users"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUDevicePropagationPass");
  }
  ::llvm::StringRef getName() const override { return "TPUDevicePropagationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUDevicePropagationPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TPUDynamicLayoutPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TPUDynamicLayoutPassBase;

  TPUDynamicLayoutPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUDynamicLayoutPassBase(const TPUDynamicLayoutPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-dynamic-layout-pass");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-dynamic-layout-pass"; }

  ::llvm::StringRef getDescription() const override { return "Inserts TPU layout ops to determine layout at run time."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUDynamicLayoutPass");
  }
  ::llvm::StringRef getName() const override { return "TPUDynamicLayoutPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUDynamicLayoutPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TPUExtractHeadTailOutsideCompilationPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TPUExtractHeadTailOutsideCompilationPassBase;

  TPUExtractHeadTailOutsideCompilationPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUExtractHeadTailOutsideCompilationPassBase(const TPUExtractHeadTailOutsideCompilationPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-extract-head-tail-outside-compilation");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-extract-head-tail-outside-compilation"; }

  ::llvm::StringRef getDescription() const override { return "Extracts TPU head or tail outside compilation to separate host launches before/after device cluster."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUExtractHeadTailOutsideCompilationPass");
  }
  ::llvm::StringRef getName() const override { return "TPUExtractHeadTailOutsideCompilationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUExtractHeadTailOutsideCompilationPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TPUExtractOutsideCompilationPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TPUExtractOutsideCompilationPassBase;

  TPUExtractOutsideCompilationPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUExtractOutsideCompilationPassBase(const TPUExtractOutsideCompilationPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-extract-outside-compilation");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-extract-outside-compilation"; }

  ::llvm::StringRef getDescription() const override { return "Extracts TPU outside compilation computation to a separate tf_device.parallel_execute region."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUExtractOutsideCompilationPass");
  }
  ::llvm::StringRef getName() const override { return "TPUExtractOutsideCompilationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUExtractOutsideCompilationPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TPUHostComputationExpansionPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TPUHostComputationExpansionPassBase;

  TPUHostComputationExpansionPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUHostComputationExpansionPassBase(const TPUHostComputationExpansionPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-host-computation-expansion");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-host-computation-expansion"; }

  ::llvm::StringRef getDescription() const override { return "Expands host computation before and after TPU computation."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUHostComputationExpansionPass");
  }
  ::llvm::StringRef getName() const override { return "TPUHostComputationExpansionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUHostComputationExpansionPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TPUIdentityPruningPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TPUIdentityPruningPassBase;

  TPUIdentityPruningPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUIdentityPruningPassBase(const TPUIdentityPruningPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-identity-pruning");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-identity-pruning"; }

  ::llvm::StringRef getDescription() const override { return "Removes Identity/IdentityN ops from the TPU computation"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUIdentityPruningPass");
  }
  ::llvm::StringRef getName() const override { return "TPUIdentityPruningPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUIdentityPruningPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TPUMergeVariablesWithExecutePassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TPUMergeVariablesWithExecutePassBase;

  TPUMergeVariablesWithExecutePassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUMergeVariablesWithExecutePassBase(const TPUMergeVariablesWithExecutePassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-merge-variables-with-execute");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-merge-variables-with-execute"; }

  ::llvm::StringRef getDescription() const override { return "Merges device variable reads and updates into TPU execute ops"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUMergeVariablesWithExecutePass");
  }
  ::llvm::StringRef getName() const override { return "TPUMergeVariablesWithExecutePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUMergeVariablesWithExecutePassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TPUParallelExecuteSinkResourceWritePassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TPUParallelExecuteSinkResourceWritePassBase;

  TPUParallelExecuteSinkResourceWritePassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUParallelExecuteSinkResourceWritePassBase(const TPUParallelExecuteSinkResourceWritePassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-parallel-execute-sink-resource-write");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-parallel-execute-sink-resource-write"; }

  ::llvm::StringRef getDescription() const override { return "Moves tf.AssignVariableOp consumers of tf_device.parallel_execute into tf_device.parallel_execute regions"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUParallelExecuteSinkResourceWritePass");
  }
  ::llvm::StringRef getName() const override { return "TPUParallelExecuteSinkResourceWritePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUParallelExecuteSinkResourceWritePassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TPUReorderReplicateAndPartitionedInputsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TPUReorderReplicateAndPartitionedInputsPassBase;

  TPUReorderReplicateAndPartitionedInputsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUReorderReplicateAndPartitionedInputsPassBase(const TPUReorderReplicateAndPartitionedInputsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-reorder-replicate-partitioned-inputs");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-reorder-replicate-partitioned-inputs"; }

  ::llvm::StringRef getDescription() const override { return "Reorder replicated and partitioned input ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUReorderReplicateAndPartitionedInputsPass");
  }
  ::llvm::StringRef getName() const override { return "TPUReorderReplicateAndPartitionedInputsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUReorderReplicateAndPartitionedInputsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TPUResourceReadForWritePassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TPUResourceReadForWritePassBase;

  TPUResourceReadForWritePassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUResourceReadForWritePassBase(const TPUResourceReadForWritePassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-resource-read-for-write");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-resource-read-for-write"; }

  ::llvm::StringRef getDescription() const override { return "Inserts tf.ReadVariableOp inputs to a TPU cluster for resource writes with no reads"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUResourceReadForWritePass");
  }
  ::llvm::StringRef getName() const override { return "TPUResourceReadForWritePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUResourceReadForWritePassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TPUResourceReadsWritesPartitioningPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TPUResourceReadsWritesPartitioningPassBase;

  TPUResourceReadsWritesPartitioningPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUResourceReadsWritesPartitioningPassBase(const TPUResourceReadsWritesPartitioningPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-resource-partition");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-resource-partition"; }

  ::llvm::StringRef getDescription() const override { return "Partitions unpartitioned resource read/write to partitioned resource variables."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUResourceReadsWritesPartitioningPass");
  }
  ::llvm::StringRef getName() const override { return "TPUResourceReadsWritesPartitioningPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUResourceReadsWritesPartitioningPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TPURewritePassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TPURewritePassBase;

  TPURewritePassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPURewritePassBase(const TPURewritePassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-rewrite");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-rewrite"; }

  ::llvm::StringRef getDescription() const override { return "Rewrites a `tf_device.cluster_func` on TPUs into TPU runtime operations."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPURewritePass");
  }
  ::llvm::StringRef getName() const override { return "TPURewritePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPURewritePassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> tpu_compile_metadata_debug_{*this, "tpu-compile-metadata-debug", ::llvm::cl::desc("Whether to serialize TPUCompileMetadataProto metadata in 'tf._TPUCompileMlir' op as a proto debug string"), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class TPUShardingIdentificationPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TPUShardingIdentificationPassBase;

  TPUShardingIdentificationPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUShardingIdentificationPassBase(const TPUShardingIdentificationPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-sharding-identification");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-sharding-identification"; }

  ::llvm::StringRef getDescription() const override { return "Identifies and handles inputs/outputs of TPU computation that is sharded across logical cores."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUShardingIdentificationPass");
  }
  ::llvm::StringRef getName() const override { return "TPUShardingIdentificationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUShardingIdentificationPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TPUSpaceToDepthPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TPUSpaceToDepthPassBase;

  TPUSpaceToDepthPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUSpaceToDepthPassBase(const TPUSpaceToDepthPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-space-to-depth-pass");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-space-to-depth-pass"; }

  ::llvm::StringRef getDescription() const override { return "Applies automatic space to depth transform for the first or frontier convolutions consume host inputs on TPU."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUSpaceToDepthPass");
  }
  ::llvm::StringRef getName() const override { return "TPUSpaceToDepthPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUSpaceToDepthPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TPUUpdateEmbeddingEnqueueOpInputsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TPUUpdateEmbeddingEnqueueOpInputsPassBase;

  TPUUpdateEmbeddingEnqueueOpInputsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUUpdateEmbeddingEnqueueOpInputsPassBase(const TPUUpdateEmbeddingEnqueueOpInputsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-update-embedding-enqueue-op-inputs");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-update-embedding-enqueue-op-inputs"; }

  ::llvm::StringRef getDescription() const override { return "Updates inputs to TPU embedding enqueue ops depending on whether graph is in training mode or in evaluation mode."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUUpdateEmbeddingEnqueueOpInputsPass");
  }
  ::llvm::StringRef getName() const override { return "TPUUpdateEmbeddingEnqueueOpInputsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUUpdateEmbeddingEnqueueOpInputsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TPUVariableRuntimeReformattingPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TPUVariableRuntimeReformattingPassBase;

  TPUVariableRuntimeReformattingPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TPUVariableRuntimeReformattingPassBase(const TPUVariableRuntimeReformattingPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tpu-variable-runtime-reformatting");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tpu-variable-runtime-reformatting"; }

  ::llvm::StringRef getDescription() const override { return "Adds device variable formatting op to allow compilation-guided variable formatting."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TPUVariableRuntimeReformattingPass");
  }
  ::llvm::StringRef getName() const override { return "TPUVariableRuntimeReformattingPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TPUVariableRuntimeReformattingPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TensorArrayOpsDecompositionPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TensorArrayOpsDecompositionPassBase;

  TensorArrayOpsDecompositionPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TensorArrayOpsDecompositionPassBase(const TensorArrayOpsDecompositionPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tensor-array-ops-decomposition");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tensor-array-ops-decomposition"; }

  ::llvm::StringRef getDescription() const override { return "Decompose tensor array operations into local variable operations."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TensorArrayOpsDecompositionPass");
  }
  ::llvm::StringRef getName() const override { return "TensorArrayOpsDecompositionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<tensor::TensorDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TensorArrayOpsDecompositionPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TensorDeviceCopyConversionPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TensorDeviceCopyConversionPassBase;

  TensorDeviceCopyConversionPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TensorDeviceCopyConversionPassBase(const TensorDeviceCopyConversionPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tensor-device-copy");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tensor-device-copy"; }

  ::llvm::StringRef getDescription() const override { return "Fold the tf.Identity op and the tf.IdentityN op if the op has the same device as its operand"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TensorDeviceCopyConversionPass");
  }
  ::llvm::StringRef getName() const override { return "TensorDeviceCopyConversionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TensorDeviceCopyConversionPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TensorFlowOptimizePassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TensorFlowOptimizePassBase;

  TensorFlowOptimizePassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TensorFlowOptimizePassBase(const TensorFlowOptimizePassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-optimize");
  }
  ::llvm::StringRef getArgument() const override { return "tf-optimize"; }

  ::llvm::StringRef getDescription() const override { return "Optimize TensorFlow module"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TensorFlowOptimizePass");
  }
  ::llvm::StringRef getName() const override { return "TensorFlowOptimizePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TensorFlowOptimizePassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TensorFlowShapeInferencePassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TensorFlowShapeInferencePassBase;

  TensorFlowShapeInferencePassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TensorFlowShapeInferencePassBase(const TensorFlowShapeInferencePassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-shape-inference");
  }
  ::llvm::StringRef getArgument() const override { return "tf-shape-inference"; }

  ::llvm::StringRef getDescription() const override { return "Shape inference on TF dialect and ops implementing InferTypeOpInterface"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TensorFlowShapeInferencePass");
  }
  ::llvm::StringRef getName() const override { return "TensorFlowShapeInferencePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TensorFlowShapeInferencePassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<int64_t> max_iterations_{*this, "max-iterations", ::llvm::cl::desc("Maximum shape inference iterations"), ::llvm::cl::init(10)};
};

template <typename DerivedT>
class TensorListOpsDecompositionPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TensorListOpsDecompositionPassBase;

  TensorListOpsDecompositionPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TensorListOpsDecompositionPassBase(const TensorListOpsDecompositionPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-tensor-list-ops-decomposition");
  }
  ::llvm::StringRef getArgument() const override { return "tf-tensor-list-ops-decomposition"; }

  ::llvm::StringRef getDescription() const override { return "Decomposes TensorList operations into generic operations on tensors."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TensorListOpsDecompositionPass");
  }
  ::llvm::StringRef getName() const override { return "TensorListOpsDecompositionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TensorListOpsDecompositionPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TensorflowGPUFusionBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TensorflowGPUFusionBase;

  TensorflowGPUFusionBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TensorflowGPUFusionBase(const TensorflowGPUFusionBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-gpu-op-fusion");
  }
  ::llvm::StringRef getArgument() const override { return "tf-gpu-op-fusion"; }

  ::llvm::StringRef getDescription() const override { return "Fusion optimization for GPU targets"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TensorflowGPUFusion");
  }
  ::llvm::StringRef getName() const override { return "TensorflowGPUFusion"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TensorflowGPUFusionBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TpuV1BridgeExecutorIslandCoarseningPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TpuV1BridgeExecutorIslandCoarseningPassBase;

  TpuV1BridgeExecutorIslandCoarseningPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TpuV1BridgeExecutorIslandCoarseningPassBase(const TpuV1BridgeExecutorIslandCoarseningPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-executor-tpu-v1-island-coarsening");
  }
  ::llvm::StringRef getArgument() const override { return "tf-executor-tpu-v1-island-coarsening"; }

  ::llvm::StringRef getDescription() const override { return "Merges TPU clusters IslandOps, intended for V1 compatibility mode"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TpuV1BridgeExecutorIslandCoarseningPass");
  }
  ::llvm::StringRef getName() const override { return "TpuV1BridgeExecutorIslandCoarseningPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TpuV1BridgeExecutorIslandCoarseningPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TransformEinsumPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TransformEinsumPassBase;

  TransformEinsumPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TransformEinsumPassBase(const TransformEinsumPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-einsum");
  }
  ::llvm::StringRef getArgument() const override { return "tf-einsum"; }

  ::llvm::StringRef getDescription() const override { return "Transform Einsum to other TF Ops for the supported variants"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TransformEinsumPass");
  }
  ::llvm::StringRef getName() const override { return "TransformEinsumPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TransformEinsumPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class UnrollBatchMatMulPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = UnrollBatchMatMulPassBase;

  UnrollBatchMatMulPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  UnrollBatchMatMulPassBase(const UnrollBatchMatMulPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-unroll-batch-matmul");
  }
  ::llvm::StringRef getArgument() const override { return "tf-unroll-batch-matmul"; }

  ::llvm::StringRef getDescription() const override { return "Unroll TF BatchMatMul op into Reshape, Slice, MatMul, Pack ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("UnrollBatchMatMulPass");
  }
  ::llvm::StringRef getName() const override { return "UnrollBatchMatMulPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(UnrollBatchMatMulPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class VerifySuitableForExportPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = VerifySuitableForExportPassBase;

  VerifySuitableForExportPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  VerifySuitableForExportPassBase(const VerifySuitableForExportPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tf-verify-for-export");
  }
  ::llvm::StringRef getArgument() const override { return "tf-verify-for-export"; }

  ::llvm::StringRef getDescription() const override { return "Verify module is suitable for export back to TF Graph"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("VerifySuitableForExportPass");
  }
  ::llvm::StringRef getName() const override { return "VerifySuitableForExportPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(VerifySuitableForExportPassBase<DerivedT>)

protected:
};
#undef GEN_PASS_CLASSES
#endif // GEN_PASS_CLASSES
