/* Autogenerated by mlir-tblgen; don't manually edit */

#ifdef GEN_PASS_DECL
// Generate declarations for all passes.
#define GEN_PASS_DECL_ALLOCTOARGPASS
#define GEN_PASS_DECL_BUFFERPACKING
#define GEN_PASS_DECL_BUFFERREUSE
#define GEN_PASS_DECL_COLLAPSEPARALLELLOOPSTO1DPASS
#define GEN_PASS_DECL_COMPUTEOPANDFUNCBUFFERIZEPASS
#define GEN_PASS_DECL_COPYREMOVAL
#define GEN_PASS_DECL_DETENSORIZESCFOPSPASS
#define GEN_PASS_DECL_FINALBUFFERIZEPASS
#define GEN_PASS_DECL_GENERICHOSTTOLLVMPASS
#define GEN_PASS_DECL_LOWERINDEXCASTPASS
#define GEN_PASS_DECL_MEMORYCOUNT
#define GEN_PASS_DECL_ONESHOTBUFFERIZE
#define GEN_PASS_DECL_PROPAGATESTATICSHAPESTOKERNELPASS
#define GEN_PASS_DECL_SCALARIZATIONPASS
#define GEN_PASS_DECL_SHAPESIMPLIFICATION
#define GEN_PASS_DECL_SYMBOLICSHAPEOPTIMIZATION
#define GEN_PASS_DECL_TESTSHAPECOMPONENTANALYSIS
#define GEN_PASS_DECL_TESTUSERANGE
#define GEN_PASS_DECL_TILELOOPSPASS
#define GEN_PASS_DECL_UNBUFFERIZEPASS
#define GEN_PASS_DECL_UNROLLLOOPSPASS
#undef GEN_PASS_DECL
#endif // GEN_PASS_DECL

//===----------------------------------------------------------------------===//
// AllocToArgPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_ALLOCTOARGPASS
#undef GEN_PASS_DECL_ALLOCTOARGPASS
#endif // GEN_PASS_DECL_ALLOCTOARGPASS
#ifdef GEN_PASS_DEF_ALLOCTOARGPASS
namespace impl {

template <typename DerivedT>
class AllocToArgPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = AllocToArgPassBase;

  AllocToArgPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  AllocToArgPassBase(const AllocToArgPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("alloc-to-arg");
  }
  ::llvm::StringRef getArgument() const override { return "alloc-to-arg"; }

  ::llvm::StringRef getDescription() const override { return "Hoist memref allocations to function arguments."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AllocToArgPass");
  }
  ::llvm::StringRef getName() const override { return "AllocToArgPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AllocToArgPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_ALLOCTOARGPASS
#endif // GEN_PASS_DEF_ALLOCTOARGPASS

//===----------------------------------------------------------------------===//
// BufferPacking
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_BUFFERPACKING
struct BufferPackingOptions {
  unsigned window_size_ = 5;
};
#undef GEN_PASS_DECL_BUFFERPACKING
#endif // GEN_PASS_DECL_BUFFERPACKING
#ifdef GEN_PASS_DEF_BUFFERPACKING
namespace impl {

template <typename DerivedT>
class BufferPackingBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = BufferPackingBase;

  BufferPackingBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  BufferPackingBase(const BufferPackingBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("buffer-packing");
  }
  ::llvm::StringRef getArgument() const override { return "buffer-packing"; }

  ::llvm::StringRef getDescription() const override { return "Pass to pack allocated buffer to reduce memory consumption."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("BufferPacking");
  }
  ::llvm::StringRef getName() const override { return "BufferPacking"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<func::FuncDialect>();

  registry.insert<memref::MemRefDialect>();

  registry.insert<arith::ArithDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(BufferPackingBase<DerivedT>)

  BufferPackingBase(const BufferPackingOptions &options) : BufferPackingBase() {
    window_size_ = options.window_size_;
  }
protected:
  ::mlir::Pass::Option<unsigned> window_size_{*this, "window-size", ::llvm::cl::desc("The window size blurs the start position of anallocated buffer. Buffers allocated in the same sliding window areaare treated equally in terms of starting position, withing thesliding window area they are sorted by memory size.A window size of zero sorts the buffers only by memory size."), ::llvm::cl::init(5)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_BUFFERPACKING
#endif // GEN_PASS_DEF_BUFFERPACKING

//===----------------------------------------------------------------------===//
// BufferReuse
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_BUFFERREUSE
#undef GEN_PASS_DECL_BUFFERREUSE
#endif // GEN_PASS_DECL_BUFFERREUSE
#ifdef GEN_PASS_DEF_BUFFERREUSE
namespace impl {

template <typename DerivedT>
class BufferReuseBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = BufferReuseBase;

  BufferReuseBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  BufferReuseBase(const BufferReuseBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("buffer-reuse");
  }
  ::llvm::StringRef getArgument() const override { return "buffer-reuse"; }

  ::llvm::StringRef getDescription() const override { return "Reuses already allocated buffers to save allocation operations if it is provably safe."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("BufferReuse");
  }
  ::llvm::StringRef getName() const override { return "BufferReuse"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(BufferReuseBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_BUFFERREUSE
#endif // GEN_PASS_DEF_BUFFERREUSE

//===----------------------------------------------------------------------===//
// CollapseParallelLoopsTo1DPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_COLLAPSEPARALLELLOOPSTO1DPASS
#undef GEN_PASS_DECL_COLLAPSEPARALLELLOOPSTO1DPASS
#endif // GEN_PASS_DECL_COLLAPSEPARALLELLOOPSTO1DPASS
#ifdef GEN_PASS_DEF_COLLAPSEPARALLELLOOPSTO1DPASS
namespace impl {

template <typename DerivedT>
class CollapseParallelLoopsTo1DPassBase : public ::mlir::OperationPass<> {
public:
  using Base = CollapseParallelLoopsTo1DPassBase;

  CollapseParallelLoopsTo1DPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  CollapseParallelLoopsTo1DPassBase(const CollapseParallelLoopsTo1DPassBase &other) : ::mlir::OperationPass<>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("collapse-parallel-loops-to-1d");
  }
  ::llvm::StringRef getArgument() const override { return "collapse-parallel-loops-to-1d"; }

  ::llvm::StringRef getDescription() const override { return "Collapses multidimensional loops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("CollapseParallelLoopsTo1DPass");
  }
  ::llvm::StringRef getName() const override { return "CollapseParallelLoopsTo1DPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(CollapseParallelLoopsTo1DPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_COLLAPSEPARALLELLOOPSTO1DPASS
#endif // GEN_PASS_DEF_COLLAPSEPARALLELLOOPSTO1DPASS

//===----------------------------------------------------------------------===//
// ComputeOpAndFuncBufferizePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_COMPUTEOPANDFUNCBUFFERIZEPASS
#undef GEN_PASS_DECL_COMPUTEOPANDFUNCBUFFERIZEPASS
#endif // GEN_PASS_DECL_COMPUTEOPANDFUNCBUFFERIZEPASS
#ifdef GEN_PASS_DEF_COMPUTEOPANDFUNCBUFFERIZEPASS
namespace impl {

template <typename DerivedT>
class ComputeOpAndFuncBufferizePassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ComputeOpAndFuncBufferizePassBase;

  ComputeOpAndFuncBufferizePassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ComputeOpAndFuncBufferizePassBase(const ComputeOpAndFuncBufferizePassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("computeop-and-func-bufferize");
  }
  ::llvm::StringRef getArgument() const override { return "computeop-and-func-bufferize"; }

  ::llvm::StringRef getDescription() const override { return "Pass to transform compute operations (hlo and linalg) on values to buffer based ones."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ComputeOpAndFuncBufferizePass");
  }
  ::llvm::StringRef getName() const override { return "ComputeOpAndFuncBufferizePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ComputeOpAndFuncBufferizePassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_COMPUTEOPANDFUNCBUFFERIZEPASS
#endif // GEN_PASS_DEF_COMPUTEOPANDFUNCBUFFERIZEPASS

//===----------------------------------------------------------------------===//
// CopyRemoval
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_COPYREMOVAL
#undef GEN_PASS_DECL_COPYREMOVAL
#endif // GEN_PASS_DECL_COPYREMOVAL
#ifdef GEN_PASS_DEF_COPYREMOVAL
namespace impl {

template <typename DerivedT>
class CopyRemovalBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = CopyRemovalBase;

  CopyRemovalBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  CopyRemovalBase(const CopyRemovalBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("copy-removal");
  }
  ::llvm::StringRef getArgument() const override { return "copy-removal"; }

  ::llvm::StringRef getDescription() const override { return "Removes redundant operations that implement a CopyOpInterface, if the intersection of the useranges fromcopy source and target only contains the CopyOp."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("CopyRemoval");
  }
  ::llvm::StringRef getName() const override { return "CopyRemoval"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(CopyRemovalBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_COPYREMOVAL
#endif // GEN_PASS_DEF_COPYREMOVAL

//===----------------------------------------------------------------------===//
// DetensorizeScfOpsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_DETENSORIZESCFOPSPASS
#undef GEN_PASS_DECL_DETENSORIZESCFOPSPASS
#endif // GEN_PASS_DECL_DETENSORIZESCFOPSPASS
#ifdef GEN_PASS_DEF_DETENSORIZESCFOPSPASS
namespace impl {

template <typename DerivedT>
class DetensorizeScfOpsPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = DetensorizeScfOpsPassBase;

  DetensorizeScfOpsPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  DetensorizeScfOpsPassBase(const DetensorizeScfOpsPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("detensorize-scf-ops");
  }
  ::llvm::StringRef getArgument() const override { return "detensorize-scf-ops"; }

  ::llvm::StringRef getDescription() const override { return "Detensorize arguments of SCF ops where possible."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("DetensorizeScfOpsPass");
  }
  ::llvm::StringRef getName() const override { return "DetensorizeScfOpsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<scf::SCFDialect>();

  registry.insert<tensor::TensorDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(DetensorizeScfOpsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_DETENSORIZESCFOPSPASS
#endif // GEN_PASS_DEF_DETENSORIZESCFOPSPASS

//===----------------------------------------------------------------------===//
// FinalBufferizePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_FINALBUFFERIZEPASS
struct FinalBufferizePassOptions {
  uint64_t alignment_ = 64;
};
#undef GEN_PASS_DECL_FINALBUFFERIZEPASS
#endif // GEN_PASS_DECL_FINALBUFFERIZEPASS
#ifdef GEN_PASS_DEF_FINALBUFFERIZEPASS
namespace impl {

template <typename DerivedT>
class FinalBufferizePassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = FinalBufferizePassBase;

  FinalBufferizePassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  FinalBufferizePassBase(const FinalBufferizePassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("final-bufferize");
  }
  ::llvm::StringRef getArgument() const override { return "final-bufferize"; }

  ::llvm::StringRef getDescription() const override { return "Pass to transform late operations on values to buffer based ones."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("FinalBufferizePass");
  }
  ::llvm::StringRef getName() const override { return "FinalBufferizePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(FinalBufferizePassBase<DerivedT>)

  FinalBufferizePassBase(const FinalBufferizePassOptions &options) : FinalBufferizePassBase() {
    alignment_ = options.alignment_;
  }
protected:
  ::mlir::Pass::Option<uint64_t> alignment_{*this, "alignment", ::llvm::cl::desc("Memory alignment"), ::llvm::cl::init(64)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_FINALBUFFERIZEPASS
#endif // GEN_PASS_DEF_FINALBUFFERIZEPASS

//===----------------------------------------------------------------------===//
// GenericHostToLLVMPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_GENERICHOSTTOLLVMPASS
#undef GEN_PASS_DECL_GENERICHOSTTOLLVMPASS
#endif // GEN_PASS_DECL_GENERICHOSTTOLLVMPASS
#ifdef GEN_PASS_DEF_GENERICHOSTTOLLVMPASS
namespace impl {

template <typename DerivedT>
class GenericHostToLLVMPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = GenericHostToLLVMPassBase;

  GenericHostToLLVMPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  GenericHostToLLVMPassBase(const GenericHostToLLVMPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("generic-host-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "generic-host-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return "Pass to lower common dialects resulting from HLO to LLVM."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("GenericHostToLLVMPass");
  }
  ::llvm::StringRef getName() const override { return "GenericHostToLLVMPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(GenericHostToLLVMPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_GENERICHOSTTOLLVMPASS
#endif // GEN_PASS_DEF_GENERICHOSTTOLLVMPASS

//===----------------------------------------------------------------------===//
// LowerIndexCastPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LOWERINDEXCASTPASS
#undef GEN_PASS_DECL_LOWERINDEXCASTPASS
#endif // GEN_PASS_DECL_LOWERINDEXCASTPASS
#ifdef GEN_PASS_DEF_LOWERINDEXCASTPASS
namespace impl {

template <typename DerivedT>
class LowerIndexCastPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = LowerIndexCastPassBase;

  LowerIndexCastPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LowerIndexCastPassBase(const LowerIndexCastPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("lower-index-cast");
  }
  ::llvm::StringRef getArgument() const override { return "lower-index-cast"; }

  ::llvm::StringRef getDescription() const override { return "Lower index cast on tensors to tensor dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LowerIndexCastPass");
  }
  ::llvm::StringRef getName() const override { return "LowerIndexCastPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LowerIndexCastPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LOWERINDEXCASTPASS
#endif // GEN_PASS_DEF_LOWERINDEXCASTPASS

//===----------------------------------------------------------------------===//
// MemoryCount
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_MEMORYCOUNT
#undef GEN_PASS_DECL_MEMORYCOUNT
#endif // GEN_PASS_DECL_MEMORYCOUNT
#ifdef GEN_PASS_DEF_MEMORYCOUNT
namespace impl {

template <typename DerivedT>
class MemoryCountBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = MemoryCountBase;

  MemoryCountBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  MemoryCountBase(const MemoryCountBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("memory-count");
  }
  ::llvm::StringRef getArgument() const override { return "memory-count"; }

  ::llvm::StringRef getDescription() const override { return "Test pass to count the allocated memory of a module."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("MemoryCount");
  }
  ::llvm::StringRef getName() const override { return "MemoryCount"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MemoryCountBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_MEMORYCOUNT
#endif // GEN_PASS_DEF_MEMORYCOUNT

//===----------------------------------------------------------------------===//
// OneShotBufferize
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_ONESHOTBUFFERIZE
#undef GEN_PASS_DECL_ONESHOTBUFFERIZE
#endif // GEN_PASS_DECL_ONESHOTBUFFERIZE
#ifdef GEN_PASS_DEF_ONESHOTBUFFERIZE
namespace impl {

template <typename DerivedT>
class OneShotBufferizeBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = OneShotBufferizeBase;

  OneShotBufferizeBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  OneShotBufferizeBase(const OneShotBufferizeBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("hlo-one-shot-bufferize");
  }
  ::llvm::StringRef getArgument() const override { return "hlo-one-shot-bufferize"; }

  ::llvm::StringRef getDescription() const override { return "One shot bufferization pass."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("OneShotBufferize");
  }
  ::llvm::StringRef getName() const override { return "OneShotBufferize"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(OneShotBufferizeBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_ONESHOTBUFFERIZE
#endif // GEN_PASS_DEF_ONESHOTBUFFERIZE

//===----------------------------------------------------------------------===//
// PropagateStaticShapesToKernelPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_PROPAGATESTATICSHAPESTOKERNELPASS
struct PropagateStaticShapesToKernelPassOptions {
  std::string ptr_type_opt;
};
#undef GEN_PASS_DECL_PROPAGATESTATICSHAPESTOKERNELPASS
#endif // GEN_PASS_DECL_PROPAGATESTATICSHAPESTOKERNELPASS
#ifdef GEN_PASS_DEF_PROPAGATESTATICSHAPESTOKERNELPASS
namespace impl {

template <typename DerivedT>
class PropagateStaticShapesToKernelPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = PropagateStaticShapesToKernelPassBase;

  PropagateStaticShapesToKernelPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  PropagateStaticShapesToKernelPassBase(const PropagateStaticShapesToKernelPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("propagate-static-shapes");
  }
  ::llvm::StringRef getArgument() const override { return "propagate-static-shapes"; }

  ::llvm::StringRef getDescription() const override { return "Pass to rewrite statically shaped kernel arguments to a pointer."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("PropagateStaticShapesToKernelPass");
  }
  ::llvm::StringRef getName() const override { return "PropagateStaticShapesToKernelPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(PropagateStaticShapesToKernelPassBase<DerivedT>)

  PropagateStaticShapesToKernelPassBase(const PropagateStaticShapesToKernelPassOptions &options) : PropagateStaticShapesToKernelPassBase() {
    ptr_type_opt = options.ptr_type_opt;
  }
protected:
  ::mlir::Pass::Option<std::string> ptr_type_opt{*this, "convert_pointer_args", ::llvm::cl::desc("Pointer type to convert pointer arguments to")};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_PROPAGATESTATICSHAPESTOKERNELPASS
#endif // GEN_PASS_DEF_PROPAGATESTATICSHAPESTOKERNELPASS

//===----------------------------------------------------------------------===//
// ScalarizationPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_SCALARIZATIONPASS
#undef GEN_PASS_DECL_SCALARIZATIONPASS
#endif // GEN_PASS_DECL_SCALARIZATIONPASS
#ifdef GEN_PASS_DEF_SCALARIZATIONPASS
namespace impl {

template <typename DerivedT>
class ScalarizationPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ScalarizationPassBase;

  ScalarizationPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ScalarizationPassBase(const ScalarizationPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("scalarize");
  }
  ::llvm::StringRef getArgument() const override { return "scalarize"; }

  ::llvm::StringRef getDescription() const override { return "Converts ops on tensors with 1 element to scalar ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ScalarizationPass");
  }
  ::llvm::StringRef getName() const override { return "ScalarizationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<arith::ArithDialect>();

  registry.insert<gml_st::GmlStDialect>();

  registry.insert<tensor::TensorDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ScalarizationPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_SCALARIZATIONPASS
#endif // GEN_PASS_DEF_SCALARIZATIONPASS

//===----------------------------------------------------------------------===//
// ShapeSimplification
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_SHAPESIMPLIFICATION
#undef GEN_PASS_DECL_SHAPESIMPLIFICATION
#endif // GEN_PASS_DECL_SHAPESIMPLIFICATION
#ifdef GEN_PASS_DEF_SHAPESIMPLIFICATION
namespace impl {

template <typename DerivedT>
class ShapeSimplificationBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ShapeSimplificationBase;

  ShapeSimplificationBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ShapeSimplificationBase(const ShapeSimplificationBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("shape-simplification");
  }
  ::llvm::StringRef getArgument() const override { return "shape-simplification"; }

  ::llvm::StringRef getDescription() const override { return "Simplify shape ops"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ShapeSimplification");
  }
  ::llvm::StringRef getName() const override { return "ShapeSimplification"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ShapeSimplificationBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_SHAPESIMPLIFICATION
#endif // GEN_PASS_DEF_SHAPESIMPLIFICATION

//===----------------------------------------------------------------------===//
// SymbolicShapeOptimization
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_SYMBOLICSHAPEOPTIMIZATION
#undef GEN_PASS_DECL_SYMBOLICSHAPEOPTIMIZATION
#endif // GEN_PASS_DECL_SYMBOLICSHAPEOPTIMIZATION
#ifdef GEN_PASS_DEF_SYMBOLICSHAPEOPTIMIZATION
namespace impl {

template <typename DerivedT>
class SymbolicShapeOptimizationBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = SymbolicShapeOptimizationBase;

  SymbolicShapeOptimizationBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  SymbolicShapeOptimizationBase(const SymbolicShapeOptimizationBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("symbolic-shape-optimization");
  }
  ::llvm::StringRef getArgument() const override { return "symbolic-shape-optimization"; }

  ::llvm::StringRef getDescription() const override { return "Analyzes shapes and performs shape-related optimizations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SymbolicShapeOptimization");
  }
  ::llvm::StringRef getName() const override { return "SymbolicShapeOptimization"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SymbolicShapeOptimizationBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_SYMBOLICSHAPEOPTIMIZATION
#endif // GEN_PASS_DEF_SYMBOLICSHAPEOPTIMIZATION

//===----------------------------------------------------------------------===//
// TestShapeComponentAnalysis
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TESTSHAPECOMPONENTANALYSIS
#undef GEN_PASS_DECL_TESTSHAPECOMPONENTANALYSIS
#endif // GEN_PASS_DECL_TESTSHAPECOMPONENTANALYSIS
#ifdef GEN_PASS_DEF_TESTSHAPECOMPONENTANALYSIS
namespace impl {

template <typename DerivedT>
class TestShapeComponentAnalysisBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = TestShapeComponentAnalysisBase;

  TestShapeComponentAnalysisBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TestShapeComponentAnalysisBase(const TestShapeComponentAnalysisBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("test-print-shape-components");
  }
  ::llvm::StringRef getArgument() const override { return "test-print-shape-components"; }

  ::llvm::StringRef getDescription() const override { return "Test pass for analyzing shape components."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TestShapeComponentAnalysis");
  }
  ::llvm::StringRef getName() const override { return "TestShapeComponentAnalysis"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TestShapeComponentAnalysisBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TESTSHAPECOMPONENTANALYSIS
#endif // GEN_PASS_DEF_TESTSHAPECOMPONENTANALYSIS

//===----------------------------------------------------------------------===//
// TestUserange
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TESTUSERANGE
#undef GEN_PASS_DECL_TESTUSERANGE
#endif // GEN_PASS_DECL_TESTUSERANGE
#ifdef GEN_PASS_DEF_TESTUSERANGE
namespace impl {

template <typename DerivedT>
class TestUserangeBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = TestUserangeBase;

  TestUserangeBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TestUserangeBase(const TestUserangeBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("test-print-userange");
  }
  ::llvm::StringRef getArgument() const override { return "test-print-userange"; }

  ::llvm::StringRef getDescription() const override { return "Test pass for checking userange intervals."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TestUserange");
  }
  ::llvm::StringRef getName() const override { return "TestUserange"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TestUserangeBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TESTUSERANGE
#endif // GEN_PASS_DEF_TESTUSERANGE

//===----------------------------------------------------------------------===//
// TileLoopsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TILELOOPSPASS
struct TileLoopsPassOptions {
  ::llvm::ArrayRef<int64_t> tile_sizes_;
  ::llvm::ArrayRef<int64_t> unroll_factors_;
};
#undef GEN_PASS_DECL_TILELOOPSPASS
#endif // GEN_PASS_DECL_TILELOOPSPASS
#ifdef GEN_PASS_DEF_TILELOOPSPASS
namespace impl {

template <typename DerivedT>
class TileLoopsPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = TileLoopsPassBase;

  TileLoopsPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TileLoopsPassBase(const TileLoopsPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tile-loops");
  }
  ::llvm::StringRef getArgument() const override { return "tile-loops"; }

  ::llvm::StringRef getDescription() const override { return "Tiles parallel loops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TileLoopsPass");
  }
  ::llvm::StringRef getName() const override { return "TileLoopsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<AffineDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TileLoopsPassBase<DerivedT>)

  TileLoopsPassBase(const TileLoopsPassOptions &options) : TileLoopsPassBase() {
    tile_sizes_ = options.tile_sizes_;
    unroll_factors_ = options.unroll_factors_;
  }
protected:
  ::mlir::Pass::ListOption<int64_t> tile_sizes_{*this, "tile-sizes", ::llvm::cl::desc("The size of the tile in each dimension, expressed as the number of `unroll_factors_` in that dimension."), llvm::cl::ZeroOrMore};
  ::mlir::Pass::ListOption<int64_t> unroll_factors_{*this, "unroll-factors", ::llvm::cl::desc("The unroll factor in each dimension, expressed as the number of elements in that dimension."), llvm::cl::ZeroOrMore};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TILELOOPSPASS
#endif // GEN_PASS_DEF_TILELOOPSPASS

//===----------------------------------------------------------------------===//
// UnbufferizePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_UNBUFFERIZEPASS
#undef GEN_PASS_DECL_UNBUFFERIZEPASS
#endif // GEN_PASS_DECL_UNBUFFERIZEPASS
#ifdef GEN_PASS_DEF_UNBUFFERIZEPASS
namespace impl {

template <typename DerivedT>
class UnbufferizePassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = UnbufferizePassBase;

  UnbufferizePassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  UnbufferizePassBase(const UnbufferizePassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("unbufferize");
  }
  ::llvm::StringRef getArgument() const override { return "unbufferize"; }

  ::llvm::StringRef getDescription() const override { return "Unbufferize partially bufferized functions."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("UnbufferizePass");
  }
  ::llvm::StringRef getName() const override { return "UnbufferizePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(UnbufferizePassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_UNBUFFERIZEPASS
#endif // GEN_PASS_DEF_UNBUFFERIZEPASS

//===----------------------------------------------------------------------===//
// UnrollLoopsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_UNROLLLOOPSPASS
#undef GEN_PASS_DECL_UNROLLLOOPSPASS
#endif // GEN_PASS_DECL_UNROLLLOOPSPASS
#ifdef GEN_PASS_DEF_UNROLLLOOPSPASS
namespace impl {

template <typename DerivedT>
class UnrollLoopsPassBase : public ::mlir::OperationPass<> {
public:
  using Base = UnrollLoopsPassBase;

  UnrollLoopsPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  UnrollLoopsPassBase(const UnrollLoopsPassBase &other) : ::mlir::OperationPass<>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("unroll-loops");
  }
  ::llvm::StringRef getArgument() const override { return "unroll-loops"; }

  ::llvm::StringRef getDescription() const override { return "Unrolls scf.for loops with small static iteration counts."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("UnrollLoopsPass");
  }
  ::llvm::StringRef getName() const override { return "UnrollLoopsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(UnrollLoopsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_UNROLLLOOPSPASS
#endif // GEN_PASS_DEF_UNROLLLOOPSPASS
#ifdef GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// AllocToArgPass Registration
//===----------------------------------------------------------------------===//

inline void registerAllocToArgPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return hlo::createAllocToArgPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerAllocToArgPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return hlo::createAllocToArgPass();
  });
}

//===----------------------------------------------------------------------===//
// BufferPacking Registration
//===----------------------------------------------------------------------===//

inline void registerBufferPacking() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createBufferPackingPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerBufferPackingPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createBufferPackingPass();
  });
}

//===----------------------------------------------------------------------===//
// BufferReuse Registration
//===----------------------------------------------------------------------===//

inline void registerBufferReuse() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createBufferReusePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerBufferReusePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createBufferReusePass();
  });
}

//===----------------------------------------------------------------------===//
// CollapseParallelLoopsTo1DPass Registration
//===----------------------------------------------------------------------===//

inline void registerCollapseParallelLoopsTo1DPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createCollapseParallelLoopsTo1DPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerCollapseParallelLoopsTo1DPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createCollapseParallelLoopsTo1DPass();
  });
}

//===----------------------------------------------------------------------===//
// ComputeOpAndFuncBufferizePass Registration
//===----------------------------------------------------------------------===//

inline void registerComputeOpAndFuncBufferizePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createComputeOpAndFuncBufferizePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerComputeOpAndFuncBufferizePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createComputeOpAndFuncBufferizePass();
  });
}

//===----------------------------------------------------------------------===//
// CopyRemoval Registration
//===----------------------------------------------------------------------===//

inline void registerCopyRemoval() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createCopyRemovalPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerCopyRemovalPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createCopyRemovalPass();
  });
}

//===----------------------------------------------------------------------===//
// DetensorizeScfOpsPass Registration
//===----------------------------------------------------------------------===//

inline void registerDetensorizeScfOpsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createDetensorizeScfOpsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerDetensorizeScfOpsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createDetensorizeScfOpsPass();
  });
}

//===----------------------------------------------------------------------===//
// FinalBufferizePass Registration
//===----------------------------------------------------------------------===//

inline void registerFinalBufferizePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createFinalBufferizePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerFinalBufferizePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createFinalBufferizePass();
  });
}

//===----------------------------------------------------------------------===//
// GenericHostToLLVMPass Registration
//===----------------------------------------------------------------------===//

inline void registerGenericHostToLLVMPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return hlo::createGenericHostToLLVMPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerGenericHostToLLVMPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return hlo::createGenericHostToLLVMPass();
  });
}

//===----------------------------------------------------------------------===//
// LowerIndexCastPass Registration
//===----------------------------------------------------------------------===//

inline void registerLowerIndexCastPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLowerIndexCastPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLowerIndexCastPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLowerIndexCastPass();
  });
}

//===----------------------------------------------------------------------===//
// MemoryCount Registration
//===----------------------------------------------------------------------===//

inline void registerMemoryCount() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createMemoryCountPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerMemoryCountPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createMemoryCountPass();
  });
}

//===----------------------------------------------------------------------===//
// OneShotBufferize Registration
//===----------------------------------------------------------------------===//

inline void registerOneShotBufferize() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return hlo::createOneShotBufferizePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerOneShotBufferizePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return hlo::createOneShotBufferizePass();
  });
}

//===----------------------------------------------------------------------===//
// PropagateStaticShapesToKernelPass Registration
//===----------------------------------------------------------------------===//

inline void registerPropagateStaticShapesToKernelPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createPropagateStaticShapesToKernelPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerPropagateStaticShapesToKernelPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createPropagateStaticShapesToKernelPass();
  });
}

//===----------------------------------------------------------------------===//
// ScalarizationPass Registration
//===----------------------------------------------------------------------===//

inline void registerScalarizationPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createScalarizationPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerScalarizationPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createScalarizationPass();
  });
}

//===----------------------------------------------------------------------===//
// ShapeSimplification Registration
//===----------------------------------------------------------------------===//

inline void registerShapeSimplification() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createShapeSimplification();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerShapeSimplificationPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createShapeSimplification();
  });
}

//===----------------------------------------------------------------------===//
// SymbolicShapeOptimization Registration
//===----------------------------------------------------------------------===//

inline void registerSymbolicShapeOptimization() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createSymbolicShapeOptimizationPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerSymbolicShapeOptimizationPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createSymbolicShapeOptimizationPass();
  });
}

//===----------------------------------------------------------------------===//
// TestShapeComponentAnalysis Registration
//===----------------------------------------------------------------------===//

inline void registerTestShapeComponentAnalysis() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTestShapeComponentAnalysisPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTestShapeComponentAnalysisPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTestShapeComponentAnalysisPass();
  });
}

//===----------------------------------------------------------------------===//
// TestUserange Registration
//===----------------------------------------------------------------------===//

inline void registerTestUserange() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTestUserangePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTestUserangePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTestUserangePass();
  });
}

//===----------------------------------------------------------------------===//
// TileLoopsPass Registration
//===----------------------------------------------------------------------===//

inline void registerTileLoopsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTileLoopsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTileLoopsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTileLoopsPass();
  });
}

//===----------------------------------------------------------------------===//
// UnbufferizePass Registration
//===----------------------------------------------------------------------===//

inline void registerUnbufferizePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return hlo::createUnbufferizePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerUnbufferizePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return hlo::createUnbufferizePass();
  });
}

//===----------------------------------------------------------------------===//
// UnrollLoopsPass Registration
//===----------------------------------------------------------------------===//

inline void registerUnrollLoopsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return hlo::createUnrollLoopsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerUnrollLoopsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return hlo::createUnrollLoopsPass();
  });
}

//===----------------------------------------------------------------------===//
// LMHLOTransforms Registration
//===----------------------------------------------------------------------===//

inline void registerLMHLOTransformsPasses() {
  registerAllocToArgPass();
  registerBufferPacking();
  registerBufferReuse();
  registerCollapseParallelLoopsTo1DPass();
  registerComputeOpAndFuncBufferizePass();
  registerCopyRemoval();
  registerDetensorizeScfOpsPass();
  registerFinalBufferizePass();
  registerGenericHostToLLVMPass();
  registerLowerIndexCastPass();
  registerMemoryCount();
  registerOneShotBufferize();
  registerPropagateStaticShapesToKernelPass();
  registerScalarizationPass();
  registerShapeSimplification();
  registerSymbolicShapeOptimization();
  registerTestShapeComponentAnalysis();
  registerTestUserange();
  registerTileLoopsPass();
  registerUnbufferizePass();
  registerUnrollLoopsPass();
}
#undef GEN_PASS_REGISTRATION
#endif // GEN_PASS_REGISTRATION
// Deprecated. Please use the new per-pass macros.
#ifdef GEN_PASS_CLASSES

template <typename DerivedT>
class AllocToArgPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = AllocToArgPassBase;

  AllocToArgPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  AllocToArgPassBase(const AllocToArgPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("alloc-to-arg");
  }
  ::llvm::StringRef getArgument() const override { return "alloc-to-arg"; }

  ::llvm::StringRef getDescription() const override { return "Hoist memref allocations to function arguments."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AllocToArgPass");
  }
  ::llvm::StringRef getName() const override { return "AllocToArgPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AllocToArgPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class BufferPackingBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = BufferPackingBase;

  BufferPackingBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  BufferPackingBase(const BufferPackingBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("buffer-packing");
  }
  ::llvm::StringRef getArgument() const override { return "buffer-packing"; }

  ::llvm::StringRef getDescription() const override { return "Pass to pack allocated buffer to reduce memory consumption."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("BufferPacking");
  }
  ::llvm::StringRef getName() const override { return "BufferPacking"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<func::FuncDialect>();

  registry.insert<memref::MemRefDialect>();

  registry.insert<arith::ArithDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(BufferPackingBase<DerivedT>)

protected:
  ::mlir::Pass::Option<unsigned> window_size_{*this, "window-size", ::llvm::cl::desc("The window size blurs the start position of anallocated buffer. Buffers allocated in the same sliding window areaare treated equally in terms of starting position, withing thesliding window area they are sorted by memory size.A window size of zero sorts the buffers only by memory size."), ::llvm::cl::init(5)};
};

template <typename DerivedT>
class BufferReuseBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = BufferReuseBase;

  BufferReuseBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  BufferReuseBase(const BufferReuseBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("buffer-reuse");
  }
  ::llvm::StringRef getArgument() const override { return "buffer-reuse"; }

  ::llvm::StringRef getDescription() const override { return "Reuses already allocated buffers to save allocation operations if it is provably safe."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("BufferReuse");
  }
  ::llvm::StringRef getName() const override { return "BufferReuse"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(BufferReuseBase<DerivedT>)

protected:
};

template <typename DerivedT>
class CollapseParallelLoopsTo1DPassBase : public ::mlir::OperationPass<> {
public:
  using Base = CollapseParallelLoopsTo1DPassBase;

  CollapseParallelLoopsTo1DPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  CollapseParallelLoopsTo1DPassBase(const CollapseParallelLoopsTo1DPassBase &other) : ::mlir::OperationPass<>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("collapse-parallel-loops-to-1d");
  }
  ::llvm::StringRef getArgument() const override { return "collapse-parallel-loops-to-1d"; }

  ::llvm::StringRef getDescription() const override { return "Collapses multidimensional loops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("CollapseParallelLoopsTo1DPass");
  }
  ::llvm::StringRef getName() const override { return "CollapseParallelLoopsTo1DPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(CollapseParallelLoopsTo1DPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ComputeOpAndFuncBufferizePassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ComputeOpAndFuncBufferizePassBase;

  ComputeOpAndFuncBufferizePassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ComputeOpAndFuncBufferizePassBase(const ComputeOpAndFuncBufferizePassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("computeop-and-func-bufferize");
  }
  ::llvm::StringRef getArgument() const override { return "computeop-and-func-bufferize"; }

  ::llvm::StringRef getDescription() const override { return "Pass to transform compute operations (hlo and linalg) on values to buffer based ones."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ComputeOpAndFuncBufferizePass");
  }
  ::llvm::StringRef getName() const override { return "ComputeOpAndFuncBufferizePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ComputeOpAndFuncBufferizePassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class CopyRemovalBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = CopyRemovalBase;

  CopyRemovalBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  CopyRemovalBase(const CopyRemovalBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("copy-removal");
  }
  ::llvm::StringRef getArgument() const override { return "copy-removal"; }

  ::llvm::StringRef getDescription() const override { return "Removes redundant operations that implement a CopyOpInterface, if the intersection of the useranges fromcopy source and target only contains the CopyOp."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("CopyRemoval");
  }
  ::llvm::StringRef getName() const override { return "CopyRemoval"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(CopyRemovalBase<DerivedT>)

protected:
};

template <typename DerivedT>
class DetensorizeScfOpsPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = DetensorizeScfOpsPassBase;

  DetensorizeScfOpsPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  DetensorizeScfOpsPassBase(const DetensorizeScfOpsPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("detensorize-scf-ops");
  }
  ::llvm::StringRef getArgument() const override { return "detensorize-scf-ops"; }

  ::llvm::StringRef getDescription() const override { return "Detensorize arguments of SCF ops where possible."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("DetensorizeScfOpsPass");
  }
  ::llvm::StringRef getName() const override { return "DetensorizeScfOpsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<scf::SCFDialect>();

  registry.insert<tensor::TensorDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(DetensorizeScfOpsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class FinalBufferizePassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = FinalBufferizePassBase;

  FinalBufferizePassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  FinalBufferizePassBase(const FinalBufferizePassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("final-bufferize");
  }
  ::llvm::StringRef getArgument() const override { return "final-bufferize"; }

  ::llvm::StringRef getDescription() const override { return "Pass to transform late operations on values to buffer based ones."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("FinalBufferizePass");
  }
  ::llvm::StringRef getName() const override { return "FinalBufferizePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(FinalBufferizePassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<uint64_t> alignment_{*this, "alignment", ::llvm::cl::desc("Memory alignment"), ::llvm::cl::init(64)};
};

template <typename DerivedT>
class GenericHostToLLVMPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = GenericHostToLLVMPassBase;

  GenericHostToLLVMPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  GenericHostToLLVMPassBase(const GenericHostToLLVMPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("generic-host-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "generic-host-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return "Pass to lower common dialects resulting from HLO to LLVM."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("GenericHostToLLVMPass");
  }
  ::llvm::StringRef getName() const override { return "GenericHostToLLVMPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(GenericHostToLLVMPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class LowerIndexCastPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = LowerIndexCastPassBase;

  LowerIndexCastPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LowerIndexCastPassBase(const LowerIndexCastPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("lower-index-cast");
  }
  ::llvm::StringRef getArgument() const override { return "lower-index-cast"; }

  ::llvm::StringRef getDescription() const override { return "Lower index cast on tensors to tensor dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LowerIndexCastPass");
  }
  ::llvm::StringRef getName() const override { return "LowerIndexCastPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LowerIndexCastPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class MemoryCountBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = MemoryCountBase;

  MemoryCountBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  MemoryCountBase(const MemoryCountBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("memory-count");
  }
  ::llvm::StringRef getArgument() const override { return "memory-count"; }

  ::llvm::StringRef getDescription() const override { return "Test pass to count the allocated memory of a module."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("MemoryCount");
  }
  ::llvm::StringRef getName() const override { return "MemoryCount"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MemoryCountBase<DerivedT>)

protected:
};

template <typename DerivedT>
class OneShotBufferizeBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = OneShotBufferizeBase;

  OneShotBufferizeBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  OneShotBufferizeBase(const OneShotBufferizeBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("hlo-one-shot-bufferize");
  }
  ::llvm::StringRef getArgument() const override { return "hlo-one-shot-bufferize"; }

  ::llvm::StringRef getDescription() const override { return "One shot bufferization pass."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("OneShotBufferize");
  }
  ::llvm::StringRef getName() const override { return "OneShotBufferize"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(OneShotBufferizeBase<DerivedT>)

protected:
};

template <typename DerivedT>
class PropagateStaticShapesToKernelPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = PropagateStaticShapesToKernelPassBase;

  PropagateStaticShapesToKernelPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  PropagateStaticShapesToKernelPassBase(const PropagateStaticShapesToKernelPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("propagate-static-shapes");
  }
  ::llvm::StringRef getArgument() const override { return "propagate-static-shapes"; }

  ::llvm::StringRef getDescription() const override { return "Pass to rewrite statically shaped kernel arguments to a pointer."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("PropagateStaticShapesToKernelPass");
  }
  ::llvm::StringRef getName() const override { return "PropagateStaticShapesToKernelPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(PropagateStaticShapesToKernelPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<std::string> ptr_type_opt{*this, "convert_pointer_args", ::llvm::cl::desc("Pointer type to convert pointer arguments to")};
};

template <typename DerivedT>
class ScalarizationPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ScalarizationPassBase;

  ScalarizationPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ScalarizationPassBase(const ScalarizationPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("scalarize");
  }
  ::llvm::StringRef getArgument() const override { return "scalarize"; }

  ::llvm::StringRef getDescription() const override { return "Converts ops on tensors with 1 element to scalar ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ScalarizationPass");
  }
  ::llvm::StringRef getName() const override { return "ScalarizationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<arith::ArithDialect>();

  registry.insert<gml_st::GmlStDialect>();

  registry.insert<tensor::TensorDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ScalarizationPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ShapeSimplificationBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ShapeSimplificationBase;

  ShapeSimplificationBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ShapeSimplificationBase(const ShapeSimplificationBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("shape-simplification");
  }
  ::llvm::StringRef getArgument() const override { return "shape-simplification"; }

  ::llvm::StringRef getDescription() const override { return "Simplify shape ops"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ShapeSimplification");
  }
  ::llvm::StringRef getName() const override { return "ShapeSimplification"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ShapeSimplificationBase<DerivedT>)

protected:
};

template <typename DerivedT>
class SymbolicShapeOptimizationBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = SymbolicShapeOptimizationBase;

  SymbolicShapeOptimizationBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  SymbolicShapeOptimizationBase(const SymbolicShapeOptimizationBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("symbolic-shape-optimization");
  }
  ::llvm::StringRef getArgument() const override { return "symbolic-shape-optimization"; }

  ::llvm::StringRef getDescription() const override { return "Analyzes shapes and performs shape-related optimizations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SymbolicShapeOptimization");
  }
  ::llvm::StringRef getName() const override { return "SymbolicShapeOptimization"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SymbolicShapeOptimizationBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TestShapeComponentAnalysisBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = TestShapeComponentAnalysisBase;

  TestShapeComponentAnalysisBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TestShapeComponentAnalysisBase(const TestShapeComponentAnalysisBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("test-print-shape-components");
  }
  ::llvm::StringRef getArgument() const override { return "test-print-shape-components"; }

  ::llvm::StringRef getDescription() const override { return "Test pass for analyzing shape components."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TestShapeComponentAnalysis");
  }
  ::llvm::StringRef getName() const override { return "TestShapeComponentAnalysis"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TestShapeComponentAnalysisBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TestUserangeBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = TestUserangeBase;

  TestUserangeBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TestUserangeBase(const TestUserangeBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("test-print-userange");
  }
  ::llvm::StringRef getArgument() const override { return "test-print-userange"; }

  ::llvm::StringRef getDescription() const override { return "Test pass for checking userange intervals."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TestUserange");
  }
  ::llvm::StringRef getName() const override { return "TestUserange"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TestUserangeBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TileLoopsPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = TileLoopsPassBase;

  TileLoopsPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TileLoopsPassBase(const TileLoopsPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tile-loops");
  }
  ::llvm::StringRef getArgument() const override { return "tile-loops"; }

  ::llvm::StringRef getDescription() const override { return "Tiles parallel loops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TileLoopsPass");
  }
  ::llvm::StringRef getName() const override { return "TileLoopsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<AffineDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TileLoopsPassBase<DerivedT>)

protected:
  ::mlir::Pass::ListOption<int64_t> tile_sizes_{*this, "tile-sizes", ::llvm::cl::desc("The size of the tile in each dimension, expressed as the number of `unroll_factors_` in that dimension."), llvm::cl::ZeroOrMore};
  ::mlir::Pass::ListOption<int64_t> unroll_factors_{*this, "unroll-factors", ::llvm::cl::desc("The unroll factor in each dimension, expressed as the number of elements in that dimension."), llvm::cl::ZeroOrMore};
};

template <typename DerivedT>
class UnbufferizePassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = UnbufferizePassBase;

  UnbufferizePassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  UnbufferizePassBase(const UnbufferizePassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("unbufferize");
  }
  ::llvm::StringRef getArgument() const override { return "unbufferize"; }

  ::llvm::StringRef getDescription() const override { return "Unbufferize partially bufferized functions."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("UnbufferizePass");
  }
  ::llvm::StringRef getName() const override { return "UnbufferizePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(UnbufferizePassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class UnrollLoopsPassBase : public ::mlir::OperationPass<> {
public:
  using Base = UnrollLoopsPassBase;

  UnrollLoopsPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  UnrollLoopsPassBase(const UnrollLoopsPassBase &other) : ::mlir::OperationPass<>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("unroll-loops");
  }
  ::llvm::StringRef getArgument() const override { return "unroll-loops"; }

  ::llvm::StringRef getDescription() const override { return "Unrolls scf.for loops with small static iteration counts."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("UnrollLoopsPass");
  }
  ::llvm::StringRef getName() const override { return "UnrollLoopsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(UnrollLoopsPassBase<DerivedT>)

protected:
};
#undef GEN_PASS_CLASSES
#endif // GEN_PASS_CLASSES
