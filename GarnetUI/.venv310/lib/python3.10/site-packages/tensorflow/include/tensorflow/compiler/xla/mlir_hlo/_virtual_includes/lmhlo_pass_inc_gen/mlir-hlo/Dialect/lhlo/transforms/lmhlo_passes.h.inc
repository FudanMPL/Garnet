/* Autogenerated by mlir-tblgen; don't manually edit */

#ifdef GEN_PASS_DECL
// Generate declarations for all passes.
#define GEN_PASS_DECL_LEGALIZETOTENSOROPPASS
#define GEN_PASS_DECL_LHLOFUSELINALGPASS
#define GEN_PASS_DECL_LHLOLEGALIZETOAFFINEPASS
#define GEN_PASS_DECL_LHLOLEGALIZETOGPUPASS
#define GEN_PASS_DECL_LHLOLEGALIZETOPARALLELLOOPSPASS
#undef GEN_PASS_DECL
#endif // GEN_PASS_DECL

//===----------------------------------------------------------------------===//
// LegalizeToTensorOpPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LEGALIZETOTENSOROPPASS
#undef GEN_PASS_DECL_LEGALIZETOTENSOROPPASS
#endif // GEN_PASS_DECL_LEGALIZETOTENSOROPPASS
#ifdef GEN_PASS_DEF_LEGALIZETOTENSOROPPASS
namespace impl {

template <typename DerivedT>
class LegalizeToTensorOpPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LegalizeToTensorOpPassBase;

  LegalizeToTensorOpPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LegalizeToTensorOpPassBase(const LegalizeToTensorOpPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("lhlo-legalize-to-tensor-op");
  }
  ::llvm::StringRef getArgument() const override { return "lhlo-legalize-to-tensor-op"; }

  ::llvm::StringRef getDescription() const override { return "Legalize bufferization.to_tensor ops inserted during mhlo to lmhlo conversion."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LegalizeToTensorOpPass");
  }
  ::llvm::StringRef getName() const override { return "LegalizeToTensorOpPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LegalizeToTensorOpPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LEGALIZETOTENSOROPPASS
#endif // GEN_PASS_DEF_LEGALIZETOTENSOROPPASS

//===----------------------------------------------------------------------===//
// LhloFuseLinalgPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LHLOFUSELINALGPASS
struct LhloFuseLinalgPassOptions {
  bool use_parallel_loops_ = false;
  ::llvm::ArrayRef<unsigned> tile_sizes_;
};
#undef GEN_PASS_DECL_LHLOFUSELINALGPASS
#endif // GEN_PASS_DECL_LHLOFUSELINALGPASS
#ifdef GEN_PASS_DEF_LHLOFUSELINALGPASS
namespace impl {

template <typename DerivedT>
class LhloFuseLinalgPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LhloFuseLinalgPassBase;

  LhloFuseLinalgPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LhloFuseLinalgPassBase(const LhloFuseLinalgPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("lhlo-fuse-linalg");
  }
  ::llvm::StringRef getArgument() const override { return "lhlo-fuse-linalg"; }

  ::llvm::StringRef getDescription() const override { return "Greedily fuse linalg ops obtained after LHLO lowering."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LhloFuseLinalgPass");
  }
  ::llvm::StringRef getName() const override { return "LhloFuseLinalgPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LhloFuseLinalgPassBase<DerivedT>)

  LhloFuseLinalgPassBase(const LhloFuseLinalgPassOptions &options) : LhloFuseLinalgPassBase() {
    use_parallel_loops_ = options.use_parallel_loops_;
    tile_sizes_ = options.tile_sizes_;
  }
protected:
  ::mlir::Pass::Option<bool> use_parallel_loops_{*this, "use-parallel-loops", ::llvm::cl::desc("Tiles GenericOp consumer to parallel loops before linalg fusion"), ::llvm::cl::init(false)};
  ::mlir::Pass::ListOption<unsigned> tile_sizes_{*this, "tile-sizes", ::llvm::cl::desc("Faster memory space number to promote fusion buffers to"), llvm::cl::ZeroOrMore};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LHLOFUSELINALGPASS
#endif // GEN_PASS_DEF_LHLOFUSELINALGPASS

//===----------------------------------------------------------------------===//
// LhloLegalizeToAffinePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LHLOLEGALIZETOAFFINEPASS
#undef GEN_PASS_DECL_LHLOLEGALIZETOAFFINEPASS
#endif // GEN_PASS_DECL_LHLOLEGALIZETOAFFINEPASS
#ifdef GEN_PASS_DEF_LHLOLEGALIZETOAFFINEPASS
namespace impl {

template <typename DerivedT>
class LhloLegalizeToAffinePassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LhloLegalizeToAffinePassBase;

  LhloLegalizeToAffinePassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LhloLegalizeToAffinePassBase(const LhloLegalizeToAffinePassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("lhlo-legalize-to-affine");
  }
  ::llvm::StringRef getArgument() const override { return "lhlo-legalize-to-affine"; }

  ::llvm::StringRef getDescription() const override { return "Legalize from LHLO dialect to affine dialect."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LhloLegalizeToAffinePass");
  }
  ::llvm::StringRef getName() const override { return "LhloLegalizeToAffinePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LhloLegalizeToAffinePassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LHLOLEGALIZETOAFFINEPASS
#endif // GEN_PASS_DEF_LHLOLEGALIZETOAFFINEPASS

//===----------------------------------------------------------------------===//
// LhloLegalizeToGpuPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LHLOLEGALIZETOGPUPASS
#undef GEN_PASS_DECL_LHLOLEGALIZETOGPUPASS
#endif // GEN_PASS_DECL_LHLOLEGALIZETOGPUPASS
#ifdef GEN_PASS_DEF_LHLOLEGALIZETOGPUPASS
namespace impl {

template <typename DerivedT>
class LhloLegalizeToGpuPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LhloLegalizeToGpuPassBase;

  LhloLegalizeToGpuPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LhloLegalizeToGpuPassBase(const LhloLegalizeToGpuPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("lhlo-legalize-to-gpu");
  }
  ::llvm::StringRef getArgument() const override { return "lhlo-legalize-to-gpu"; }

  ::llvm::StringRef getDescription() const override { return "Legalize from LHLO dialect to GPU dialect."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LhloLegalizeToGpuPass");
  }
  ::llvm::StringRef getName() const override { return "LhloLegalizeToGpuPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LhloLegalizeToGpuPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LHLOLEGALIZETOGPUPASS
#endif // GEN_PASS_DEF_LHLOLEGALIZETOGPUPASS

//===----------------------------------------------------------------------===//
// LhloLegalizeToParallelLoopsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LHLOLEGALIZETOPARALLELLOOPSPASS
#undef GEN_PASS_DECL_LHLOLEGALIZETOPARALLELLOOPSPASS
#endif // GEN_PASS_DECL_LHLOLEGALIZETOPARALLELLOOPSPASS
#ifdef GEN_PASS_DEF_LHLOLEGALIZETOPARALLELLOOPSPASS
namespace impl {

template <typename DerivedT>
class LhloLegalizeToParallelLoopsPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LhloLegalizeToParallelLoopsPassBase;

  LhloLegalizeToParallelLoopsPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LhloLegalizeToParallelLoopsPassBase(const LhloLegalizeToParallelLoopsPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("lhlo-legalize-to-parallel-loops");
  }
  ::llvm::StringRef getArgument() const override { return "lhlo-legalize-to-parallel-loops"; }

  ::llvm::StringRef getDescription() const override { return "Legalize from LHLO dialect to parallel loops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LhloLegalizeToParallelLoopsPass");
  }
  ::llvm::StringRef getName() const override { return "LhloLegalizeToParallelLoopsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LhloLegalizeToParallelLoopsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LHLOLEGALIZETOPARALLELLOOPSPASS
#endif // GEN_PASS_DEF_LHLOLEGALIZETOPARALLELLOOPSPASS
#ifdef GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// LegalizeToTensorOpPass Registration
//===----------------------------------------------------------------------===//

inline void registerLegalizeToTensorOpPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLegalizeToTensorOpPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLegalizeToTensorOpPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLegalizeToTensorOpPass();
  });
}

//===----------------------------------------------------------------------===//
// LhloFuseLinalgPass Registration
//===----------------------------------------------------------------------===//

inline void registerLhloFuseLinalgPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLhloFuseLinalgPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLhloFuseLinalgPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLhloFuseLinalgPass();
  });
}

//===----------------------------------------------------------------------===//
// LhloLegalizeToAffinePass Registration
//===----------------------------------------------------------------------===//

inline void registerLhloLegalizeToAffinePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLhloLegalizeToAffinePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLhloLegalizeToAffinePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLhloLegalizeToAffinePass();
  });
}

//===----------------------------------------------------------------------===//
// LhloLegalizeToGpuPass Registration
//===----------------------------------------------------------------------===//

inline void registerLhloLegalizeToGpuPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLegalizeToGpuPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLhloLegalizeToGpuPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLegalizeToGpuPass();
  });
}

//===----------------------------------------------------------------------===//
// LhloLegalizeToParallelLoopsPass Registration
//===----------------------------------------------------------------------===//

inline void registerLhloLegalizeToParallelLoopsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLegalizeLhloToParallelLoopsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLhloLegalizeToParallelLoopsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLegalizeLhloToParallelLoopsPass();
  });
}

//===----------------------------------------------------------------------===//
// AllLmhlo Registration
//===----------------------------------------------------------------------===//

inline void registerAllLmhloPasses() {
  registerLegalizeToTensorOpPass();
  registerLhloFuseLinalgPass();
  registerLhloLegalizeToAffinePass();
  registerLhloLegalizeToGpuPass();
  registerLhloLegalizeToParallelLoopsPass();
}
#undef GEN_PASS_REGISTRATION
#endif // GEN_PASS_REGISTRATION
// Deprecated. Please use the new per-pass macros.
#ifdef GEN_PASS_CLASSES

template <typename DerivedT>
class LegalizeToTensorOpPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LegalizeToTensorOpPassBase;

  LegalizeToTensorOpPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LegalizeToTensorOpPassBase(const LegalizeToTensorOpPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("lhlo-legalize-to-tensor-op");
  }
  ::llvm::StringRef getArgument() const override { return "lhlo-legalize-to-tensor-op"; }

  ::llvm::StringRef getDescription() const override { return "Legalize bufferization.to_tensor ops inserted during mhlo to lmhlo conversion."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LegalizeToTensorOpPass");
  }
  ::llvm::StringRef getName() const override { return "LegalizeToTensorOpPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LegalizeToTensorOpPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class LhloFuseLinalgPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LhloFuseLinalgPassBase;

  LhloFuseLinalgPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LhloFuseLinalgPassBase(const LhloFuseLinalgPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("lhlo-fuse-linalg");
  }
  ::llvm::StringRef getArgument() const override { return "lhlo-fuse-linalg"; }

  ::llvm::StringRef getDescription() const override { return "Greedily fuse linalg ops obtained after LHLO lowering."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LhloFuseLinalgPass");
  }
  ::llvm::StringRef getName() const override { return "LhloFuseLinalgPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LhloFuseLinalgPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> use_parallel_loops_{*this, "use-parallel-loops", ::llvm::cl::desc("Tiles GenericOp consumer to parallel loops before linalg fusion"), ::llvm::cl::init(false)};
  ::mlir::Pass::ListOption<unsigned> tile_sizes_{*this, "tile-sizes", ::llvm::cl::desc("Faster memory space number to promote fusion buffers to"), llvm::cl::ZeroOrMore};
};

template <typename DerivedT>
class LhloLegalizeToAffinePassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LhloLegalizeToAffinePassBase;

  LhloLegalizeToAffinePassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LhloLegalizeToAffinePassBase(const LhloLegalizeToAffinePassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("lhlo-legalize-to-affine");
  }
  ::llvm::StringRef getArgument() const override { return "lhlo-legalize-to-affine"; }

  ::llvm::StringRef getDescription() const override { return "Legalize from LHLO dialect to affine dialect."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LhloLegalizeToAffinePass");
  }
  ::llvm::StringRef getName() const override { return "LhloLegalizeToAffinePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LhloLegalizeToAffinePassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class LhloLegalizeToGpuPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LhloLegalizeToGpuPassBase;

  LhloLegalizeToGpuPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LhloLegalizeToGpuPassBase(const LhloLegalizeToGpuPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("lhlo-legalize-to-gpu");
  }
  ::llvm::StringRef getArgument() const override { return "lhlo-legalize-to-gpu"; }

  ::llvm::StringRef getDescription() const override { return "Legalize from LHLO dialect to GPU dialect."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LhloLegalizeToGpuPass");
  }
  ::llvm::StringRef getName() const override { return "LhloLegalizeToGpuPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LhloLegalizeToGpuPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class LhloLegalizeToParallelLoopsPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LhloLegalizeToParallelLoopsPassBase;

  LhloLegalizeToParallelLoopsPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LhloLegalizeToParallelLoopsPassBase(const LhloLegalizeToParallelLoopsPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("lhlo-legalize-to-parallel-loops");
  }
  ::llvm::StringRef getArgument() const override { return "lhlo-legalize-to-parallel-loops"; }

  ::llvm::StringRef getDescription() const override { return "Legalize from LHLO dialect to parallel loops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LhloLegalizeToParallelLoopsPass");
  }
  ::llvm::StringRef getName() const override { return "LhloLegalizeToParallelLoopsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LhloLegalizeToParallelLoopsPassBase<DerivedT>)

protected:
};
#undef GEN_PASS_CLASSES
#endif // GEN_PASS_CLASSES
