from tensor import Tensor,reset_gloabal_store,untrain,autograd_function
import tensor as tensor

import functional as F
program.use_fss_cmp = True
program.options_from_args()
BATCH_SIZE = 10
CHANNEL = 3
ROW = 8
COL = 8
KERNEL_ROW = 2
KERNEL_COL = 2

@autograd_function
def test_rfss3conv2d_relu():
    training_samples = MultiArray([BATCH_SIZE, CHANNEL, ROW, COL], sfix)
    for i in range(BATCH_SIZE):
        for j in range(CHANNEL):
            for k in range(ROW):
                for m in range(COL):
                    training_samples[i][j][k][m] = sfix(1)

    weight_v=MultiArray([BATCH_SIZE,CHANNEL,KERNEL_ROW,KERNEL_COL],sfix)
    for i in range(CHANNEL):
        for j in range(KERNEL_ROW):
            for k in range(KERNEL_COL):
                weight_v[0][i][j][k] = sfix(1)


    input = Tensor(training_samples, req_grad = True)
    weight=Tensor(weight_v,req_grad = True )
    output=F.rfss3_conv2d_relu(input,weight,padding=[2,2], groups = 1)
    output.backward()
    output.value.print_reveal_nested()
    weight.grad.print_reveal_nested()
    input.grad.print_reveal_nested()


@autograd_function
def test_conv2d_relu():
    print_ln("test_conv2d:")
    training_samples = MultiArray([BATCH_SIZE, CHANNEL, ROW, COL], sfix)
    for i in range(BATCH_SIZE):
        for j in range(CHANNEL):
            for k in range(ROW):
                for m in range(COL):
                    training_samples[i][j][k][m] = sfix(1)

    weight_v=MultiArray([BATCH_SIZE,CHANNEL,KERNEL_ROW,KERNEL_COL],sfix)
    for i in range(CHANNEL):
        for j in range(KERNEL_ROW):
            for k in range(KERNEL_COL):
                weight_v[0][i][j][k] = sfix(1)


    input = Tensor(training_samples, req_grad = True)
    weight=Tensor(weight_v,req_grad = True )
    output=F.conv2d(input,weight,padding=[2,2],groups = 1)
    output.backward()
    output.value.print_reveal_nested()
    weight.grad.print_reveal_nested()
    input.grad.print_reveal_nested()

# test_rfss3conv2d_relu()
test_conv2d_relu()
